(function () {
  'use strict';

  function _typeof(obj) {
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof = function (obj) {
        return typeof obj;
      };
    } else {
      _typeof = function (obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
    }

    return _typeof(obj);
  }

  function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
      var info = gen[key](arg);
      var value = info.value;
    } catch (error) {
      reject(error);
      return;
    }

    if (info.done) {
      resolve(value);
    } else {
      Promise.resolve(value).then(_next, _throw);
    }
  }

  function _asyncToGenerator(fn) {
    return function () {
      var self = this,
          args = arguments;
      return new Promise(function (resolve, reject) {
        var gen = fn.apply(self, args);

        function _next(value) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
        }

        function _throw(err) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
        }

        _next(undefined);
      });
    };
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
  }

  function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
  }

  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf(o, p);
  }

  function isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;

    try {
      Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
      return true;
    } catch (e) {
      return false;
    }
  }

  function _construct(Parent, args, Class) {
    if (isNativeReflectConstruct()) {
      _construct = Reflect.construct;
    } else {
      _construct = function _construct(Parent, args, Class) {
        var a = [null];
        a.push.apply(a, args);
        var Constructor = Function.bind.apply(Parent, a);
        var instance = new Constructor();
        if (Class) _setPrototypeOf(instance, Class.prototype);
        return instance;
      };
    }

    return _construct.apply(null, arguments);
  }

  function _objectDestructuringEmpty(obj) {
    if (obj == null) throw new TypeError("Cannot destructure undefined");
  }

  function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  function _possibleConstructorReturn(self, call) {
    if (call && (typeof call === "object" || typeof call === "function")) {
      return call;
    }

    return _assertThisInitialized(self);
  }

  function _superPropBase(object, property) {
    while (!Object.prototype.hasOwnProperty.call(object, property)) {
      object = _getPrototypeOf(object);
      if (object === null) break;
    }

    return object;
  }

  function _get(target, property, receiver) {
    if (typeof Reflect !== "undefined" && Reflect.get) {
      _get = Reflect.get;
    } else {
      _get = function _get(target, property, receiver) {
        var base = _superPropBase(target, property);

        if (!base) return;
        var desc = Object.getOwnPropertyDescriptor(base, property);

        if (desc.get) {
          return desc.get.call(receiver);
        }

        return desc.value;
      };
    }

    return _get(target, property, receiver || target);
  }

  function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();
  }

  function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();
  }

  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) {
      for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

      return arr2;
    }
  }

  function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
  }

  function _iterableToArray(iter) {
    if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
  }

  function _iterableToArrayLimit(arr, i) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance");
  }

  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance");
  }

  (function e(t, n, r) {
    function s(o, u) {
      if (!n[o]) {
        if (!t[o]) {
          var a = typeof require == "function" && require;
          if (!u && a) return a(o, !0);
          if (i) return i(o, !0);
          var f = new Error("Cannot find module '" + o + "'");
          throw f.code = "MODULE_NOT_FOUND", f;
        }

        var l = n[o] = {
          exports: {}
        };
        t[o][0].call(l.exports, function (e) {
          var n = t[o][1][e];
          return s(n ? n : e);
        }, l, l.exports, e, t, n, r);
      }

      return n[o].exports;
    }

    var i = typeof require == "function" && require;

    for (var o = 0; o < r.length; o++) {
      s(r[o]);
    }

    return s;
  })({
    1: [function (_dereq_, module, exports) {
      (function (global) {

        _dereq_(327);

        _dereq_(328);

        _dereq_(2);

        if (global._babelPolyfill) {
          throw new Error("only one instance of babel-polyfill is allowed");
        }

        global._babelPolyfill = true;
        var DEFINE_PROPERTY = "defineProperty";

        function define(O, key, value) {
          O[key] || Object[DEFINE_PROPERTY](O, key, {
            writable: true,
            configurable: true,
            value: value
          });
        }

        define(String.prototype, "padLeft", "".padStart);
        define(String.prototype, "padRight", "".padEnd);
        "pop,reverse,shift,keys,values,entries,indexOf,every,some,forEach,map,filter,find,findIndex,includes,join,slice,concat,push,splice,unshift,sort,lastIndexOf,reduce,reduceRight,copyWithin,fill".split(",").forEach(function (key) {
          [][key] && define(Array, key, Function.call.bind([][key]));
        });
      }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
    }, {
      "2": 2,
      "327": 327,
      "328": 328
    }],
    2: [function (_dereq_, module, exports) {
      _dereq_(130);

      module.exports = _dereq_(23).RegExp.escape;
    }, {
      "130": 130,
      "23": 23
    }],
    3: [function (_dereq_, module, exports) {
      module.exports = function (it) {
        if (typeof it != 'function') throw TypeError(it + ' is not a function!');
        return it;
      };
    }, {}],
    4: [function (_dereq_, module, exports) {
      var cof = _dereq_(18);

      module.exports = function (it, msg) {
        if (typeof it != 'number' && cof(it) != 'Number') throw TypeError(msg);
        return +it;
      };
    }, {
      "18": 18
    }],
    5: [function (_dereq_, module, exports) {
      // 22.1.3.31 Array.prototype[@@unscopables]
      var UNSCOPABLES = _dereq_(128)('unscopables');

      var ArrayProto = Array.prototype;
      if (ArrayProto[UNSCOPABLES] == undefined) _dereq_(42)(ArrayProto, UNSCOPABLES, {});

      module.exports = function (key) {
        ArrayProto[UNSCOPABLES][key] = true;
      };
    }, {
      "128": 128,
      "42": 42
    }],
    6: [function (_dereq_, module, exports) {
      module.exports = function (it, Constructor, name, forbiddenField) {
        if (!(it instanceof Constructor) || forbiddenField !== undefined && forbiddenField in it) {
          throw TypeError(name + ': incorrect invocation!');
        }

        return it;
      };
    }, {}],
    7: [function (_dereq_, module, exports) {
      var isObject = _dereq_(51);

      module.exports = function (it) {
        if (!isObject(it)) throw TypeError(it + ' is not an object!');
        return it;
      };
    }, {
      "51": 51
    }],
    8: [function (_dereq_, module, exports) {

      var toObject = _dereq_(119);

      var toAbsoluteIndex = _dereq_(114);

      var toLength = _dereq_(118);

      module.exports = [].copyWithin || function copyWithin(target
      /* = 0 */
      , start
      /* = 0, end = @length */
      ) {
        var O = toObject(this);
        var len = toLength(O.length);
        var to = toAbsoluteIndex(target, len);
        var from = toAbsoluteIndex(start, len);
        var end = arguments.length > 2 ? arguments[2] : undefined;
        var count = Math.min((end === undefined ? len : toAbsoluteIndex(end, len)) - from, len - to);
        var inc = 1;

        if (from < to && to < from + count) {
          inc = -1;
          from += count - 1;
          to += count - 1;
        }

        while (count-- > 0) {
          if (from in O) O[to] = O[from];else delete O[to];
          to += inc;
          from += inc;
        }

        return O;
      };
    }, {
      "114": 114,
      "118": 118,
      "119": 119
    }],
    9: [function (_dereq_, module, exports) {

      var toObject = _dereq_(119);

      var toAbsoluteIndex = _dereq_(114);

      var toLength = _dereq_(118);

      module.exports = function fill(value
      /* , start = 0, end = @length */
      ) {
        var O = toObject(this);
        var length = toLength(O.length);
        var aLen = arguments.length;
        var index = toAbsoluteIndex(aLen > 1 ? arguments[1] : undefined, length);
        var end = aLen > 2 ? arguments[2] : undefined;
        var endPos = end === undefined ? length : toAbsoluteIndex(end, length);

        while (endPos > index) {
          O[index++] = value;
        }

        return O;
      };
    }, {
      "114": 114,
      "118": 118,
      "119": 119
    }],
    10: [function (_dereq_, module, exports) {
      var forOf = _dereq_(39);

      module.exports = function (iter, ITERATOR) {
        var result = [];
        forOf(iter, false, result.push, result, ITERATOR);
        return result;
      };
    }, {
      "39": 39
    }],
    11: [function (_dereq_, module, exports) {
      // false -> Array#indexOf
      // true  -> Array#includes
      var toIObject = _dereq_(117);

      var toLength = _dereq_(118);

      var toAbsoluteIndex = _dereq_(114);

      module.exports = function (IS_INCLUDES) {
        return function ($this, el, fromIndex) {
          var O = toIObject($this);
          var length = toLength(O.length);
          var index = toAbsoluteIndex(fromIndex, length);
          var value; // Array#includes uses SameValueZero equality algorithm
          // eslint-disable-next-line no-self-compare

          if (IS_INCLUDES && el != el) while (length > index) {
            value = O[index++]; // eslint-disable-next-line no-self-compare

            if (value != value) return true; // Array#indexOf ignores holes, Array#includes - not
          } else for (; length > index; index++) {
            if (IS_INCLUDES || index in O) {
              if (O[index] === el) return IS_INCLUDES || index || 0;
            }
          }
          return !IS_INCLUDES && -1;
        };
      };
    }, {
      "114": 114,
      "117": 117,
      "118": 118
    }],
    12: [function (_dereq_, module, exports) {
      // 0 -> Array#forEach
      // 1 -> Array#map
      // 2 -> Array#filter
      // 3 -> Array#some
      // 4 -> Array#every
      // 5 -> Array#find
      // 6 -> Array#findIndex
      var ctx = _dereq_(25);

      var IObject = _dereq_(47);

      var toObject = _dereq_(119);

      var toLength = _dereq_(118);

      var asc = _dereq_(15);

      module.exports = function (TYPE, $create) {
        var IS_MAP = TYPE == 1;
        var IS_FILTER = TYPE == 2;
        var IS_SOME = TYPE == 3;
        var IS_EVERY = TYPE == 4;
        var IS_FIND_INDEX = TYPE == 6;
        var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
        var create = $create || asc;
        return function ($this, callbackfn, that) {
          var O = toObject($this);
          var self = IObject(O);
          var f = ctx(callbackfn, that, 3);
          var length = toLength(self.length);
          var index = 0;
          var result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined;
          var val, res;

          for (; length > index; index++) {
            if (NO_HOLES || index in self) {
              val = self[index];
              res = f(val, index, O);

              if (TYPE) {
                if (IS_MAP) result[index] = res; // map
                else if (res) switch (TYPE) {
                    case 3:
                      return true;
                    // some

                    case 5:
                      return val;
                    // find

                    case 6:
                      return index;
                    // findIndex

                    case 2:
                      result.push(val);
                    // filter
                  } else if (IS_EVERY) return false; // every
              }
            }
          }

          return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
        };
      };
    }, {
      "118": 118,
      "119": 119,
      "15": 15,
      "25": 25,
      "47": 47
    }],
    13: [function (_dereq_, module, exports) {
      var aFunction = _dereq_(3);

      var toObject = _dereq_(119);

      var IObject = _dereq_(47);

      var toLength = _dereq_(118);

      module.exports = function (that, callbackfn, aLen, memo, isRight) {
        aFunction(callbackfn);
        var O = toObject(that);
        var self = IObject(O);
        var length = toLength(O.length);
        var index = isRight ? length - 1 : 0;
        var i = isRight ? -1 : 1;
        if (aLen < 2) for (;;) {
          if (index in self) {
            memo = self[index];
            index += i;
            break;
          }

          index += i;

          if (isRight ? index < 0 : length <= index) {
            throw TypeError('Reduce of empty array with no initial value');
          }
        }

        for (; isRight ? index >= 0 : length > index; index += i) {
          if (index in self) {
            memo = callbackfn(memo, self[index], index, O);
          }
        }

        return memo;
      };
    }, {
      "118": 118,
      "119": 119,
      "3": 3,
      "47": 47
    }],
    14: [function (_dereq_, module, exports) {
      var isObject = _dereq_(51);

      var isArray = _dereq_(49);

      var SPECIES = _dereq_(128)('species');

      module.exports = function (original) {
        var C;

        if (isArray(original)) {
          C = original.constructor; // cross-realm fallback

          if (typeof C == 'function' && (C === Array || isArray(C.prototype))) C = undefined;

          if (isObject(C)) {
            C = C[SPECIES];
            if (C === null) C = undefined;
          }
        }

        return C === undefined ? Array : C;
      };
    }, {
      "128": 128,
      "49": 49,
      "51": 51
    }],
    15: [function (_dereq_, module, exports) {
      // 9.4.2.3 ArraySpeciesCreate(originalArray, length)
      var speciesConstructor = _dereq_(14);

      module.exports = function (original, length) {
        return new (speciesConstructor(original))(length);
      };
    }, {
      "14": 14
    }],
    16: [function (_dereq_, module, exports) {

      var aFunction = _dereq_(3);

      var isObject = _dereq_(51);

      var invoke = _dereq_(46);

      var arraySlice = [].slice;
      var factories = {};

      var construct = function construct(F, len, args) {
        if (!(len in factories)) {
          for (var n = [], i = 0; i < len; i++) {
            n[i] = 'a[' + i + ']';
          } // eslint-disable-next-line no-new-func


          factories[len] = Function('F,a', 'return new F(' + n.join(',') + ')');
        }

        return factories[len](F, args);
      };

      module.exports = Function.bind || function bind(that
      /* , ...args */
      ) {
        var fn = aFunction(this);
        var partArgs = arraySlice.call(arguments, 1);

        var bound = function bound()
        /* args... */
        {
          var args = partArgs.concat(arraySlice.call(arguments));
          return this instanceof bound ? construct(fn, args.length, args) : invoke(fn, args, that);
        };

        if (isObject(fn.prototype)) bound.prototype = fn.prototype;
        return bound;
      };
    }, {
      "3": 3,
      "46": 46,
      "51": 51
    }],
    17: [function (_dereq_, module, exports) {
      // getting tag from 19.1.3.6 Object.prototype.toString()
      var cof = _dereq_(18);

      var TAG = _dereq_(128)('toStringTag'); // ES3 wrong here


      var ARG = cof(function () {
        return arguments;
      }()) == 'Arguments'; // fallback for IE11 Script Access Denied error

      var tryGet = function tryGet(it, key) {
        try {
          return it[key];
        } catch (e) {
          /* empty */
        }
      };

      module.exports = function (it) {
        var O, T, B;
        return it === undefined ? 'Undefined' : it === null ? 'Null' // @@toStringTag case
        : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T // builtinTag case
        : ARG ? cof(O) // ES3 arguments fallback
        : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
      };
    }, {
      "128": 128,
      "18": 18
    }],
    18: [function (_dereq_, module, exports) {
      var toString = {}.toString;

      module.exports = function (it) {
        return toString.call(it).slice(8, -1);
      };
    }, {}],
    19: [function (_dereq_, module, exports) {

      var dP = _dereq_(72).f;

      var create = _dereq_(71);

      var redefineAll = _dereq_(93);

      var ctx = _dereq_(25);

      var anInstance = _dereq_(6);

      var forOf = _dereq_(39);

      var $iterDefine = _dereq_(55);

      var step = _dereq_(57);

      var setSpecies = _dereq_(100);

      var DESCRIPTORS = _dereq_(29);

      var fastKey = _dereq_(66).fastKey;

      var validate = _dereq_(125);

      var SIZE = DESCRIPTORS ? '_s' : 'size';

      var getEntry = function getEntry(that, key) {
        // fast case
        var index = fastKey(key);
        var entry;
        if (index !== 'F') return that._i[index]; // frozen object case

        for (entry = that._f; entry; entry = entry.n) {
          if (entry.k == key) return entry;
        }
      };

      module.exports = {
        getConstructor: function getConstructor(wrapper, NAME, IS_MAP, ADDER) {
          var C = wrapper(function (that, iterable) {
            anInstance(that, C, NAME, '_i');
            that._t = NAME; // collection type

            that._i = create(null); // index

            that._f = undefined; // first entry

            that._l = undefined; // last entry

            that[SIZE] = 0; // size

            if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
          });
          redefineAll(C.prototype, {
            // 23.1.3.1 Map.prototype.clear()
            // 23.2.3.2 Set.prototype.clear()
            clear: function clear() {
              for (var that = validate(this, NAME), data = that._i, entry = that._f; entry; entry = entry.n) {
                entry.r = true;
                if (entry.p) entry.p = entry.p.n = undefined;
                delete data[entry.i];
              }

              that._f = that._l = undefined;
              that[SIZE] = 0;
            },
            // 23.1.3.3 Map.prototype.delete(key)
            // 23.2.3.4 Set.prototype.delete(value)
            'delete': function _delete(key) {
              var that = validate(this, NAME);
              var entry = getEntry(that, key);

              if (entry) {
                var next = entry.n;
                var prev = entry.p;
                delete that._i[entry.i];
                entry.r = true;
                if (prev) prev.n = next;
                if (next) next.p = prev;
                if (that._f == entry) that._f = next;
                if (that._l == entry) that._l = prev;
                that[SIZE]--;
              }

              return !!entry;
            },
            // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
            // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
            forEach: function forEach(callbackfn
            /* , that = undefined */
            ) {
              validate(this, NAME);
              var f = ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);
              var entry;

              while (entry = entry ? entry.n : this._f) {
                f(entry.v, entry.k, this); // revert to the last existing entry

                while (entry && entry.r) {
                  entry = entry.p;
                }
              }
            },
            // 23.1.3.7 Map.prototype.has(key)
            // 23.2.3.7 Set.prototype.has(value)
            has: function has(key) {
              return !!getEntry(validate(this, NAME), key);
            }
          });
          if (DESCRIPTORS) dP(C.prototype, 'size', {
            get: function get() {
              return validate(this, NAME)[SIZE];
            }
          });
          return C;
        },
        def: function def(that, key, value) {
          var entry = getEntry(that, key);
          var prev, index; // change existing entry

          if (entry) {
            entry.v = value; // create new entry
          } else {
            that._l = entry = {
              i: index = fastKey(key, true),
              // <- index
              k: key,
              // <- key
              v: value,
              // <- value
              p: prev = that._l,
              // <- previous entry
              n: undefined,
              // <- next entry
              r: false // <- removed

            };
            if (!that._f) that._f = entry;
            if (prev) prev.n = entry;
            that[SIZE]++; // add to index

            if (index !== 'F') that._i[index] = entry;
          }

          return that;
        },
        getEntry: getEntry,
        setStrong: function setStrong(C, NAME, IS_MAP) {
          // add .keys, .values, .entries, [@@iterator]
          // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
          $iterDefine(C, NAME, function (iterated, kind) {
            this._t = validate(iterated, NAME); // target

            this._k = kind; // kind

            this._l = undefined; // previous
          }, function () {
            var that = this;
            var kind = that._k;
            var entry = that._l; // revert to the last existing entry

            while (entry && entry.r) {
              entry = entry.p;
            } // get next entry


            if (!that._t || !(that._l = entry = entry ? entry.n : that._t._f)) {
              // or finish the iteration
              that._t = undefined;
              return step(1);
            } // return step by kind


            if (kind == 'keys') return step(0, entry.k);
            if (kind == 'values') return step(0, entry.v);
            return step(0, [entry.k, entry.v]);
          }, IS_MAP ? 'entries' : 'values', !IS_MAP, true); // add [@@species], 23.1.2.2, 23.2.2.2

          setSpecies(NAME);
        }
      };
    }, {
      "100": 100,
      "125": 125,
      "25": 25,
      "29": 29,
      "39": 39,
      "55": 55,
      "57": 57,
      "6": 6,
      "66": 66,
      "71": 71,
      "72": 72,
      "93": 93
    }],
    20: [function (_dereq_, module, exports) {
      // https://github.com/DavidBruant/Map-Set.prototype.toJSON
      var classof = _dereq_(17);

      var from = _dereq_(10);

      module.exports = function (NAME) {
        return function toJSON() {
          if (classof(this) != NAME) throw TypeError(NAME + "#toJSON isn't generic");
          return from(this);
        };
      };
    }, {
      "10": 10,
      "17": 17
    }],
    21: [function (_dereq_, module, exports) {

      var redefineAll = _dereq_(93);

      var getWeak = _dereq_(66).getWeak;

      var anObject = _dereq_(7);

      var isObject = _dereq_(51);

      var anInstance = _dereq_(6);

      var forOf = _dereq_(39);

      var createArrayMethod = _dereq_(12);

      var $has = _dereq_(41);

      var validate = _dereq_(125);

      var arrayFind = createArrayMethod(5);
      var arrayFindIndex = createArrayMethod(6);
      var id = 0; // fallback for uncaught frozen keys

      var uncaughtFrozenStore = function uncaughtFrozenStore(that) {
        return that._l || (that._l = new UncaughtFrozenStore());
      };

      var UncaughtFrozenStore = function UncaughtFrozenStore() {
        this.a = [];
      };

      var findUncaughtFrozen = function findUncaughtFrozen(store, key) {
        return arrayFind(store.a, function (it) {
          return it[0] === key;
        });
      };

      UncaughtFrozenStore.prototype = {
        get: function get(key) {
          var entry = findUncaughtFrozen(this, key);
          if (entry) return entry[1];
        },
        has: function has(key) {
          return !!findUncaughtFrozen(this, key);
        },
        set: function set(key, value) {
          var entry = findUncaughtFrozen(this, key);
          if (entry) entry[1] = value;else this.a.push([key, value]);
        },
        'delete': function _delete(key) {
          var index = arrayFindIndex(this.a, function (it) {
            return it[0] === key;
          });
          if (~index) this.a.splice(index, 1);
          return !!~index;
        }
      };
      module.exports = {
        getConstructor: function getConstructor(wrapper, NAME, IS_MAP, ADDER) {
          var C = wrapper(function (that, iterable) {
            anInstance(that, C, NAME, '_i');
            that._t = NAME; // collection type

            that._i = id++; // collection id

            that._l = undefined; // leak store for uncaught frozen objects

            if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
          });
          redefineAll(C.prototype, {
            // 23.3.3.2 WeakMap.prototype.delete(key)
            // 23.4.3.3 WeakSet.prototype.delete(value)
            'delete': function _delete(key) {
              if (!isObject(key)) return false;
              var data = getWeak(key);
              if (data === true) return uncaughtFrozenStore(validate(this, NAME))['delete'](key);
              return data && $has(data, this._i) && delete data[this._i];
            },
            // 23.3.3.4 WeakMap.prototype.has(key)
            // 23.4.3.4 WeakSet.prototype.has(value)
            has: function has(key) {
              if (!isObject(key)) return false;
              var data = getWeak(key);
              if (data === true) return uncaughtFrozenStore(validate(this, NAME)).has(key);
              return data && $has(data, this._i);
            }
          });
          return C;
        },
        def: function def(that, key, value) {
          var data = getWeak(anObject(key), true);
          if (data === true) uncaughtFrozenStore(that).set(key, value);else data[that._i] = value;
          return that;
        },
        ufstore: uncaughtFrozenStore
      };
    }, {
      "12": 12,
      "125": 125,
      "39": 39,
      "41": 41,
      "51": 51,
      "6": 6,
      "66": 66,
      "7": 7,
      "93": 93
    }],
    22: [function (_dereq_, module, exports) {

      var global = _dereq_(40);

      var $export = _dereq_(33);

      var redefine = _dereq_(94);

      var redefineAll = _dereq_(93);

      var meta = _dereq_(66);

      var forOf = _dereq_(39);

      var anInstance = _dereq_(6);

      var isObject = _dereq_(51);

      var fails = _dereq_(35);

      var $iterDetect = _dereq_(56);

      var setToStringTag = _dereq_(101);

      var inheritIfRequired = _dereq_(45);

      module.exports = function (NAME, wrapper, methods, common, IS_MAP, IS_WEAK) {
        var Base = global[NAME];
        var C = Base;
        var ADDER = IS_MAP ? 'set' : 'add';
        var proto = C && C.prototype;
        var O = {};

        var fixMethod = function fixMethod(KEY) {
          var fn = proto[KEY];
          redefine(proto, KEY, KEY == 'delete' ? function (a) {
            return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
          } : KEY == 'has' ? function has(a) {
            return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
          } : KEY == 'get' ? function get(a) {
            return IS_WEAK && !isObject(a) ? undefined : fn.call(this, a === 0 ? 0 : a);
          } : KEY == 'add' ? function add(a) {
            fn.call(this, a === 0 ? 0 : a);
            return this;
          } : function set(a, b) {
            fn.call(this, a === 0 ? 0 : a, b);
            return this;
          });
        };

        if (typeof C != 'function' || !(IS_WEAK || proto.forEach && !fails(function () {
          new C().entries().next();
        }))) {
          // create collection constructor
          C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
          redefineAll(C.prototype, methods);
          meta.NEED = true;
        } else {
          var instance = new C(); // early implementations not supports chaining

          var HASNT_CHAINING = instance[ADDER](IS_WEAK ? {} : -0, 1) != instance; // V8 ~  Chromium 40- weak-collections throws on primitives, but should return false

          var THROWS_ON_PRIMITIVES = fails(function () {
            instance.has(1);
          }); // most early implementations doesn't supports iterables, most modern - not close it correctly

          var ACCEPT_ITERABLES = $iterDetect(function (iter) {
            new C(iter);
          }); // eslint-disable-line no-new
          // for early implementations -0 and +0 not the same

          var BUGGY_ZERO = !IS_WEAK && fails(function () {
            // V8 ~ Chromium 42- fails only with 5+ elements
            var $instance = new C();
            var index = 5;

            while (index--) {
              $instance[ADDER](index, index);
            }

            return !$instance.has(-0);
          });

          if (!ACCEPT_ITERABLES) {
            C = wrapper(function (target, iterable) {
              anInstance(target, C, NAME);
              var that = inheritIfRequired(new Base(), target, C);
              if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
              return that;
            });
            C.prototype = proto;
            proto.constructor = C;
          }

          if (THROWS_ON_PRIMITIVES || BUGGY_ZERO) {
            fixMethod('delete');
            fixMethod('has');
            IS_MAP && fixMethod('get');
          }

          if (BUGGY_ZERO || HASNT_CHAINING) fixMethod(ADDER); // weak collections should not contains .clear method

          if (IS_WEAK && proto.clear) delete proto.clear;
        }

        setToStringTag(C, NAME);
        O[NAME] = C;
        $export($export.G + $export.W + $export.F * (C != Base), O);
        if (!IS_WEAK) common.setStrong(C, NAME, IS_MAP);
        return C;
      };
    }, {
      "101": 101,
      "33": 33,
      "35": 35,
      "39": 39,
      "40": 40,
      "45": 45,
      "51": 51,
      "56": 56,
      "6": 6,
      "66": 66,
      "93": 93,
      "94": 94
    }],
    23: [function (_dereq_, module, exports) {
      var core = module.exports = {
        version: '2.5.0'
      };
      if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef
    }, {}],
    24: [function (_dereq_, module, exports) {

      var $defineProperty = _dereq_(72);

      var createDesc = _dereq_(92);

      module.exports = function (object, index, value) {
        if (index in object) $defineProperty.f(object, index, createDesc(0, value));else object[index] = value;
      };
    }, {
      "72": 72,
      "92": 92
    }],
    25: [function (_dereq_, module, exports) {
      // optional / simple context binding
      var aFunction = _dereq_(3);

      module.exports = function (fn, that, length) {
        aFunction(fn);
        if (that === undefined) return fn;

        switch (length) {
          case 1:
            return function (a) {
              return fn.call(that, a);
            };

          case 2:
            return function (a, b) {
              return fn.call(that, a, b);
            };

          case 3:
            return function (a, b, c) {
              return fn.call(that, a, b, c);
            };
        }

        return function ()
        /* ...args */
        {
          return fn.apply(that, arguments);
        };
      };
    }, {
      "3": 3
    }],
    26: [function (_dereq_, module, exports) {

      var fails = _dereq_(35);

      var getTime = Date.prototype.getTime;
      var $toISOString = Date.prototype.toISOString;

      var lz = function lz(num) {
        return num > 9 ? num : '0' + num;
      }; // PhantomJS / old WebKit has a broken implementations


      module.exports = fails(function () {
        return $toISOString.call(new Date(-5e13 - 1)) != '0385-07-25T07:06:39.999Z';
      }) || !fails(function () {
        $toISOString.call(new Date(NaN));
      }) ? function toISOString() {
        if (!isFinite(getTime.call(this))) throw RangeError('Invalid time value');
        var d = this;
        var y = d.getUTCFullYear();
        var m = d.getUTCMilliseconds();
        var s = y < 0 ? '-' : y > 9999 ? '+' : '';
        return s + ('00000' + Math.abs(y)).slice(s ? -6 : -4) + '-' + lz(d.getUTCMonth() + 1) + '-' + lz(d.getUTCDate()) + 'T' + lz(d.getUTCHours()) + ':' + lz(d.getUTCMinutes()) + ':' + lz(d.getUTCSeconds()) + '.' + (m > 99 ? m : '0' + lz(m)) + 'Z';
      } : $toISOString;
    }, {
      "35": 35
    }],
    27: [function (_dereq_, module, exports) {

      var anObject = _dereq_(7);

      var toPrimitive = _dereq_(120);

      var NUMBER = 'number';

      module.exports = function (hint) {
        if (hint !== 'string' && hint !== NUMBER && hint !== 'default') throw TypeError('Incorrect hint');
        return toPrimitive(anObject(this), hint != NUMBER);
      };
    }, {
      "120": 120,
      "7": 7
    }],
    28: [function (_dereq_, module, exports) {
      // 7.2.1 RequireObjectCoercible(argument)
      module.exports = function (it) {
        if (it == undefined) throw TypeError("Can't call method on  " + it);
        return it;
      };
    }, {}],
    29: [function (_dereq_, module, exports) {
      // Thank's IE8 for his funny defineProperty
      module.exports = !_dereq_(35)(function () {
        return Object.defineProperty({}, 'a', {
          get: function get() {
            return 7;
          }
        }).a != 7;
      });
    }, {
      "35": 35
    }],
    30: [function (_dereq_, module, exports) {
      var isObject = _dereq_(51);

      var document = _dereq_(40).document; // typeof document.createElement is 'object' in old IE


      var is = isObject(document) && isObject(document.createElement);

      module.exports = function (it) {
        return is ? document.createElement(it) : {};
      };
    }, {
      "40": 40,
      "51": 51
    }],
    31: [function (_dereq_, module, exports) {
      // IE 8- don't enum bug keys
      module.exports = 'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'.split(',');
    }, {}],
    32: [function (_dereq_, module, exports) {
      // all enumerable object keys, includes symbols
      var getKeys = _dereq_(81);

      var gOPS = _dereq_(78);

      var pIE = _dereq_(82);

      module.exports = function (it) {
        var result = getKeys(it);
        var getSymbols = gOPS.f;

        if (getSymbols) {
          var symbols = getSymbols(it);
          var isEnum = pIE.f;
          var i = 0;
          var key;

          while (symbols.length > i) {
            if (isEnum.call(it, key = symbols[i++])) result.push(key);
          }
        }

        return result;
      };
    }, {
      "78": 78,
      "81": 81,
      "82": 82
    }],
    33: [function (_dereq_, module, exports) {
      var global = _dereq_(40);

      var core = _dereq_(23);

      var hide = _dereq_(42);

      var redefine = _dereq_(94);

      var ctx = _dereq_(25);

      var PROTOTYPE = 'prototype';

      var $export = function $export(type, name, source) {
        var IS_FORCED = type & $export.F;
        var IS_GLOBAL = type & $export.G;
        var IS_STATIC = type & $export.S;
        var IS_PROTO = type & $export.P;
        var IS_BIND = type & $export.B;
        var target = IS_GLOBAL ? global : IS_STATIC ? global[name] || (global[name] = {}) : (global[name] || {})[PROTOTYPE];
        var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});
        var expProto = exports[PROTOTYPE] || (exports[PROTOTYPE] = {});
        var key, own, out, exp;
        if (IS_GLOBAL) source = name;

        for (key in source) {
          // contains in native
          own = !IS_FORCED && target && target[key] !== undefined; // export native or passed

          out = (own ? target : source)[key]; // bind timers to global for call from export context

          exp = IS_BIND && own ? ctx(out, global) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out; // extend global

          if (target) redefine(target, key, out, type & $export.U); // export

          if (exports[key] != out) hide(exports, key, exp);
          if (IS_PROTO && expProto[key] != out) expProto[key] = out;
        }
      };

      global.core = core; // type bitmap

      $export.F = 1; // forced

      $export.G = 2; // global

      $export.S = 4; // static

      $export.P = 8; // proto

      $export.B = 16; // bind

      $export.W = 32; // wrap

      $export.U = 64; // safe

      $export.R = 128; // real proto method for `library`

      module.exports = $export;
    }, {
      "23": 23,
      "25": 25,
      "40": 40,
      "42": 42,
      "94": 94
    }],
    34: [function (_dereq_, module, exports) {
      var MATCH = _dereq_(128)('match');

      module.exports = function (KEY) {
        var re = /./;

        try {
          '/./'[KEY](re);
        } catch (e) {
          try {
            re[MATCH] = false;
            return !'/./'[KEY](re);
          } catch (f) {
            /* empty */
          }
        }

        return true;
      };
    }, {
      "128": 128
    }],
    35: [function (_dereq_, module, exports) {
      module.exports = function (exec) {
        try {
          return !!exec();
        } catch (e) {
          return true;
        }
      };
    }, {}],
    36: [function (_dereq_, module, exports) {

      var hide = _dereq_(42);

      var redefine = _dereq_(94);

      var fails = _dereq_(35);

      var defined = _dereq_(28);

      var wks = _dereq_(128);

      module.exports = function (KEY, length, exec) {
        var SYMBOL = wks(KEY);
        var fns = exec(defined, SYMBOL, ''[KEY]);
        var strfn = fns[0];
        var rxfn = fns[1];

        if (fails(function () {
          var O = {};

          O[SYMBOL] = function () {
            return 7;
          };

          return ''[KEY](O) != 7;
        })) {
          redefine(String.prototype, KEY, strfn);
          hide(RegExp.prototype, SYMBOL, length == 2 // 21.2.5.8 RegExp.prototype[@@replace](string, replaceValue)
          // 21.2.5.11 RegExp.prototype[@@split](string, limit)
          ? function (string, arg) {
            return rxfn.call(string, this, arg);
          } // 21.2.5.6 RegExp.prototype[@@match](string)
          // 21.2.5.9 RegExp.prototype[@@search](string)
          : function (string) {
            return rxfn.call(string, this);
          });
        }
      };
    }, {
      "128": 128,
      "28": 28,
      "35": 35,
      "42": 42,
      "94": 94
    }],
    37: [function (_dereq_, module, exports) {

      var anObject = _dereq_(7);

      module.exports = function () {
        var that = anObject(this);
        var result = '';
        if (that.global) result += 'g';
        if (that.ignoreCase) result += 'i';
        if (that.multiline) result += 'm';
        if (that.unicode) result += 'u';
        if (that.sticky) result += 'y';
        return result;
      };
    }, {
      "7": 7
    }],
    38: [function (_dereq_, module, exports) {

      var isArray = _dereq_(49);

      var isObject = _dereq_(51);

      var toLength = _dereq_(118);

      var ctx = _dereq_(25);

      var IS_CONCAT_SPREADABLE = _dereq_(128)('isConcatSpreadable');

      function flattenIntoArray(target, original, source, sourceLen, start, depth, mapper, thisArg) {
        var targetIndex = start;
        var sourceIndex = 0;
        var mapFn = mapper ? ctx(mapper, thisArg, 3) : false;
        var element, spreadable;

        while (sourceIndex < sourceLen) {
          if (sourceIndex in source) {
            element = mapFn ? mapFn(source[sourceIndex], sourceIndex, original) : source[sourceIndex];
            spreadable = false;

            if (isObject(element)) {
              spreadable = element[IS_CONCAT_SPREADABLE];
              spreadable = spreadable !== undefined ? !!spreadable : isArray(element);
            }

            if (spreadable && depth > 0) {
              targetIndex = flattenIntoArray(target, original, element, toLength(element.length), targetIndex, depth - 1) - 1;
            } else {
              if (targetIndex >= 0x1fffffffffffff) throw TypeError();
              target[targetIndex] = element;
            }

            targetIndex++;
          }

          sourceIndex++;
        }

        return targetIndex;
      }

      module.exports = flattenIntoArray;
    }, {
      "118": 118,
      "128": 128,
      "25": 25,
      "49": 49,
      "51": 51
    }],
    39: [function (_dereq_, module, exports) {
      var ctx = _dereq_(25);

      var call = _dereq_(53);

      var isArrayIter = _dereq_(48);

      var anObject = _dereq_(7);

      var toLength = _dereq_(118);

      var getIterFn = _dereq_(129);

      var BREAK = {};
      var RETURN = {};

      var exports = module.exports = function (iterable, entries, fn, that, ITERATOR) {
        var iterFn = ITERATOR ? function () {
          return iterable;
        } : getIterFn(iterable);
        var f = ctx(fn, that, entries ? 2 : 1);
        var index = 0;
        var length, step, iterator, result;
        if (typeof iterFn != 'function') throw TypeError(iterable + ' is not iterable!'); // fast case for arrays with default iterator

        if (isArrayIter(iterFn)) for (length = toLength(iterable.length); length > index; index++) {
          result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
          if (result === BREAK || result === RETURN) return result;
        } else for (iterator = iterFn.call(iterable); !(step = iterator.next()).done;) {
          result = call(iterator, f, step.value, entries);
          if (result === BREAK || result === RETURN) return result;
        }
      };

      exports.BREAK = BREAK;
      exports.RETURN = RETURN;
    }, {
      "118": 118,
      "129": 129,
      "25": 25,
      "48": 48,
      "53": 53,
      "7": 7
    }],
    40: [function (_dereq_, module, exports) {
      // https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
      var global = module.exports = typeof window != 'undefined' && window.Math == Math ? window : typeof self != 'undefined' && self.Math == Math ? self // eslint-disable-next-line no-new-func
      : Function('return this')();
      if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef
    }, {}],
    41: [function (_dereq_, module, exports) {
      var hasOwnProperty = {}.hasOwnProperty;

      module.exports = function (it, key) {
        return hasOwnProperty.call(it, key);
      };
    }, {}],
    42: [function (_dereq_, module, exports) {
      var dP = _dereq_(72);

      var createDesc = _dereq_(92);

      module.exports = _dereq_(29) ? function (object, key, value) {
        return dP.f(object, key, createDesc(1, value));
      } : function (object, key, value) {
        object[key] = value;
        return object;
      };
    }, {
      "29": 29,
      "72": 72,
      "92": 92
    }],
    43: [function (_dereq_, module, exports) {
      var document = _dereq_(40).document;

      module.exports = document && document.documentElement;
    }, {
      "40": 40
    }],
    44: [function (_dereq_, module, exports) {
      module.exports = !_dereq_(29) && !_dereq_(35)(function () {
        return Object.defineProperty(_dereq_(30)('div'), 'a', {
          get: function get() {
            return 7;
          }
        }).a != 7;
      });
    }, {
      "29": 29,
      "30": 30,
      "35": 35
    }],
    45: [function (_dereq_, module, exports) {
      var isObject = _dereq_(51);

      var setPrototypeOf = _dereq_(99).set;

      module.exports = function (that, target, C) {
        var S = target.constructor;
        var P;

        if (S !== C && typeof S == 'function' && (P = S.prototype) !== C.prototype && isObject(P) && setPrototypeOf) {
          setPrototypeOf(that, P);
        }

        return that;
      };
    }, {
      "51": 51,
      "99": 99
    }],
    46: [function (_dereq_, module, exports) {
      // fast apply, http://jsperf.lnkit.com/fast-apply/5
      module.exports = function (fn, args, that) {
        var un = that === undefined;

        switch (args.length) {
          case 0:
            return un ? fn() : fn.call(that);

          case 1:
            return un ? fn(args[0]) : fn.call(that, args[0]);

          case 2:
            return un ? fn(args[0], args[1]) : fn.call(that, args[0], args[1]);

          case 3:
            return un ? fn(args[0], args[1], args[2]) : fn.call(that, args[0], args[1], args[2]);

          case 4:
            return un ? fn(args[0], args[1], args[2], args[3]) : fn.call(that, args[0], args[1], args[2], args[3]);
        }

        return fn.apply(that, args);
      };
    }, {}],
    47: [function (_dereq_, module, exports) {
      // fallback for non-array-like ES3 and non-enumerable old V8 strings
      var cof = _dereq_(18); // eslint-disable-next-line no-prototype-builtins


      module.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
        return cof(it) == 'String' ? it.split('') : Object(it);
      };
    }, {
      "18": 18
    }],
    48: [function (_dereq_, module, exports) {
      // check on default Array iterator
      var Iterators = _dereq_(58);

      var ITERATOR = _dereq_(128)('iterator');

      var ArrayProto = Array.prototype;

      module.exports = function (it) {
        return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
      };
    }, {
      "128": 128,
      "58": 58
    }],
    49: [function (_dereq_, module, exports) {
      // 7.2.2 IsArray(argument)
      var cof = _dereq_(18);

      module.exports = Array.isArray || function isArray(arg) {
        return cof(arg) == 'Array';
      };
    }, {
      "18": 18
    }],
    50: [function (_dereq_, module, exports) {
      // 20.1.2.3 Number.isInteger(number)
      var isObject = _dereq_(51);

      var floor = Math.floor;

      module.exports = function isInteger(it) {
        return !isObject(it) && isFinite(it) && floor(it) === it;
      };
    }, {
      "51": 51
    }],
    51: [function (_dereq_, module, exports) {
      module.exports = function (it) {
        return _typeof(it) === 'object' ? it !== null : typeof it === 'function';
      };
    }, {}],
    52: [function (_dereq_, module, exports) {
      // 7.2.8 IsRegExp(argument)
      var isObject = _dereq_(51);

      var cof = _dereq_(18);

      var MATCH = _dereq_(128)('match');

      module.exports = function (it) {
        var isRegExp;
        return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : cof(it) == 'RegExp');
      };
    }, {
      "128": 128,
      "18": 18,
      "51": 51
    }],
    53: [function (_dereq_, module, exports) {
      // call something on iterator step with safe closing on error
      var anObject = _dereq_(7);

      module.exports = function (iterator, fn, value, entries) {
        try {
          return entries ? fn(anObject(value)[0], value[1]) : fn(value); // 7.4.6 IteratorClose(iterator, completion)
        } catch (e) {
          var ret = iterator['return'];
          if (ret !== undefined) anObject(ret.call(iterator));
          throw e;
        }
      };
    }, {
      "7": 7
    }],
    54: [function (_dereq_, module, exports) {

      var create = _dereq_(71);

      var descriptor = _dereq_(92);

      var setToStringTag = _dereq_(101);

      var IteratorPrototype = {}; // 25.1.2.1.1 %IteratorPrototype%[@@iterator]()

      _dereq_(42)(IteratorPrototype, _dereq_(128)('iterator'), function () {
        return this;
      });

      module.exports = function (Constructor, NAME, next) {
        Constructor.prototype = create(IteratorPrototype, {
          next: descriptor(1, next)
        });
        setToStringTag(Constructor, NAME + ' Iterator');
      };
    }, {
      "101": 101,
      "128": 128,
      "42": 42,
      "71": 71,
      "92": 92
    }],
    55: [function (_dereq_, module, exports) {

      var LIBRARY = _dereq_(60);

      var $export = _dereq_(33);

      var redefine = _dereq_(94);

      var hide = _dereq_(42);

      var has = _dereq_(41);

      var Iterators = _dereq_(58);

      var $iterCreate = _dereq_(54);

      var setToStringTag = _dereq_(101);

      var getPrototypeOf = _dereq_(79);

      var ITERATOR = _dereq_(128)('iterator');

      var BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`

      var FF_ITERATOR = '@@iterator';
      var KEYS = 'keys';
      var VALUES = 'values';

      var returnThis = function returnThis() {
        return this;
      };

      module.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
        $iterCreate(Constructor, NAME, next);

        var getMethod = function getMethod(kind) {
          if (!BUGGY && kind in proto) return proto[kind];

          switch (kind) {
            case KEYS:
              return function keys() {
                return new Constructor(this, kind);
              };

            case VALUES:
              return function values() {
                return new Constructor(this, kind);
              };
          }

          return function entries() {
            return new Constructor(this, kind);
          };
        };

        var TAG = NAME + ' Iterator';
        var DEF_VALUES = DEFAULT == VALUES;
        var VALUES_BUG = false;
        var proto = Base.prototype;
        var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
        var $default = $native || getMethod(DEFAULT);
        var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;
        var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;
        var methods, key, IteratorPrototype; // Fix native

        if ($anyNative) {
          IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));

          if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
            // Set @@toStringTag to native iterators
            setToStringTag(IteratorPrototype, TAG, true); // fix for some old engines

            if (!LIBRARY && !has(IteratorPrototype, ITERATOR)) hide(IteratorPrototype, ITERATOR, returnThis);
          }
        } // fix Array#{values, @@iterator}.name in V8 / FF


        if (DEF_VALUES && $native && $native.name !== VALUES) {
          VALUES_BUG = true;

          $default = function values() {
            return $native.call(this);
          };
        } // Define iterator


        if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
          hide(proto, ITERATOR, $default);
        } // Plug for library


        Iterators[NAME] = $default;
        Iterators[TAG] = returnThis;

        if (DEFAULT) {
          methods = {
            values: DEF_VALUES ? $default : getMethod(VALUES),
            keys: IS_SET ? $default : getMethod(KEYS),
            entries: $entries
          };
          if (FORCED) for (key in methods) {
            if (!(key in proto)) redefine(proto, key, methods[key]);
          } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
        }

        return methods;
      };
    }, {
      "101": 101,
      "128": 128,
      "33": 33,
      "41": 41,
      "42": 42,
      "54": 54,
      "58": 58,
      "60": 60,
      "79": 79,
      "94": 94
    }],
    56: [function (_dereq_, module, exports) {
      var ITERATOR = _dereq_(128)('iterator');

      var SAFE_CLOSING = false;

      try {
        var riter = [7][ITERATOR]();

        riter['return'] = function () {
          SAFE_CLOSING = true;
        }; // eslint-disable-next-line no-throw-literal


        Array.from(riter, function () {
          throw 2;
        });
      } catch (e) {
        /* empty */
      }

      module.exports = function (exec, skipClosing) {
        if (!skipClosing && !SAFE_CLOSING) return false;
        var safe = false;

        try {
          var arr = [7];
          var iter = arr[ITERATOR]();

          iter.next = function () {
            return {
              done: safe = true
            };
          };

          arr[ITERATOR] = function () {
            return iter;
          };

          exec(arr);
        } catch (e) {
          /* empty */
        }

        return safe;
      };
    }, {
      "128": 128
    }],
    57: [function (_dereq_, module, exports) {
      module.exports = function (done, value) {
        return {
          value: value,
          done: !!done
        };
      };
    }, {}],
    58: [function (_dereq_, module, exports) {
      module.exports = {};
    }, {}],
    59: [function (_dereq_, module, exports) {
      var getKeys = _dereq_(81);

      var toIObject = _dereq_(117);

      module.exports = function (object, el) {
        var O = toIObject(object);
        var keys = getKeys(O);
        var length = keys.length;
        var index = 0;
        var key;

        while (length > index) {
          if (O[key = keys[index++]] === el) return key;
        }
      };
    }, {
      "117": 117,
      "81": 81
    }],
    60: [function (_dereq_, module, exports) {
      module.exports = false;
    }, {}],
    61: [function (_dereq_, module, exports) {
      // 20.2.2.14 Math.expm1(x)
      var $expm1 = Math.expm1;
      module.exports = !$expm1 // Old FF bug
      || $expm1(10) > 22025.465794806719 || $expm1(10) < 22025.4657948067165168 // Tor Browser bug
      || $expm1(-2e-17) != -2e-17 ? function expm1(x) {
        return (x = +x) == 0 ? x : x > -1e-6 && x < 1e-6 ? x + x * x / 2 : Math.exp(x) - 1;
      } : $expm1;
    }, {}],
    62: [function (_dereq_, module, exports) {
      // 20.2.2.16 Math.fround(x)
      var sign = _dereq_(65);

      var pow = Math.pow;
      var EPSILON = pow(2, -52);
      var EPSILON32 = pow(2, -23);
      var MAX32 = pow(2, 127) * (2 - EPSILON32);
      var MIN32 = pow(2, -126);

      var roundTiesToEven = function roundTiesToEven(n) {
        return n + 1 / EPSILON - 1 / EPSILON;
      };

      module.exports = Math.fround || function fround(x) {
        var $abs = Math.abs(x);
        var $sign = sign(x);
        var a, result;
        if ($abs < MIN32) return $sign * roundTiesToEven($abs / MIN32 / EPSILON32) * MIN32 * EPSILON32;
        a = (1 + EPSILON32 / EPSILON) * $abs;
        result = a - (a - $abs); // eslint-disable-next-line no-self-compare

        if (result > MAX32 || result != result) return $sign * Infinity;
        return $sign * result;
      };
    }, {
      "65": 65
    }],
    63: [function (_dereq_, module, exports) {
      // 20.2.2.20 Math.log1p(x)
      module.exports = Math.log1p || function log1p(x) {
        return (x = +x) > -1e-8 && x < 1e-8 ? x - x * x / 2 : Math.log(1 + x);
      };
    }, {}],
    64: [function (_dereq_, module, exports) {
      // https://rwaldron.github.io/proposal-math-extensions/
      module.exports = Math.scale || function scale(x, inLow, inHigh, outLow, outHigh) {
        if (arguments.length === 0 // eslint-disable-next-line no-self-compare
        || x != x // eslint-disable-next-line no-self-compare
        || inLow != inLow // eslint-disable-next-line no-self-compare
        || inHigh != inHigh // eslint-disable-next-line no-self-compare
        || outLow != outLow // eslint-disable-next-line no-self-compare
        || outHigh != outHigh) return NaN;
        if (x === Infinity || x === -Infinity) return x;
        return (x - inLow) * (outHigh - outLow) / (inHigh - inLow) + outLow;
      };
    }, {}],
    65: [function (_dereq_, module, exports) {
      // 20.2.2.28 Math.sign(x)
      module.exports = Math.sign || function sign(x) {
        // eslint-disable-next-line no-self-compare
        return (x = +x) == 0 || x != x ? x : x < 0 ? -1 : 1;
      };
    }, {}],
    66: [function (_dereq_, module, exports) {
      var META = _dereq_(124)('meta');

      var isObject = _dereq_(51);

      var has = _dereq_(41);

      var setDesc = _dereq_(72).f;

      var id = 0;

      var isExtensible = Object.isExtensible || function () {
        return true;
      };

      var FREEZE = !_dereq_(35)(function () {
        return isExtensible(Object.preventExtensions({}));
      });

      var setMeta = function setMeta(it) {
        setDesc(it, META, {
          value: {
            i: 'O' + ++id,
            // object ID
            w: {} // weak collections IDs

          }
        });
      };

      var fastKey = function fastKey(it, create) {
        // return primitive with prefix
        if (!isObject(it)) return _typeof(it) == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;

        if (!has(it, META)) {
          // can't set metadata to uncaught frozen object
          if (!isExtensible(it)) return 'F'; // not necessary to add metadata

          if (!create) return 'E'; // add missing metadata

          setMeta(it); // return object ID
        }

        return it[META].i;
      };

      var getWeak = function getWeak(it, create) {
        if (!has(it, META)) {
          // can't set metadata to uncaught frozen object
          if (!isExtensible(it)) return true; // not necessary to add metadata

          if (!create) return false; // add missing metadata

          setMeta(it); // return hash weak collections IDs
        }

        return it[META].w;
      }; // add metadata on freeze-family methods calling


      var onFreeze = function onFreeze(it) {
        if (FREEZE && meta.NEED && isExtensible(it) && !has(it, META)) setMeta(it);
        return it;
      };

      var meta = module.exports = {
        KEY: META,
        NEED: false,
        fastKey: fastKey,
        getWeak: getWeak,
        onFreeze: onFreeze
      };
    }, {
      "124": 124,
      "35": 35,
      "41": 41,
      "51": 51,
      "72": 72
    }],
    67: [function (_dereq_, module, exports) {
      var Map = _dereq_(160);

      var $export = _dereq_(33);

      var shared = _dereq_(103)('metadata');

      var store = shared.store || (shared.store = new (_dereq_(266))());

      var getOrCreateMetadataMap = function getOrCreateMetadataMap(target, targetKey, create) {
        var targetMetadata = store.get(target);

        if (!targetMetadata) {
          if (!create) return undefined;
          store.set(target, targetMetadata = new Map());
        }

        var keyMetadata = targetMetadata.get(targetKey);

        if (!keyMetadata) {
          if (!create) return undefined;
          targetMetadata.set(targetKey, keyMetadata = new Map());
        }

        return keyMetadata;
      };

      var ordinaryHasOwnMetadata = function ordinaryHasOwnMetadata(MetadataKey, O, P) {
        var metadataMap = getOrCreateMetadataMap(O, P, false);
        return metadataMap === undefined ? false : metadataMap.has(MetadataKey);
      };

      var ordinaryGetOwnMetadata = function ordinaryGetOwnMetadata(MetadataKey, O, P) {
        var metadataMap = getOrCreateMetadataMap(O, P, false);
        return metadataMap === undefined ? undefined : metadataMap.get(MetadataKey);
      };

      var ordinaryDefineOwnMetadata = function ordinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P) {
        getOrCreateMetadataMap(O, P, true).set(MetadataKey, MetadataValue);
      };

      var ordinaryOwnMetadataKeys = function ordinaryOwnMetadataKeys(target, targetKey) {
        var metadataMap = getOrCreateMetadataMap(target, targetKey, false);
        var keys = [];
        if (metadataMap) metadataMap.forEach(function (_, key) {
          keys.push(key);
        });
        return keys;
      };

      var toMetaKey = function toMetaKey(it) {
        return it === undefined || _typeof(it) == 'symbol' ? it : String(it);
      };

      var exp = function exp(O) {
        $export($export.S, 'Reflect', O);
      };

      module.exports = {
        store: store,
        map: getOrCreateMetadataMap,
        has: ordinaryHasOwnMetadata,
        get: ordinaryGetOwnMetadata,
        set: ordinaryDefineOwnMetadata,
        keys: ordinaryOwnMetadataKeys,
        key: toMetaKey,
        exp: exp
      };
    }, {
      "103": 103,
      "160": 160,
      "266": 266,
      "33": 33
    }],
    68: [function (_dereq_, module, exports) {
      var global = _dereq_(40);

      var macrotask = _dereq_(113).set;

      var Observer = global.MutationObserver || global.WebKitMutationObserver;
      var process = global.process;
      var Promise = global.Promise;
      var isNode = _dereq_(18)(process) == 'process';

      module.exports = function () {
        var head, last, notify;

        var flush = function flush() {
          var parent, fn;
          if (isNode && (parent = process.domain)) parent.exit();

          while (head) {
            fn = head.fn;
            head = head.next;

            try {
              fn();
            } catch (e) {
              if (head) notify();else last = undefined;
              throw e;
            }
          }

          last = undefined;
          if (parent) parent.enter();
        }; // Node.js


        if (isNode) {
          notify = function notify() {
            process.nextTick(flush);
          }; // browsers with MutationObserver

        } else if (Observer) {
          var toggle = true;
          var node = document.createTextNode('');
          new Observer(flush).observe(node, {
            characterData: true
          }); // eslint-disable-line no-new

          notify = function notify() {
            node.data = toggle = !toggle;
          }; // environments with maybe non-completely correct, but existent Promise

        } else if (Promise && Promise.resolve) {
          var promise = Promise.resolve();

          notify = function notify() {
            promise.then(flush);
          }; // for other environments - macrotask based on:
          // - setImmediate
          // - MessageChannel
          // - window.postMessag
          // - onreadystatechange
          // - setTimeout

        } else {
          notify = function notify() {
            // strange IE + webpack dev server bug - use .call(global)
            macrotask.call(global, flush);
          };
        }

        return function (fn) {
          var task = {
            fn: fn,
            next: undefined
          };
          if (last) last.next = task;

          if (!head) {
            head = task;
            notify();
          }

          last = task;
        };
      };
    }, {
      "113": 113,
      "18": 18,
      "40": 40
    }],
    69: [function (_dereq_, module, exports) {

      var aFunction = _dereq_(3);

      function PromiseCapability(C) {
        var resolve, reject;
        this.promise = new C(function ($$resolve, $$reject) {
          if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');
          resolve = $$resolve;
          reject = $$reject;
        });
        this.resolve = aFunction(resolve);
        this.reject = aFunction(reject);
      }

      module.exports.f = function (C) {
        return new PromiseCapability(C);
      };
    }, {
      "3": 3
    }],
    70: [function (_dereq_, module, exports) {

      var getKeys = _dereq_(81);

      var gOPS = _dereq_(78);

      var pIE = _dereq_(82);

      var toObject = _dereq_(119);

      var IObject = _dereq_(47);

      var $assign = Object.assign; // should work with symbols and should have deterministic property order (V8 bug)

      module.exports = !$assign || _dereq_(35)(function () {
        var A = {};
        var B = {}; // eslint-disable-next-line no-undef

        var S = Symbol();
        var K = 'abcdefghijklmnopqrst';
        A[S] = 7;
        K.split('').forEach(function (k) {
          B[k] = k;
        });
        return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
      }) ? function assign(target, source) {
        // eslint-disable-line no-unused-vars
        var T = toObject(target);
        var aLen = arguments.length;
        var index = 1;
        var getSymbols = gOPS.f;
        var isEnum = pIE.f;

        while (aLen > index) {
          var S = IObject(arguments[index++]);
          var keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S);
          var length = keys.length;
          var j = 0;
          var key;

          while (length > j) {
            if (isEnum.call(S, key = keys[j++])) T[key] = S[key];
          }
        }

        return T;
      } : $assign;
    }, {
      "119": 119,
      "35": 35,
      "47": 47,
      "78": 78,
      "81": 81,
      "82": 82
    }],
    71: [function (_dereq_, module, exports) {
      // 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
      var anObject = _dereq_(7);

      var dPs = _dereq_(73);

      var enumBugKeys = _dereq_(31);

      var IE_PROTO = _dereq_(102)('IE_PROTO');

      var Empty = function Empty() {
        /* empty */
      };

      var PROTOTYPE = 'prototype'; // Create object with fake `null` prototype: use iframe Object with cleared prototype

      var _createDict = function createDict() {
        // Thrash, waste and sodomy: IE GC bug
        var iframe = _dereq_(30)('iframe');

        var i = enumBugKeys.length;
        var lt = '<';
        var gt = '>';
        var iframeDocument;
        iframe.style.display = 'none';

        _dereq_(43).appendChild(iframe);

        iframe.src = 'javascript:'; // eslint-disable-line no-script-url
        // createDict = iframe.contentWindow.Object;
        // html.removeChild(iframe);

        iframeDocument = iframe.contentWindow.document;
        iframeDocument.open();
        iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
        iframeDocument.close();
        _createDict = iframeDocument.F;

        while (i--) {
          delete _createDict[PROTOTYPE][enumBugKeys[i]];
        }

        return _createDict();
      };

      module.exports = Object.create || function create(O, Properties) {
        var result;

        if (O !== null) {
          Empty[PROTOTYPE] = anObject(O);
          result = new Empty();
          Empty[PROTOTYPE] = null; // add "__proto__" for Object.getPrototypeOf polyfill

          result[IE_PROTO] = O;
        } else result = _createDict();

        return Properties === undefined ? result : dPs(result, Properties);
      };
    }, {
      "102": 102,
      "30": 30,
      "31": 31,
      "43": 43,
      "7": 7,
      "73": 73
    }],
    72: [function (_dereq_, module, exports) {
      var anObject = _dereq_(7);

      var IE8_DOM_DEFINE = _dereq_(44);

      var toPrimitive = _dereq_(120);

      var dP = Object.defineProperty;
      exports.f = _dereq_(29) ? Object.defineProperty : function defineProperty(O, P, Attributes) {
        anObject(O);
        P = toPrimitive(P, true);
        anObject(Attributes);
        if (IE8_DOM_DEFINE) try {
          return dP(O, P, Attributes);
        } catch (e) {
          /* empty */
        }
        if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
        if ('value' in Attributes) O[P] = Attributes.value;
        return O;
      };
    }, {
      "120": 120,
      "29": 29,
      "44": 44,
      "7": 7
    }],
    73: [function (_dereq_, module, exports) {
      var dP = _dereq_(72);

      var anObject = _dereq_(7);

      var getKeys = _dereq_(81);

      module.exports = _dereq_(29) ? Object.defineProperties : function defineProperties(O, Properties) {
        anObject(O);
        var keys = getKeys(Properties);
        var length = keys.length;
        var i = 0;
        var P;

        while (length > i) {
          dP.f(O, P = keys[i++], Properties[P]);
        }

        return O;
      };
    }, {
      "29": 29,
      "7": 7,
      "72": 72,
      "81": 81
    }],
    74: [function (_dereq_, module, exports) {

      module.exports = _dereq_(60) || !_dereq_(35)(function () {
        var K = Math.random(); // In FF throws only define methods
        // eslint-disable-next-line no-undef, no-useless-call

        __defineSetter__.call(null, K, function () {
          /* empty */
        });

        delete _dereq_(40)[K];
      });
    }, {
      "35": 35,
      "40": 40,
      "60": 60
    }],
    75: [function (_dereq_, module, exports) {
      var pIE = _dereq_(82);

      var createDesc = _dereq_(92);

      var toIObject = _dereq_(117);

      var toPrimitive = _dereq_(120);

      var has = _dereq_(41);

      var IE8_DOM_DEFINE = _dereq_(44);

      var gOPD = Object.getOwnPropertyDescriptor;
      exports.f = _dereq_(29) ? gOPD : function getOwnPropertyDescriptor(O, P) {
        O = toIObject(O);
        P = toPrimitive(P, true);
        if (IE8_DOM_DEFINE) try {
          return gOPD(O, P);
        } catch (e) {
          /* empty */
        }
        if (has(O, P)) return createDesc(!pIE.f.call(O, P), O[P]);
      };
    }, {
      "117": 117,
      "120": 120,
      "29": 29,
      "41": 41,
      "44": 44,
      "82": 82,
      "92": 92
    }],
    76: [function (_dereq_, module, exports) {
      // fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
      var toIObject = _dereq_(117);

      var gOPN = _dereq_(77).f;

      var toString = {}.toString;
      var windowNames = (typeof window === "undefined" ? "undefined" : _typeof(window)) == 'object' && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];

      var getWindowNames = function getWindowNames(it) {
        try {
          return gOPN(it);
        } catch (e) {
          return windowNames.slice();
        }
      };

      module.exports.f = function getOwnPropertyNames(it) {
        return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));
      };
    }, {
      "117": 117,
      "77": 77
    }],
    77: [function (_dereq_, module, exports) {
      // 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
      var $keys = _dereq_(80);

      var hiddenKeys = _dereq_(31).concat('length', 'prototype');

      exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
        return $keys(O, hiddenKeys);
      };
    }, {
      "31": 31,
      "80": 80
    }],
    78: [function (_dereq_, module, exports) {
      exports.f = Object.getOwnPropertySymbols;
    }, {}],
    79: [function (_dereq_, module, exports) {
      // 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
      var has = _dereq_(41);

      var toObject = _dereq_(119);

      var IE_PROTO = _dereq_(102)('IE_PROTO');

      var ObjectProto = Object.prototype;

      module.exports = Object.getPrototypeOf || function (O) {
        O = toObject(O);
        if (has(O, IE_PROTO)) return O[IE_PROTO];

        if (typeof O.constructor == 'function' && O instanceof O.constructor) {
          return O.constructor.prototype;
        }

        return O instanceof Object ? ObjectProto : null;
      };
    }, {
      "102": 102,
      "119": 119,
      "41": 41
    }],
    80: [function (_dereq_, module, exports) {
      var has = _dereq_(41);

      var toIObject = _dereq_(117);

      var arrayIndexOf = _dereq_(11)(false);

      var IE_PROTO = _dereq_(102)('IE_PROTO');

      module.exports = function (object, names) {
        var O = toIObject(object);
        var i = 0;
        var result = [];
        var key;

        for (key in O) {
          if (key != IE_PROTO) has(O, key) && result.push(key);
        } // Don't enum bug & hidden keys


        while (names.length > i) {
          if (has(O, key = names[i++])) {
            ~arrayIndexOf(result, key) || result.push(key);
          }
        }

        return result;
      };
    }, {
      "102": 102,
      "11": 11,
      "117": 117,
      "41": 41
    }],
    81: [function (_dereq_, module, exports) {
      // 19.1.2.14 / 15.2.3.14 Object.keys(O)
      var $keys = _dereq_(80);

      var enumBugKeys = _dereq_(31);

      module.exports = Object.keys || function keys(O) {
        return $keys(O, enumBugKeys);
      };
    }, {
      "31": 31,
      "80": 80
    }],
    82: [function (_dereq_, module, exports) {
      exports.f = {}.propertyIsEnumerable;
    }, {}],
    83: [function (_dereq_, module, exports) {
      // most Object methods by ES6 should accept primitives
      var $export = _dereq_(33);

      var core = _dereq_(23);

      var fails = _dereq_(35);

      module.exports = function (KEY, exec) {
        var fn = (core.Object || {})[KEY] || Object[KEY];
        var exp = {};
        exp[KEY] = exec(fn);
        $export($export.S + $export.F * fails(function () {
          fn(1);
        }), 'Object', exp);
      };
    }, {
      "23": 23,
      "33": 33,
      "35": 35
    }],
    84: [function (_dereq_, module, exports) {
      var getKeys = _dereq_(81);

      var toIObject = _dereq_(117);

      var isEnum = _dereq_(82).f;

      module.exports = function (isEntries) {
        return function (it) {
          var O = toIObject(it);
          var keys = getKeys(O);
          var length = keys.length;
          var i = 0;
          var result = [];
          var key;

          while (length > i) {
            if (isEnum.call(O, key = keys[i++])) {
              result.push(isEntries ? [key, O[key]] : O[key]);
            }
          }

          return result;
        };
      };
    }, {
      "117": 117,
      "81": 81,
      "82": 82
    }],
    85: [function (_dereq_, module, exports) {
      // all object keys, includes non-enumerable and symbols
      var gOPN = _dereq_(77);

      var gOPS = _dereq_(78);

      var anObject = _dereq_(7);

      var Reflect = _dereq_(40).Reflect;

      module.exports = Reflect && Reflect.ownKeys || function ownKeys(it) {
        var keys = gOPN.f(anObject(it));
        var getSymbols = gOPS.f;
        return getSymbols ? keys.concat(getSymbols(it)) : keys;
      };
    }, {
      "40": 40,
      "7": 7,
      "77": 77,
      "78": 78
    }],
    86: [function (_dereq_, module, exports) {
      var $parseFloat = _dereq_(40).parseFloat;

      var $trim = _dereq_(111).trim;

      module.exports = 1 / $parseFloat(_dereq_(112) + '-0') !== -Infinity ? function parseFloat(str) {
        var string = $trim(String(str), 3);
        var result = $parseFloat(string);
        return result === 0 && string.charAt(0) == '-' ? -0 : result;
      } : $parseFloat;
    }, {
      "111": 111,
      "112": 112,
      "40": 40
    }],
    87: [function (_dereq_, module, exports) {
      var $parseInt = _dereq_(40).parseInt;

      var $trim = _dereq_(111).trim;

      var ws = _dereq_(112);

      var hex = /^[-+]?0[xX]/;
      module.exports = $parseInt(ws + '08') !== 8 || $parseInt(ws + '0x16') !== 22 ? function parseInt(str, radix) {
        var string = $trim(String(str), 3);
        return $parseInt(string, radix >>> 0 || (hex.test(string) ? 16 : 10));
      } : $parseInt;
    }, {
      "111": 111,
      "112": 112,
      "40": 40
    }],
    88: [function (_dereq_, module, exports) {

      var path = _dereq_(89);

      var invoke = _dereq_(46);

      var aFunction = _dereq_(3);

      module.exports = function ()
      /* ...pargs */
      {
        var fn = aFunction(this);
        var length = arguments.length;
        var pargs = Array(length);
        var i = 0;
        var _ = path._;
        var holder = false;

        while (length > i) {
          if ((pargs[i] = arguments[i++]) === _) holder = true;
        }

        return function ()
        /* ...args */
        {
          var that = this;
          var aLen = arguments.length;
          var j = 0;
          var k = 0;
          var args;
          if (!holder && !aLen) return invoke(fn, pargs, that);
          args = pargs.slice();
          if (holder) for (; length > j; j++) {
            if (args[j] === _) args[j] = arguments[k++];
          }

          while (aLen > k) {
            args.push(arguments[k++]);
          }

          return invoke(fn, args, that);
        };
      };
    }, {
      "3": 3,
      "46": 46,
      "89": 89
    }],
    89: [function (_dereq_, module, exports) {
      module.exports = _dereq_(40);
    }, {
      "40": 40
    }],
    90: [function (_dereq_, module, exports) {
      module.exports = function (exec) {
        try {
          return {
            e: false,
            v: exec()
          };
        } catch (e) {
          return {
            e: true,
            v: e
          };
        }
      };
    }, {}],
    91: [function (_dereq_, module, exports) {
      var newPromiseCapability = _dereq_(69);

      module.exports = function (C, x) {
        var promiseCapability = newPromiseCapability.f(C);
        var resolve = promiseCapability.resolve;
        resolve(x);
        return promiseCapability.promise;
      };
    }, {
      "69": 69
    }],
    92: [function (_dereq_, module, exports) {
      module.exports = function (bitmap, value) {
        return {
          enumerable: !(bitmap & 1),
          configurable: !(bitmap & 2),
          writable: !(bitmap & 4),
          value: value
        };
      };
    }, {}],
    93: [function (_dereq_, module, exports) {
      var redefine = _dereq_(94);

      module.exports = function (target, src, safe) {
        for (var key in src) {
          redefine(target, key, src[key], safe);
        }

        return target;
      };
    }, {
      "94": 94
    }],
    94: [function (_dereq_, module, exports) {
      var global = _dereq_(40);

      var hide = _dereq_(42);

      var has = _dereq_(41);

      var SRC = _dereq_(124)('src');

      var TO_STRING = 'toString';
      var $toString = Function[TO_STRING];
      var TPL = ('' + $toString).split(TO_STRING);

      _dereq_(23).inspectSource = function (it) {
        return $toString.call(it);
      };

      (module.exports = function (O, key, val, safe) {
        var isFunction = typeof val == 'function';
        if (isFunction) has(val, 'name') || hide(val, 'name', key);
        if (O[key] === val) return;
        if (isFunction) has(val, SRC) || hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));

        if (O === global) {
          O[key] = val;
        } else if (!safe) {
          delete O[key];
          hide(O, key, val);
        } else if (O[key]) {
          O[key] = val;
        } else {
          hide(O, key, val);
        } // add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative

      })(Function.prototype, TO_STRING, function toString() {
        return typeof this == 'function' && this[SRC] || $toString.call(this);
      });
    }, {
      "124": 124,
      "23": 23,
      "40": 40,
      "41": 41,
      "42": 42
    }],
    95: [function (_dereq_, module, exports) {
      module.exports = function (regExp, replace) {
        var replacer = replace === Object(replace) ? function (part) {
          return replace[part];
        } : replace;
        return function (it) {
          return String(it).replace(regExp, replacer);
        };
      };
    }, {}],
    96: [function (_dereq_, module, exports) {
      // 7.2.9 SameValue(x, y)
      module.exports = Object.is || function is(x, y) {
        // eslint-disable-next-line no-self-compare
        return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;
      };
    }, {}],
    97: [function (_dereq_, module, exports) {

      var $export = _dereq_(33);

      var aFunction = _dereq_(3);

      var ctx = _dereq_(25);

      var forOf = _dereq_(39);

      module.exports = function (COLLECTION) {
        $export($export.S, COLLECTION, {
          from: function from(source
          /* , mapFn, thisArg */
          ) {
            var mapFn = arguments[1];
            var mapping, A, n, cb;
            aFunction(this);
            mapping = mapFn !== undefined;
            if (mapping) aFunction(mapFn);
            if (source == undefined) return new this();
            A = [];

            if (mapping) {
              n = 0;
              cb = ctx(mapFn, arguments[2], 2);
              forOf(source, false, function (nextItem) {
                A.push(cb(nextItem, n++));
              });
            } else {
              forOf(source, false, A.push, A);
            }

            return new this(A);
          }
        });
      };
    }, {
      "25": 25,
      "3": 3,
      "33": 33,
      "39": 39
    }],
    98: [function (_dereq_, module, exports) {

      var $export = _dereq_(33);

      module.exports = function (COLLECTION) {
        $export($export.S, COLLECTION, {
          of: function of() {
            var length = arguments.length;
            var A = Array(length);

            while (length--) {
              A[length] = arguments[length];
            }

            return new this(A);
          }
        });
      };
    }, {
      "33": 33
    }],
    99: [function (_dereq_, module, exports) {
      // Works with __proto__ only. Old v8 can't work with null proto objects.

      /* eslint-disable no-proto */
      var isObject = _dereq_(51);

      var anObject = _dereq_(7);

      var check = function check(O, proto) {
        anObject(O);
        if (!isObject(proto) && proto !== null) throw TypeError(proto + ": can't set as prototype!");
      };

      module.exports = {
        set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
        function (test, buggy, set) {
          try {
            set = _dereq_(25)(Function.call, _dereq_(75).f(Object.prototype, '__proto__').set, 2);
            set(test, []);
            buggy = !(test instanceof Array);
          } catch (e) {
            buggy = true;
          }

          return function setPrototypeOf(O, proto) {
            check(O, proto);
            if (buggy) O.__proto__ = proto;else set(O, proto);
            return O;
          };
        }({}, false) : undefined),
        check: check
      };
    }, {
      "25": 25,
      "51": 51,
      "7": 7,
      "75": 75
    }],
    100: [function (_dereq_, module, exports) {

      var global = _dereq_(40);

      var dP = _dereq_(72);

      var DESCRIPTORS = _dereq_(29);

      var SPECIES = _dereq_(128)('species');

      module.exports = function (KEY) {
        var C = global[KEY];
        if (DESCRIPTORS && C && !C[SPECIES]) dP.f(C, SPECIES, {
          configurable: true,
          get: function get() {
            return this;
          }
        });
      };
    }, {
      "128": 128,
      "29": 29,
      "40": 40,
      "72": 72
    }],
    101: [function (_dereq_, module, exports) {
      var def = _dereq_(72).f;

      var has = _dereq_(41);

      var TAG = _dereq_(128)('toStringTag');

      module.exports = function (it, tag, stat) {
        if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, {
          configurable: true,
          value: tag
        });
      };
    }, {
      "128": 128,
      "41": 41,
      "72": 72
    }],
    102: [function (_dereq_, module, exports) {
      var shared = _dereq_(103)('keys');

      var uid = _dereq_(124);

      module.exports = function (key) {
        return shared[key] || (shared[key] = uid(key));
      };
    }, {
      "103": 103,
      "124": 124
    }],
    103: [function (_dereq_, module, exports) {
      var global = _dereq_(40);

      var SHARED = '__core-js_shared__';
      var store = global[SHARED] || (global[SHARED] = {});

      module.exports = function (key) {
        return store[key] || (store[key] = {});
      };
    }, {
      "40": 40
    }],
    104: [function (_dereq_, module, exports) {
      // 7.3.20 SpeciesConstructor(O, defaultConstructor)
      var anObject = _dereq_(7);

      var aFunction = _dereq_(3);

      var SPECIES = _dereq_(128)('species');

      module.exports = function (O, D) {
        var C = anObject(O).constructor;
        var S;
        return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);
      };
    }, {
      "128": 128,
      "3": 3,
      "7": 7
    }],
    105: [function (_dereq_, module, exports) {

      var fails = _dereq_(35);

      module.exports = function (method, arg) {
        return !!method && fails(function () {
          // eslint-disable-next-line no-useless-call
          arg ? method.call(null, function () {
            /* empty */
          }, 1) : method.call(null);
        });
      };
    }, {
      "35": 35
    }],
    106: [function (_dereq_, module, exports) {
      var toInteger = _dereq_(116);

      var defined = _dereq_(28); // true  -> String#at
      // false -> String#codePointAt


      module.exports = function (TO_STRING) {
        return function (that, pos) {
          var s = String(defined(that));
          var i = toInteger(pos);
          var l = s.length;
          var a, b;
          if (i < 0 || i >= l) return TO_STRING ? '' : undefined;
          a = s.charCodeAt(i);
          return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff ? TO_STRING ? s.charAt(i) : a : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
        };
      };
    }, {
      "116": 116,
      "28": 28
    }],
    107: [function (_dereq_, module, exports) {
      // helper for String#{startsWith, endsWith, includes}
      var isRegExp = _dereq_(52);

      var defined = _dereq_(28);

      module.exports = function (that, searchString, NAME) {
        if (isRegExp(searchString)) throw TypeError('String#' + NAME + " doesn't accept regex!");
        return String(defined(that));
      };
    }, {
      "28": 28,
      "52": 52
    }],
    108: [function (_dereq_, module, exports) {
      var $export = _dereq_(33);

      var fails = _dereq_(35);

      var defined = _dereq_(28);

      var quot = /"/g; // B.2.3.2.1 CreateHTML(string, tag, attribute, value)

      var createHTML = function createHTML(string, tag, attribute, value) {
        var S = String(defined(string));
        var p1 = '<' + tag;
        if (attribute !== '') p1 += ' ' + attribute + '="' + String(value).replace(quot, '&quot;') + '"';
        return p1 + '>' + S + '</' + tag + '>';
      };

      module.exports = function (NAME, exec) {
        var O = {};
        O[NAME] = exec(createHTML);
        $export($export.P + $export.F * fails(function () {
          var test = ''[NAME]('"');
          return test !== test.toLowerCase() || test.split('"').length > 3;
        }), 'String', O);
      };
    }, {
      "28": 28,
      "33": 33,
      "35": 35
    }],
    109: [function (_dereq_, module, exports) {
      // https://github.com/tc39/proposal-string-pad-start-end
      var toLength = _dereq_(118);

      var repeat = _dereq_(110);

      var defined = _dereq_(28);

      module.exports = function (that, maxLength, fillString, left) {
        var S = String(defined(that));
        var stringLength = S.length;
        var fillStr = fillString === undefined ? ' ' : String(fillString);
        var intMaxLength = toLength(maxLength);
        if (intMaxLength <= stringLength || fillStr == '') return S;
        var fillLen = intMaxLength - stringLength;
        var stringFiller = repeat.call(fillStr, Math.ceil(fillLen / fillStr.length));
        if (stringFiller.length > fillLen) stringFiller = stringFiller.slice(0, fillLen);
        return left ? stringFiller + S : S + stringFiller;
      };
    }, {
      "110": 110,
      "118": 118,
      "28": 28
    }],
    110: [function (_dereq_, module, exports) {

      var toInteger = _dereq_(116);

      var defined = _dereq_(28);

      module.exports = function repeat(count) {
        var str = String(defined(this));
        var res = '';
        var n = toInteger(count);
        if (n < 0 || n == Infinity) throw RangeError("Count can't be negative");

        for (; n > 0; (n >>>= 1) && (str += str)) {
          if (n & 1) res += str;
        }

        return res;
      };
    }, {
      "116": 116,
      "28": 28
    }],
    111: [function (_dereq_, module, exports) {
      var $export = _dereq_(33);

      var defined = _dereq_(28);

      var fails = _dereq_(35);

      var spaces = _dereq_(112);

      var space = '[' + spaces + ']';
      var non = "\u200B\x85";
      var ltrim = RegExp('^' + space + space + '*');
      var rtrim = RegExp(space + space + '*$');

      var exporter = function exporter(KEY, exec, ALIAS) {
        var exp = {};
        var FORCE = fails(function () {
          return !!spaces[KEY]() || non[KEY]() != non;
        });
        var fn = exp[KEY] = FORCE ? exec(trim) : spaces[KEY];
        if (ALIAS) exp[ALIAS] = fn;
        $export($export.P + $export.F * FORCE, 'String', exp);
      }; // 1 -> String#trimLeft
      // 2 -> String#trimRight
      // 3 -> String#trim


      var trim = exporter.trim = function (string, TYPE) {
        string = String(defined(string));
        if (TYPE & 1) string = string.replace(ltrim, '');
        if (TYPE & 2) string = string.replace(rtrim, '');
        return string;
      };

      module.exports = exporter;
    }, {
      "112": 112,
      "28": 28,
      "33": 33,
      "35": 35
    }],
    112: [function (_dereq_, module, exports) {
      module.exports = "\t\n\x0B\f\r \xA0\u1680\u180E\u2000\u2001\u2002\u2003" + "\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF";
    }, {}],
    113: [function (_dereq_, module, exports) {
      var ctx = _dereq_(25);

      var invoke = _dereq_(46);

      var html = _dereq_(43);

      var cel = _dereq_(30);

      var global = _dereq_(40);

      var process = global.process;
      var setTask = global.setImmediate;
      var clearTask = global.clearImmediate;
      var MessageChannel = global.MessageChannel;
      var Dispatch = global.Dispatch;
      var counter = 0;
      var queue = {};
      var ONREADYSTATECHANGE = 'onreadystatechange';
      var defer, channel, port;

      var run = function run() {
        var id = +this; // eslint-disable-next-line no-prototype-builtins

        if (queue.hasOwnProperty(id)) {
          var fn = queue[id];
          delete queue[id];
          fn();
        }
      };

      var listener = function listener(event) {
        run.call(event.data);
      }; // Node.js 0.9+ & IE10+ has setImmediate, otherwise:


      if (!setTask || !clearTask) {
        setTask = function setImmediate(fn) {
          var args = [];
          var i = 1;

          while (arguments.length > i) {
            args.push(arguments[i++]);
          }

          queue[++counter] = function () {
            // eslint-disable-next-line no-new-func
            invoke(typeof fn == 'function' ? fn : Function(fn), args);
          };

          defer(counter);
          return counter;
        };

        clearTask = function clearImmediate(id) {
          delete queue[id];
        }; // Node.js 0.8-


        if (_dereq_(18)(process) == 'process') {
          defer = function defer(id) {
            process.nextTick(ctx(run, id, 1));
          }; // Sphere (JS game engine) Dispatch API

        } else if (Dispatch && Dispatch.now) {
          defer = function defer(id) {
            Dispatch.now(ctx(run, id, 1));
          }; // Browsers with MessageChannel, includes WebWorkers

        } else if (MessageChannel) {
          channel = new MessageChannel();
          port = channel.port2;
          channel.port1.onmessage = listener;
          defer = ctx(port.postMessage, port, 1); // Browsers with postMessage, skip WebWorkers
          // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
        } else if (global.addEventListener && typeof postMessage == 'function' && !global.importScripts) {
          defer = function defer(id) {
            global.postMessage(id + '', '*');
          };

          global.addEventListener('message', listener, false); // IE8-
        } else if (ONREADYSTATECHANGE in cel('script')) {
          defer = function defer(id) {
            html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function () {
              html.removeChild(this);
              run.call(id);
            };
          }; // Rest old browsers

        } else {
          defer = function defer(id) {
            setTimeout(ctx(run, id, 1), 0);
          };
        }
      }

      module.exports = {
        set: setTask,
        clear: clearTask
      };
    }, {
      "18": 18,
      "25": 25,
      "30": 30,
      "40": 40,
      "43": 43,
      "46": 46
    }],
    114: [function (_dereq_, module, exports) {
      var toInteger = _dereq_(116);

      var max = Math.max;
      var min = Math.min;

      module.exports = function (index, length) {
        index = toInteger(index);
        return index < 0 ? max(index + length, 0) : min(index, length);
      };
    }, {
      "116": 116
    }],
    115: [function (_dereq_, module, exports) {
      // https://tc39.github.io/ecma262/#sec-toindex
      var toInteger = _dereq_(116);

      var toLength = _dereq_(118);

      module.exports = function (it) {
        if (it === undefined) return 0;
        var number = toInteger(it);
        var length = toLength(number);
        if (number !== length) throw RangeError('Wrong length!');
        return length;
      };
    }, {
      "116": 116,
      "118": 118
    }],
    116: [function (_dereq_, module, exports) {
      // 7.1.4 ToInteger
      var ceil = Math.ceil;
      var floor = Math.floor;

      module.exports = function (it) {
        return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
      };
    }, {}],
    117: [function (_dereq_, module, exports) {
      // to indexed object, toObject with fallback for non-array-like ES3 strings
      var IObject = _dereq_(47);

      var defined = _dereq_(28);

      module.exports = function (it) {
        return IObject(defined(it));
      };
    }, {
      "28": 28,
      "47": 47
    }],
    118: [function (_dereq_, module, exports) {
      // 7.1.15 ToLength
      var toInteger = _dereq_(116);

      var min = Math.min;

      module.exports = function (it) {
        return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
      };
    }, {
      "116": 116
    }],
    119: [function (_dereq_, module, exports) {
      // 7.1.13 ToObject(argument)
      var defined = _dereq_(28);

      module.exports = function (it) {
        return Object(defined(it));
      };
    }, {
      "28": 28
    }],
    120: [function (_dereq_, module, exports) {
      // 7.1.1 ToPrimitive(input [, PreferredType])
      var isObject = _dereq_(51); // instead of the ES6 spec version, we didn't implement @@toPrimitive case
      // and the second argument - flag - preferred type is a string


      module.exports = function (it, S) {
        if (!isObject(it)) return it;
        var fn, val;
        if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
        if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;
        if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
        throw TypeError("Can't convert object to primitive value");
      };
    }, {
      "51": 51
    }],
    121: [function (_dereq_, module, exports) {

      if (_dereq_(29)) {
        var LIBRARY = _dereq_(60);

        var global = _dereq_(40);

        var fails = _dereq_(35);

        var $export = _dereq_(33);

        var $typed = _dereq_(123);

        var $buffer = _dereq_(122);

        var ctx = _dereq_(25);

        var anInstance = _dereq_(6);

        var propertyDesc = _dereq_(92);

        var hide = _dereq_(42);

        var redefineAll = _dereq_(93);

        var toInteger = _dereq_(116);

        var toLength = _dereq_(118);

        var toIndex = _dereq_(115);

        var toAbsoluteIndex = _dereq_(114);

        var toPrimitive = _dereq_(120);

        var has = _dereq_(41);

        var classof = _dereq_(17);

        var isObject = _dereq_(51);

        var toObject = _dereq_(119);

        var isArrayIter = _dereq_(48);

        var create = _dereq_(71);

        var getPrototypeOf = _dereq_(79);

        var gOPN = _dereq_(77).f;

        var getIterFn = _dereq_(129);

        var uid = _dereq_(124);

        var wks = _dereq_(128);

        var createArrayMethod = _dereq_(12);

        var createArrayIncludes = _dereq_(11);

        var speciesConstructor = _dereq_(104);

        var ArrayIterators = _dereq_(141);

        var Iterators = _dereq_(58);

        var $iterDetect = _dereq_(56);

        var setSpecies = _dereq_(100);

        var arrayFill = _dereq_(9);

        var arrayCopyWithin = _dereq_(8);

        var $DP = _dereq_(72);

        var $GOPD = _dereq_(75);

        var dP = $DP.f;
        var gOPD = $GOPD.f;
        var RangeError = global.RangeError;
        var TypeError = global.TypeError;
        var Uint8Array = global.Uint8Array;
        var ARRAY_BUFFER = 'ArrayBuffer';
        var SHARED_BUFFER = 'Shared' + ARRAY_BUFFER;
        var BYTES_PER_ELEMENT = 'BYTES_PER_ELEMENT';
        var PROTOTYPE = 'prototype';
        var ArrayProto = Array[PROTOTYPE];
        var $ArrayBuffer = $buffer.ArrayBuffer;
        var $DataView = $buffer.DataView;
        var arrayForEach = createArrayMethod(0);
        var arrayFilter = createArrayMethod(2);
        var arraySome = createArrayMethod(3);
        var arrayEvery = createArrayMethod(4);
        var arrayFind = createArrayMethod(5);
        var arrayFindIndex = createArrayMethod(6);
        var arrayIncludes = createArrayIncludes(true);
        var arrayIndexOf = createArrayIncludes(false);
        var arrayValues = ArrayIterators.values;
        var arrayKeys = ArrayIterators.keys;
        var arrayEntries = ArrayIterators.entries;
        var arrayLastIndexOf = ArrayProto.lastIndexOf;
        var arrayReduce = ArrayProto.reduce;
        var arrayReduceRight = ArrayProto.reduceRight;
        var arrayJoin = ArrayProto.join;
        var arraySort = ArrayProto.sort;
        var arraySlice = ArrayProto.slice;
        var arrayToString = ArrayProto.toString;
        var arrayToLocaleString = ArrayProto.toLocaleString;
        var ITERATOR = wks('iterator');
        var TAG = wks('toStringTag');
        var TYPED_CONSTRUCTOR = uid('typed_constructor');
        var DEF_CONSTRUCTOR = uid('def_constructor');
        var ALL_CONSTRUCTORS = $typed.CONSTR;
        var TYPED_ARRAY = $typed.TYPED;
        var VIEW = $typed.VIEW;
        var WRONG_LENGTH = 'Wrong length!';
        var $map = createArrayMethod(1, function (O, length) {
          return allocate(speciesConstructor(O, O[DEF_CONSTRUCTOR]), length);
        });
        var LITTLE_ENDIAN = fails(function () {
          // eslint-disable-next-line no-undef
          return new Uint8Array(new Uint16Array([1]).buffer)[0] === 1;
        });
        var FORCED_SET = !!Uint8Array && !!Uint8Array[PROTOTYPE].set && fails(function () {
          new Uint8Array(1).set({});
        });

        var toOffset = function toOffset(it, BYTES) {
          var offset = toInteger(it);
          if (offset < 0 || offset % BYTES) throw RangeError('Wrong offset!');
          return offset;
        };

        var validate = function validate(it) {
          if (isObject(it) && TYPED_ARRAY in it) return it;
          throw TypeError(it + ' is not a typed array!');
        };

        var allocate = function allocate(C, length) {
          if (!(isObject(C) && TYPED_CONSTRUCTOR in C)) {
            throw TypeError('It is not a typed array constructor!');
          }

          return new C(length);
        };

        var speciesFromList = function speciesFromList(O, list) {
          return fromList(speciesConstructor(O, O[DEF_CONSTRUCTOR]), list);
        };

        var fromList = function fromList(C, list) {
          var index = 0;
          var length = list.length;
          var result = allocate(C, length);

          while (length > index) {
            result[index] = list[index++];
          }

          return result;
        };

        var addGetter = function addGetter(it, key, internal) {
          dP(it, key, {
            get: function get() {
              return this._d[internal];
            }
          });
        };

        var $from = function from(source
        /* , mapfn, thisArg */
        ) {
          var O = toObject(source);
          var aLen = arguments.length;
          var mapfn = aLen > 1 ? arguments[1] : undefined;
          var mapping = mapfn !== undefined;
          var iterFn = getIterFn(O);
          var i, length, values, result, step, iterator;

          if (iterFn != undefined && !isArrayIter(iterFn)) {
            for (iterator = iterFn.call(O), values = [], i = 0; !(step = iterator.next()).done; i++) {
              values.push(step.value);
            }

            O = values;
          }

          if (mapping && aLen > 2) mapfn = ctx(mapfn, arguments[2], 2);

          for (i = 0, length = toLength(O.length), result = allocate(this, length); length > i; i++) {
            result[i] = mapping ? mapfn(O[i], i) : O[i];
          }

          return result;
        };

        var $of = function of()
        /* ...items */
        {
          var index = 0;
          var length = arguments.length;
          var result = allocate(this, length);

          while (length > index) {
            result[index] = arguments[index++];
          }

          return result;
        }; // iOS Safari 6.x fails here


        var TO_LOCALE_BUG = !!Uint8Array && fails(function () {
          arrayToLocaleString.call(new Uint8Array(1));
        });

        var $toLocaleString = function toLocaleString() {
          return arrayToLocaleString.apply(TO_LOCALE_BUG ? arraySlice.call(validate(this)) : validate(this), arguments);
        };

        var proto = {
          copyWithin: function copyWithin(target, start
          /* , end */
          ) {
            return arrayCopyWithin.call(validate(this), target, start, arguments.length > 2 ? arguments[2] : undefined);
          },
          every: function every(callbackfn
          /* , thisArg */
          ) {
            return arrayEvery(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
          },
          fill: function fill(value
          /* , start, end */
          ) {
            // eslint-disable-line no-unused-vars
            return arrayFill.apply(validate(this), arguments);
          },
          filter: function filter(callbackfn
          /* , thisArg */
          ) {
            return speciesFromList(this, arrayFilter(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined));
          },
          find: function find(predicate
          /* , thisArg */
          ) {
            return arrayFind(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
          },
          findIndex: function findIndex(predicate
          /* , thisArg */
          ) {
            return arrayFindIndex(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
          },
          forEach: function forEach(callbackfn
          /* , thisArg */
          ) {
            arrayForEach(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
          },
          indexOf: function indexOf(searchElement
          /* , fromIndex */
          ) {
            return arrayIndexOf(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
          },
          includes: function includes(searchElement
          /* , fromIndex */
          ) {
            return arrayIncludes(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
          },
          join: function join(separator) {
            // eslint-disable-line no-unused-vars
            return arrayJoin.apply(validate(this), arguments);
          },
          lastIndexOf: function lastIndexOf(searchElement
          /* , fromIndex */
          ) {
            // eslint-disable-line no-unused-vars
            return arrayLastIndexOf.apply(validate(this), arguments);
          },
          map: function map(mapfn
          /* , thisArg */
          ) {
            return $map(validate(this), mapfn, arguments.length > 1 ? arguments[1] : undefined);
          },
          reduce: function reduce(callbackfn
          /* , initialValue */
          ) {
            // eslint-disable-line no-unused-vars
            return arrayReduce.apply(validate(this), arguments);
          },
          reduceRight: function reduceRight(callbackfn
          /* , initialValue */
          ) {
            // eslint-disable-line no-unused-vars
            return arrayReduceRight.apply(validate(this), arguments);
          },
          reverse: function reverse() {
            var that = this;
            var length = validate(that).length;
            var middle = Math.floor(length / 2);
            var index = 0;
            var value;

            while (index < middle) {
              value = that[index];
              that[index++] = that[--length];
              that[length] = value;
            }

            return that;
          },
          some: function some(callbackfn
          /* , thisArg */
          ) {
            return arraySome(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
          },
          sort: function sort(comparefn) {
            return arraySort.call(validate(this), comparefn);
          },
          subarray: function subarray(begin, end) {
            var O = validate(this);
            var length = O.length;
            var $begin = toAbsoluteIndex(begin, length);
            return new (speciesConstructor(O, O[DEF_CONSTRUCTOR]))(O.buffer, O.byteOffset + $begin * O.BYTES_PER_ELEMENT, toLength((end === undefined ? length : toAbsoluteIndex(end, length)) - $begin));
          }
        };

        var $slice = function slice(start, end) {
          return speciesFromList(this, arraySlice.call(validate(this), start, end));
        };

        var $set = function set(arrayLike
        /* , offset */
        ) {
          validate(this);
          var offset = toOffset(arguments[1], 1);
          var length = this.length;
          var src = toObject(arrayLike);
          var len = toLength(src.length);
          var index = 0;
          if (len + offset > length) throw RangeError(WRONG_LENGTH);

          while (index < len) {
            this[offset + index] = src[index++];
          }
        };

        var $iterators = {
          entries: function entries() {
            return arrayEntries.call(validate(this));
          },
          keys: function keys() {
            return arrayKeys.call(validate(this));
          },
          values: function values() {
            return arrayValues.call(validate(this));
          }
        };

        var isTAIndex = function isTAIndex(target, key) {
          return isObject(target) && target[TYPED_ARRAY] && _typeof(key) != 'symbol' && key in target && String(+key) == String(key);
        };

        var $getDesc = function getOwnPropertyDescriptor(target, key) {
          return isTAIndex(target, key = toPrimitive(key, true)) ? propertyDesc(2, target[key]) : gOPD(target, key);
        };

        var $setDesc = function defineProperty(target, key, desc) {
          if (isTAIndex(target, key = toPrimitive(key, true)) && isObject(desc) && has(desc, 'value') && !has(desc, 'get') && !has(desc, 'set') // TODO: add validation descriptor w/o calling accessors
          && !desc.configurable && (!has(desc, 'writable') || desc.writable) && (!has(desc, 'enumerable') || desc.enumerable)) {
            target[key] = desc.value;
            return target;
          }

          return dP(target, key, desc);
        };

        if (!ALL_CONSTRUCTORS) {
          $GOPD.f = $getDesc;
          $DP.f = $setDesc;
        }

        $export($export.S + $export.F * !ALL_CONSTRUCTORS, 'Object', {
          getOwnPropertyDescriptor: $getDesc,
          defineProperty: $setDesc
        });

        if (fails(function () {
          arrayToString.call({});
        })) {
          arrayToString = arrayToLocaleString = function toString() {
            return arrayJoin.call(this);
          };
        }

        var $TypedArrayPrototype$ = redefineAll({}, proto);
        redefineAll($TypedArrayPrototype$, $iterators);
        hide($TypedArrayPrototype$, ITERATOR, $iterators.values);
        redefineAll($TypedArrayPrototype$, {
          slice: $slice,
          set: $set,
          constructor: function constructor() {
            /* noop */
          },
          toString: arrayToString,
          toLocaleString: $toLocaleString
        });
        addGetter($TypedArrayPrototype$, 'buffer', 'b');
        addGetter($TypedArrayPrototype$, 'byteOffset', 'o');
        addGetter($TypedArrayPrototype$, 'byteLength', 'l');
        addGetter($TypedArrayPrototype$, 'length', 'e');
        dP($TypedArrayPrototype$, TAG, {
          get: function get() {
            return this[TYPED_ARRAY];
          }
        }); // eslint-disable-next-line max-statements

        module.exports = function (KEY, BYTES, wrapper, CLAMPED) {
          CLAMPED = !!CLAMPED;
          var NAME = KEY + (CLAMPED ? 'Clamped' : '') + 'Array';
          var GETTER = 'get' + KEY;
          var SETTER = 'set' + KEY;
          var TypedArray = global[NAME];
          var Base = TypedArray || {};
          var TAC = TypedArray && getPrototypeOf(TypedArray);
          var FORCED = !TypedArray || !$typed.ABV;
          var O = {};
          var TypedArrayPrototype = TypedArray && TypedArray[PROTOTYPE];

          var getter = function getter(that, index) {
            var data = that._d;
            return data.v[GETTER](index * BYTES + data.o, LITTLE_ENDIAN);
          };

          var setter = function setter(that, index, value) {
            var data = that._d;
            if (CLAMPED) value = (value = Math.round(value)) < 0 ? 0 : value > 0xff ? 0xff : value & 0xff;
            data.v[SETTER](index * BYTES + data.o, value, LITTLE_ENDIAN);
          };

          var addElement = function addElement(that, index) {
            dP(that, index, {
              get: function get() {
                return getter(this, index);
              },
              set: function set(value) {
                return setter(this, index, value);
              },
              enumerable: true
            });
          };

          if (FORCED) {
            TypedArray = wrapper(function (that, data, $offset, $length) {
              anInstance(that, TypedArray, NAME, '_d');
              var index = 0;
              var offset = 0;
              var buffer, byteLength, length, klass;

              if (!isObject(data)) {
                length = toIndex(data);
                byteLength = length * BYTES;
                buffer = new $ArrayBuffer(byteLength);
              } else if (data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER) {
                buffer = data;
                offset = toOffset($offset, BYTES);
                var $len = data.byteLength;

                if ($length === undefined) {
                  if ($len % BYTES) throw RangeError(WRONG_LENGTH);
                  byteLength = $len - offset;
                  if (byteLength < 0) throw RangeError(WRONG_LENGTH);
                } else {
                  byteLength = toLength($length) * BYTES;
                  if (byteLength + offset > $len) throw RangeError(WRONG_LENGTH);
                }

                length = byteLength / BYTES;
              } else if (TYPED_ARRAY in data) {
                return fromList(TypedArray, data);
              } else {
                return $from.call(TypedArray, data);
              }

              hide(that, '_d', {
                b: buffer,
                o: offset,
                l: byteLength,
                e: length,
                v: new $DataView(buffer)
              });

              while (index < length) {
                addElement(that, index++);
              }
            });
            TypedArrayPrototype = TypedArray[PROTOTYPE] = create($TypedArrayPrototype$);
            hide(TypedArrayPrototype, 'constructor', TypedArray);
          } else if (!fails(function () {
            TypedArray(1);
          }) || !fails(function () {
            new TypedArray(-1); // eslint-disable-line no-new
          }) || !$iterDetect(function (iter) {
            new TypedArray(); // eslint-disable-line no-new

            new TypedArray(null); // eslint-disable-line no-new

            new TypedArray(1.5); // eslint-disable-line no-new

            new TypedArray(iter); // eslint-disable-line no-new
          }, true)) {
            TypedArray = wrapper(function (that, data, $offset, $length) {
              anInstance(that, TypedArray, NAME);
              var klass; // `ws` module bug, temporarily remove validation length for Uint8Array
              // https://github.com/websockets/ws/pull/645

              if (!isObject(data)) return new Base(toIndex(data));

              if (data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER) {
                return $length !== undefined ? new Base(data, toOffset($offset, BYTES), $length) : $offset !== undefined ? new Base(data, toOffset($offset, BYTES)) : new Base(data);
              }

              if (TYPED_ARRAY in data) return fromList(TypedArray, data);
              return $from.call(TypedArray, data);
            });
            arrayForEach(TAC !== Function.prototype ? gOPN(Base).concat(gOPN(TAC)) : gOPN(Base), function (key) {
              if (!(key in TypedArray)) hide(TypedArray, key, Base[key]);
            });
            TypedArray[PROTOTYPE] = TypedArrayPrototype;
            if (!LIBRARY) TypedArrayPrototype.constructor = TypedArray;
          }

          var $nativeIterator = TypedArrayPrototype[ITERATOR];
          var CORRECT_ITER_NAME = !!$nativeIterator && ($nativeIterator.name == 'values' || $nativeIterator.name == undefined);
          var $iterator = $iterators.values;
          hide(TypedArray, TYPED_CONSTRUCTOR, true);
          hide(TypedArrayPrototype, TYPED_ARRAY, NAME);
          hide(TypedArrayPrototype, VIEW, true);
          hide(TypedArrayPrototype, DEF_CONSTRUCTOR, TypedArray);

          if (CLAMPED ? new TypedArray(1)[TAG] != NAME : !(TAG in TypedArrayPrototype)) {
            dP(TypedArrayPrototype, TAG, {
              get: function get() {
                return NAME;
              }
            });
          }

          O[NAME] = TypedArray;
          $export($export.G + $export.W + $export.F * (TypedArray != Base), O);
          $export($export.S, NAME, {
            BYTES_PER_ELEMENT: BYTES
          });
          $export($export.S + $export.F * fails(function () {
            Base.of.call(TypedArray, 1);
          }), NAME, {
            from: $from,
            of: $of
          });
          if (!(BYTES_PER_ELEMENT in TypedArrayPrototype)) hide(TypedArrayPrototype, BYTES_PER_ELEMENT, BYTES);
          $export($export.P, NAME, proto);
          setSpecies(NAME);
          $export($export.P + $export.F * FORCED_SET, NAME, {
            set: $set
          });
          $export($export.P + $export.F * !CORRECT_ITER_NAME, NAME, $iterators);
          if (!LIBRARY && TypedArrayPrototype.toString != arrayToString) TypedArrayPrototype.toString = arrayToString;
          $export($export.P + $export.F * fails(function () {
            new TypedArray(1).slice();
          }), NAME, {
            slice: $slice
          });
          $export($export.P + $export.F * (fails(function () {
            return [1, 2].toLocaleString() != new TypedArray([1, 2]).toLocaleString();
          }) || !fails(function () {
            TypedArrayPrototype.toLocaleString.call([1, 2]);
          })), NAME, {
            toLocaleString: $toLocaleString
          });
          Iterators[NAME] = CORRECT_ITER_NAME ? $nativeIterator : $iterator;
          if (!LIBRARY && !CORRECT_ITER_NAME) hide(TypedArrayPrototype, ITERATOR, $iterator);
        };
      } else module.exports = function () {
        /* empty */
      };
    }, {
      "100": 100,
      "104": 104,
      "11": 11,
      "114": 114,
      "115": 115,
      "116": 116,
      "118": 118,
      "119": 119,
      "12": 12,
      "120": 120,
      "122": 122,
      "123": 123,
      "124": 124,
      "128": 128,
      "129": 129,
      "141": 141,
      "17": 17,
      "25": 25,
      "29": 29,
      "33": 33,
      "35": 35,
      "40": 40,
      "41": 41,
      "42": 42,
      "48": 48,
      "51": 51,
      "56": 56,
      "58": 58,
      "6": 6,
      "60": 60,
      "71": 71,
      "72": 72,
      "75": 75,
      "77": 77,
      "79": 79,
      "8": 8,
      "9": 9,
      "92": 92,
      "93": 93
    }],
    122: [function (_dereq_, module, exports) {

      var global = _dereq_(40);

      var DESCRIPTORS = _dereq_(29);

      var LIBRARY = _dereq_(60);

      var $typed = _dereq_(123);

      var hide = _dereq_(42);

      var redefineAll = _dereq_(93);

      var fails = _dereq_(35);

      var anInstance = _dereq_(6);

      var toInteger = _dereq_(116);

      var toLength = _dereq_(118);

      var toIndex = _dereq_(115);

      var gOPN = _dereq_(77).f;

      var dP = _dereq_(72).f;

      var arrayFill = _dereq_(9);

      var setToStringTag = _dereq_(101);

      var ARRAY_BUFFER = 'ArrayBuffer';
      var DATA_VIEW = 'DataView';
      var PROTOTYPE = 'prototype';
      var WRONG_LENGTH = 'Wrong length!';
      var WRONG_INDEX = 'Wrong index!';
      var $ArrayBuffer = global[ARRAY_BUFFER];
      var $DataView = global[DATA_VIEW];
      var Math = global.Math;
      var RangeError = global.RangeError; // eslint-disable-next-line no-shadow-restricted-names

      var Infinity = global.Infinity;
      var BaseBuffer = $ArrayBuffer;
      var abs = Math.abs;
      var pow = Math.pow;
      var floor = Math.floor;
      var log = Math.log;
      var LN2 = Math.LN2;
      var BUFFER = 'buffer';
      var BYTE_LENGTH = 'byteLength';
      var BYTE_OFFSET = 'byteOffset';
      var $BUFFER = DESCRIPTORS ? '_b' : BUFFER;
      var $LENGTH = DESCRIPTORS ? '_l' : BYTE_LENGTH;
      var $OFFSET = DESCRIPTORS ? '_o' : BYTE_OFFSET; // IEEE754 conversions based on https://github.com/feross/ieee754

      function packIEEE754(value, mLen, nBytes) {
        var buffer = Array(nBytes);
        var eLen = nBytes * 8 - mLen - 1;
        var eMax = (1 << eLen) - 1;
        var eBias = eMax >> 1;
        var rt = mLen === 23 ? pow(2, -24) - pow(2, -77) : 0;
        var i = 0;
        var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
        var e, m, c;
        value = abs(value); // eslint-disable-next-line no-self-compare

        if (value != value || value === Infinity) {
          // eslint-disable-next-line no-self-compare
          m = value != value ? 1 : 0;
          e = eMax;
        } else {
          e = floor(log(value) / LN2);

          if (value * (c = pow(2, -e)) < 1) {
            e--;
            c *= 2;
          }

          if (e + eBias >= 1) {
            value += rt / c;
          } else {
            value += rt * pow(2, 1 - eBias);
          }

          if (value * c >= 2) {
            e++;
            c /= 2;
          }

          if (e + eBias >= eMax) {
            m = 0;
            e = eMax;
          } else if (e + eBias >= 1) {
            m = (value * c - 1) * pow(2, mLen);
            e = e + eBias;
          } else {
            m = value * pow(2, eBias - 1) * pow(2, mLen);
            e = 0;
          }
        }

        for (; mLen >= 8; buffer[i++] = m & 255, m /= 256, mLen -= 8) {
        }

        e = e << mLen | m;
        eLen += mLen;

        for (; eLen > 0; buffer[i++] = e & 255, e /= 256, eLen -= 8) {
        }

        buffer[--i] |= s * 128;
        return buffer;
      }

      function unpackIEEE754(buffer, mLen, nBytes) {
        var eLen = nBytes * 8 - mLen - 1;
        var eMax = (1 << eLen) - 1;
        var eBias = eMax >> 1;
        var nBits = eLen - 7;
        var i = nBytes - 1;
        var s = buffer[i--];
        var e = s & 127;
        var m;
        s >>= 7;

        for (; nBits > 0; e = e * 256 + buffer[i], i--, nBits -= 8) {
        }

        m = e & (1 << -nBits) - 1;
        e >>= -nBits;
        nBits += mLen;

        for (; nBits > 0; m = m * 256 + buffer[i], i--, nBits -= 8) {
        }

        if (e === 0) {
          e = 1 - eBias;
        } else if (e === eMax) {
          return m ? NaN : s ? -Infinity : Infinity;
        } else {
          m = m + pow(2, mLen);
          e = e - eBias;
        }

        return (s ? -1 : 1) * m * pow(2, e - mLen);
      }

      function unpackI32(bytes) {
        return bytes[3] << 24 | bytes[2] << 16 | bytes[1] << 8 | bytes[0];
      }

      function packI8(it) {
        return [it & 0xff];
      }

      function packI16(it) {
        return [it & 0xff, it >> 8 & 0xff];
      }

      function packI32(it) {
        return [it & 0xff, it >> 8 & 0xff, it >> 16 & 0xff, it >> 24 & 0xff];
      }

      function packF64(it) {
        return packIEEE754(it, 52, 8);
      }

      function packF32(it) {
        return packIEEE754(it, 23, 4);
      }

      function addGetter(C, key, internal) {
        dP(C[PROTOTYPE], key, {
          get: function get() {
            return this[internal];
          }
        });
      }

      function get(view, bytes, index, isLittleEndian) {
        var numIndex = +index;
        var intIndex = toIndex(numIndex);
        if (intIndex + bytes > view[$LENGTH]) throw RangeError(WRONG_INDEX);
        var store = view[$BUFFER]._b;
        var start = intIndex + view[$OFFSET];
        var pack = store.slice(start, start + bytes);
        return isLittleEndian ? pack : pack.reverse();
      }

      function set(view, bytes, index, conversion, value, isLittleEndian) {
        var numIndex = +index;
        var intIndex = toIndex(numIndex);
        if (intIndex + bytes > view[$LENGTH]) throw RangeError(WRONG_INDEX);
        var store = view[$BUFFER]._b;
        var start = intIndex + view[$OFFSET];
        var pack = conversion(+value);

        for (var i = 0; i < bytes; i++) {
          store[start + i] = pack[isLittleEndian ? i : bytes - i - 1];
        }
      }

      if (!$typed.ABV) {
        $ArrayBuffer = function ArrayBuffer(length) {
          anInstance(this, $ArrayBuffer, ARRAY_BUFFER);
          var byteLength = toIndex(length);
          this._b = arrayFill.call(Array(byteLength), 0);
          this[$LENGTH] = byteLength;
        };

        $DataView = function DataView(buffer, byteOffset, byteLength) {
          anInstance(this, $DataView, DATA_VIEW);
          anInstance(buffer, $ArrayBuffer, DATA_VIEW);
          var bufferLength = buffer[$LENGTH];
          var offset = toInteger(byteOffset);
          if (offset < 0 || offset > bufferLength) throw RangeError('Wrong offset!');
          byteLength = byteLength === undefined ? bufferLength - offset : toLength(byteLength);
          if (offset + byteLength > bufferLength) throw RangeError(WRONG_LENGTH);
          this[$BUFFER] = buffer;
          this[$OFFSET] = offset;
          this[$LENGTH] = byteLength;
        };

        if (DESCRIPTORS) {
          addGetter($ArrayBuffer, BYTE_LENGTH, '_l');
          addGetter($DataView, BUFFER, '_b');
          addGetter($DataView, BYTE_LENGTH, '_l');
          addGetter($DataView, BYTE_OFFSET, '_o');
        }

        redefineAll($DataView[PROTOTYPE], {
          getInt8: function getInt8(byteOffset) {
            return get(this, 1, byteOffset)[0] << 24 >> 24;
          },
          getUint8: function getUint8(byteOffset) {
            return get(this, 1, byteOffset)[0];
          },
          getInt16: function getInt16(byteOffset
          /* , littleEndian */
          ) {
            var bytes = get(this, 2, byteOffset, arguments[1]);
            return (bytes[1] << 8 | bytes[0]) << 16 >> 16;
          },
          getUint16: function getUint16(byteOffset
          /* , littleEndian */
          ) {
            var bytes = get(this, 2, byteOffset, arguments[1]);
            return bytes[1] << 8 | bytes[0];
          },
          getInt32: function getInt32(byteOffset
          /* , littleEndian */
          ) {
            return unpackI32(get(this, 4, byteOffset, arguments[1]));
          },
          getUint32: function getUint32(byteOffset
          /* , littleEndian */
          ) {
            return unpackI32(get(this, 4, byteOffset, arguments[1])) >>> 0;
          },
          getFloat32: function getFloat32(byteOffset
          /* , littleEndian */
          ) {
            return unpackIEEE754(get(this, 4, byteOffset, arguments[1]), 23, 4);
          },
          getFloat64: function getFloat64(byteOffset
          /* , littleEndian */
          ) {
            return unpackIEEE754(get(this, 8, byteOffset, arguments[1]), 52, 8);
          },
          setInt8: function setInt8(byteOffset, value) {
            set(this, 1, byteOffset, packI8, value);
          },
          setUint8: function setUint8(byteOffset, value) {
            set(this, 1, byteOffset, packI8, value);
          },
          setInt16: function setInt16(byteOffset, value
          /* , littleEndian */
          ) {
            set(this, 2, byteOffset, packI16, value, arguments[2]);
          },
          setUint16: function setUint16(byteOffset, value
          /* , littleEndian */
          ) {
            set(this, 2, byteOffset, packI16, value, arguments[2]);
          },
          setInt32: function setInt32(byteOffset, value
          /* , littleEndian */
          ) {
            set(this, 4, byteOffset, packI32, value, arguments[2]);
          },
          setUint32: function setUint32(byteOffset, value
          /* , littleEndian */
          ) {
            set(this, 4, byteOffset, packI32, value, arguments[2]);
          },
          setFloat32: function setFloat32(byteOffset, value
          /* , littleEndian */
          ) {
            set(this, 4, byteOffset, packF32, value, arguments[2]);
          },
          setFloat64: function setFloat64(byteOffset, value
          /* , littleEndian */
          ) {
            set(this, 8, byteOffset, packF64, value, arguments[2]);
          }
        });
      } else {
        if (!fails(function () {
          $ArrayBuffer(1);
        }) || !fails(function () {
          new $ArrayBuffer(-1); // eslint-disable-line no-new
        }) || fails(function () {
          new $ArrayBuffer(); // eslint-disable-line no-new

          new $ArrayBuffer(1.5); // eslint-disable-line no-new

          new $ArrayBuffer(NaN); // eslint-disable-line no-new

          return $ArrayBuffer.name != ARRAY_BUFFER;
        })) {
          $ArrayBuffer = function ArrayBuffer(length) {
            anInstance(this, $ArrayBuffer);
            return new BaseBuffer(toIndex(length));
          };

          var ArrayBufferProto = $ArrayBuffer[PROTOTYPE] = BaseBuffer[PROTOTYPE];

          for (var keys = gOPN(BaseBuffer), j = 0, key; keys.length > j;) {
            if (!((key = keys[j++]) in $ArrayBuffer)) hide($ArrayBuffer, key, BaseBuffer[key]);
          }

          if (!LIBRARY) ArrayBufferProto.constructor = $ArrayBuffer;
        } // iOS Safari 7.x bug


        var view = new $DataView(new $ArrayBuffer(2));
        var $setInt8 = $DataView[PROTOTYPE].setInt8;
        view.setInt8(0, 2147483648);
        view.setInt8(1, 2147483649);
        if (view.getInt8(0) || !view.getInt8(1)) redefineAll($DataView[PROTOTYPE], {
          setInt8: function setInt8(byteOffset, value) {
            $setInt8.call(this, byteOffset, value << 24 >> 24);
          },
          setUint8: function setUint8(byteOffset, value) {
            $setInt8.call(this, byteOffset, value << 24 >> 24);
          }
        }, true);
      }

      setToStringTag($ArrayBuffer, ARRAY_BUFFER);
      setToStringTag($DataView, DATA_VIEW);
      hide($DataView[PROTOTYPE], $typed.VIEW, true);
      exports[ARRAY_BUFFER] = $ArrayBuffer;
      exports[DATA_VIEW] = $DataView;
    }, {
      "101": 101,
      "115": 115,
      "116": 116,
      "118": 118,
      "123": 123,
      "29": 29,
      "35": 35,
      "40": 40,
      "42": 42,
      "6": 6,
      "60": 60,
      "72": 72,
      "77": 77,
      "9": 9,
      "93": 93
    }],
    123: [function (_dereq_, module, exports) {
      var global = _dereq_(40);

      var hide = _dereq_(42);

      var uid = _dereq_(124);

      var TYPED = uid('typed_array');
      var VIEW = uid('view');
      var ABV = !!(global.ArrayBuffer && global.DataView);
      var CONSTR = ABV;
      var i = 0;
      var l = 9;
      var Typed;
      var TypedArrayConstructors = 'Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array'.split(',');

      while (i < l) {
        if (Typed = global[TypedArrayConstructors[i++]]) {
          hide(Typed.prototype, TYPED, true);
          hide(Typed.prototype, VIEW, true);
        } else CONSTR = false;
      }

      module.exports = {
        ABV: ABV,
        CONSTR: CONSTR,
        TYPED: TYPED,
        VIEW: VIEW
      };
    }, {
      "124": 124,
      "40": 40,
      "42": 42
    }],
    124: [function (_dereq_, module, exports) {
      var id = 0;
      var px = Math.random();

      module.exports = function (key) {
        return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
      };
    }, {}],
    125: [function (_dereq_, module, exports) {
      var isObject = _dereq_(51);

      module.exports = function (it, TYPE) {
        if (!isObject(it) || it._t !== TYPE) throw TypeError('Incompatible receiver, ' + TYPE + ' required!');
        return it;
      };
    }, {
      "51": 51
    }],
    126: [function (_dereq_, module, exports) {
      var global = _dereq_(40);

      var core = _dereq_(23);

      var LIBRARY = _dereq_(60);

      var wksExt = _dereq_(127);

      var defineProperty = _dereq_(72).f;

      module.exports = function (name) {
        var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});
        if (name.charAt(0) != '_' && !(name in $Symbol)) defineProperty($Symbol, name, {
          value: wksExt.f(name)
        });
      };
    }, {
      "127": 127,
      "23": 23,
      "40": 40,
      "60": 60,
      "72": 72
    }],
    127: [function (_dereq_, module, exports) {
      exports.f = _dereq_(128);
    }, {
      "128": 128
    }],
    128: [function (_dereq_, module, exports) {
      var store = _dereq_(103)('wks');

      var uid = _dereq_(124);

      var _Symbol = _dereq_(40).Symbol;

      var USE_SYMBOL = typeof _Symbol == 'function';

      var $exports = module.exports = function (name) {
        return store[name] || (store[name] = USE_SYMBOL && _Symbol[name] || (USE_SYMBOL ? _Symbol : uid)('Symbol.' + name));
      };

      $exports.store = store;
    }, {
      "103": 103,
      "124": 124,
      "40": 40
    }],
    129: [function (_dereq_, module, exports) {
      var classof = _dereq_(17);

      var ITERATOR = _dereq_(128)('iterator');

      var Iterators = _dereq_(58);

      module.exports = _dereq_(23).getIteratorMethod = function (it) {
        if (it != undefined) return it[ITERATOR] || it['@@iterator'] || Iterators[classof(it)];
      };
    }, {
      "128": 128,
      "17": 17,
      "23": 23,
      "58": 58
    }],
    130: [function (_dereq_, module, exports) {
      // https://github.com/benjamingr/RexExp.escape
      var $export = _dereq_(33);

      var $re = _dereq_(95)(/[\\^$*+?.()|[\]{}]/g, '\\$&');

      $export($export.S, 'RegExp', {
        escape: function escape(it) {
          return $re(it);
        }
      });
    }, {
      "33": 33,
      "95": 95
    }],
    131: [function (_dereq_, module, exports) {
      // 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)
      var $export = _dereq_(33);

      $export($export.P, 'Array', {
        copyWithin: _dereq_(8)
      });

      _dereq_(5)('copyWithin');
    }, {
      "33": 33,
      "5": 5,
      "8": 8
    }],
    132: [function (_dereq_, module, exports) {

      var $export = _dereq_(33);

      var $every = _dereq_(12)(4);

      $export($export.P + $export.F * !_dereq_(105)([].every, true), 'Array', {
        // 22.1.3.5 / 15.4.4.16 Array.prototype.every(callbackfn [, thisArg])
        every: function every(callbackfn
        /* , thisArg */
        ) {
          return $every(this, callbackfn, arguments[1]);
        }
      });
    }, {
      "105": 105,
      "12": 12,
      "33": 33
    }],
    133: [function (_dereq_, module, exports) {
      // 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)
      var $export = _dereq_(33);

      $export($export.P, 'Array', {
        fill: _dereq_(9)
      });

      _dereq_(5)('fill');
    }, {
      "33": 33,
      "5": 5,
      "9": 9
    }],
    134: [function (_dereq_, module, exports) {

      var $export = _dereq_(33);

      var $filter = _dereq_(12)(2);

      $export($export.P + $export.F * !_dereq_(105)([].filter, true), 'Array', {
        // 22.1.3.7 / 15.4.4.20 Array.prototype.filter(callbackfn [, thisArg])
        filter: function filter(callbackfn
        /* , thisArg */
        ) {
          return $filter(this, callbackfn, arguments[1]);
        }
      });
    }, {
      "105": 105,
      "12": 12,
      "33": 33
    }],
    135: [function (_dereq_, module, exports) {

      var $export = _dereq_(33);

      var $find = _dereq_(12)(6);

      var KEY = 'findIndex';
      var forced = true; // Shouldn't skip holes

      if (KEY in []) Array(1)[KEY](function () {
        forced = false;
      });
      $export($export.P + $export.F * forced, 'Array', {
        findIndex: function findIndex(callbackfn
        /* , that = undefined */
        ) {
          return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
        }
      });

      _dereq_(5)(KEY);
    }, {
      "12": 12,
      "33": 33,
      "5": 5
    }],
    136: [function (_dereq_, module, exports) {

      var $export = _dereq_(33);

      var $find = _dereq_(12)(5);

      var KEY = 'find';
      var forced = true; // Shouldn't skip holes

      if (KEY in []) Array(1)[KEY](function () {
        forced = false;
      });
      $export($export.P + $export.F * forced, 'Array', {
        find: function find(callbackfn
        /* , that = undefined */
        ) {
          return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
        }
      });

      _dereq_(5)(KEY);
    }, {
      "12": 12,
      "33": 33,
      "5": 5
    }],
    137: [function (_dereq_, module, exports) {

      var $export = _dereq_(33);

      var $forEach = _dereq_(12)(0);

      var STRICT = _dereq_(105)([].forEach, true);

      $export($export.P + $export.F * !STRICT, 'Array', {
        // 22.1.3.10 / 15.4.4.18 Array.prototype.forEach(callbackfn [, thisArg])
        forEach: function forEach(callbackfn
        /* , thisArg */
        ) {
          return $forEach(this, callbackfn, arguments[1]);
        }
      });
    }, {
      "105": 105,
      "12": 12,
      "33": 33
    }],
    138: [function (_dereq_, module, exports) {

      var ctx = _dereq_(25);

      var $export = _dereq_(33);

      var toObject = _dereq_(119);

      var call = _dereq_(53);

      var isArrayIter = _dereq_(48);

      var toLength = _dereq_(118);

      var createProperty = _dereq_(24);

      var getIterFn = _dereq_(129);

      $export($export.S + $export.F * !_dereq_(56)(function (iter) {
        Array.from(iter);
      }), 'Array', {
        // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
        from: function from(arrayLike
        /* , mapfn = undefined, thisArg = undefined */
        ) {
          var O = toObject(arrayLike);
          var C = typeof this == 'function' ? this : Array;
          var aLen = arguments.length;
          var mapfn = aLen > 1 ? arguments[1] : undefined;
          var mapping = mapfn !== undefined;
          var index = 0;
          var iterFn = getIterFn(O);
          var length, result, step, iterator;
          if (mapping) mapfn = ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2); // if object isn't iterable or it's array with default iterator - use simple case

          if (iterFn != undefined && !(C == Array && isArrayIter(iterFn))) {
            for (iterator = iterFn.call(O), result = new C(); !(step = iterator.next()).done; index++) {
              createProperty(result, index, mapping ? call(iterator, mapfn, [step.value, index], true) : step.value);
            }
          } else {
            length = toLength(O.length);

            for (result = new C(length); length > index; index++) {
              createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);
            }
          }

          result.length = index;
          return result;
        }
      });
    }, {
      "118": 118,
      "119": 119,
      "129": 129,
      "24": 24,
      "25": 25,
      "33": 33,
      "48": 48,
      "53": 53,
      "56": 56
    }],
    139: [function (_dereq_, module, exports) {

      var $export = _dereq_(33);

      var $indexOf = _dereq_(11)(false);

      var $native = [].indexOf;
      var NEGATIVE_ZERO = !!$native && 1 / [1].indexOf(1, -0) < 0;
      $export($export.P + $export.F * (NEGATIVE_ZERO || !_dereq_(105)($native)), 'Array', {
        // 22.1.3.11 / 15.4.4.14 Array.prototype.indexOf(searchElement [, fromIndex])
        indexOf: function indexOf(searchElement
        /* , fromIndex = 0 */
        ) {
          return NEGATIVE_ZERO // convert -0 to +0
          ? $native.apply(this, arguments) || 0 : $indexOf(this, searchElement, arguments[1]);
        }
      });
    }, {
      "105": 105,
      "11": 11,
      "33": 33
    }],
    140: [function (_dereq_, module, exports) {
      // 22.1.2.2 / 15.4.3.2 Array.isArray(arg)
      var $export = _dereq_(33);

      $export($export.S, 'Array', {
        isArray: _dereq_(49)
      });
    }, {
      "33": 33,
      "49": 49
    }],
    141: [function (_dereq_, module, exports) {

      var addToUnscopables = _dereq_(5);

      var step = _dereq_(57);

      var Iterators = _dereq_(58);

      var toIObject = _dereq_(117); // 22.1.3.4 Array.prototype.entries()
      // 22.1.3.13 Array.prototype.keys()
      // 22.1.3.29 Array.prototype.values()
      // 22.1.3.30 Array.prototype[@@iterator]()


      module.exports = _dereq_(55)(Array, 'Array', function (iterated, kind) {
        this._t = toIObject(iterated); // target

        this._i = 0; // next index

        this._k = kind; // kind
        // 22.1.5.2.1 %ArrayIteratorPrototype%.next()
      }, function () {
        var O = this._t;
        var kind = this._k;
        var index = this._i++;

        if (!O || index >= O.length) {
          this._t = undefined;
          return step(1);
        }

        if (kind == 'keys') return step(0, index);
        if (kind == 'values') return step(0, O[index]);
        return step(0, [index, O[index]]);
      }, 'values'); // argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)

      Iterators.Arguments = Iterators.Array;
      addToUnscopables('keys');
      addToUnscopables('values');
      addToUnscopables('entries');
    }, {
      "117": 117,
      "5": 5,
      "55": 55,
      "57": 57,
      "58": 58
    }],
    142: [function (_dereq_, module, exports) {

      var $export = _dereq_(33);

      var toIObject = _dereq_(117);

      var arrayJoin = [].join; // fallback for not array-like strings

      $export($export.P + $export.F * (_dereq_(47) != Object || !_dereq_(105)(arrayJoin)), 'Array', {
        join: function join(separator) {
          return arrayJoin.call(toIObject(this), separator === undefined ? ',' : separator);
        }
      });
    }, {
      "105": 105,
      "117": 117,
      "33": 33,
      "47": 47
    }],
    143: [function (_dereq_, module, exports) {

      var $export = _dereq_(33);

      var toIObject = _dereq_(117);

      var toInteger = _dereq_(116);

      var toLength = _dereq_(118);

      var $native = [].lastIndexOf;
      var NEGATIVE_ZERO = !!$native && 1 / [1].lastIndexOf(1, -0) < 0;
      $export($export.P + $export.F * (NEGATIVE_ZERO || !_dereq_(105)($native)), 'Array', {
        // 22.1.3.14 / 15.4.4.15 Array.prototype.lastIndexOf(searchElement [, fromIndex])
        lastIndexOf: function lastIndexOf(searchElement
        /* , fromIndex = @[*-1] */
        ) {
          // convert -0 to +0
          if (NEGATIVE_ZERO) return $native.apply(this, arguments) || 0;
          var O = toIObject(this);
          var length = toLength(O.length);
          var index = length - 1;
          if (arguments.length > 1) index = Math.min(index, toInteger(arguments[1]));
          if (index < 0) index = length + index;

          for (; index >= 0; index--) {
            if (index in O) if (O[index] === searchElement) return index || 0;
          }

          return -1;
        }
      });
    }, {
      "105": 105,
      "116": 116,
      "117": 117,
      "118": 118,
      "33": 33
    }],
    144: [function (_dereq_, module, exports) {

      var $export = _dereq_(33);

      var $map = _dereq_(12)(1);

      $export($export.P + $export.F * !_dereq_(105)([].map, true), 'Array', {
        // 22.1.3.15 / 15.4.4.19 Array.prototype.map(callbackfn [, thisArg])
        map: function map(callbackfn
        /* , thisArg */
        ) {
          return $map(this, callbackfn, arguments[1]);
        }
      });
    }, {
      "105": 105,
      "12": 12,
      "33": 33
    }],
    145: [function (_dereq_, module, exports) {

      var $export = _dereq_(33);

      var createProperty = _dereq_(24); // WebKit Array.of isn't generic


      $export($export.S + $export.F * _dereq_(35)(function () {
        function F() {
          /* empty */
        }

        return !(Array.of.call(F) instanceof F);
      }), 'Array', {
        // 22.1.2.3 Array.of( ...items)
        of: function of()
        /* ...args */
        {
          var index = 0;
          var aLen = arguments.length;
          var result = new (typeof this == 'function' ? this : Array)(aLen);

          while (aLen > index) {
            createProperty(result, index, arguments[index++]);
          }

          result.length = aLen;
          return result;
        }
      });
    }, {
      "24": 24,
      "33": 33,
      "35": 35
    }],
    146: [function (_dereq_, module, exports) {

      var $export = _dereq_(33);

      var $reduce = _dereq_(13);

      $export($export.P + $export.F * !_dereq_(105)([].reduceRight, true), 'Array', {
        // 22.1.3.19 / 15.4.4.22 Array.prototype.reduceRight(callbackfn [, initialValue])
        reduceRight: function reduceRight(callbackfn
        /* , initialValue */
        ) {
          return $reduce(this, callbackfn, arguments.length, arguments[1], true);
        }
      });
    }, {
      "105": 105,
      "13": 13,
      "33": 33
    }],
    147: [function (_dereq_, module, exports) {

      var $export = _dereq_(33);

      var $reduce = _dereq_(13);

      $export($export.P + $export.F * !_dereq_(105)([].reduce, true), 'Array', {
        // 22.1.3.18 / 15.4.4.21 Array.prototype.reduce(callbackfn [, initialValue])
        reduce: function reduce(callbackfn
        /* , initialValue */
        ) {
          return $reduce(this, callbackfn, arguments.length, arguments[1], false);
        }
      });
    }, {
      "105": 105,
      "13": 13,
      "33": 33
    }],
    148: [function (_dereq_, module, exports) {

      var $export = _dereq_(33);

      var html = _dereq_(43);

      var cof = _dereq_(18);

      var toAbsoluteIndex = _dereq_(114);

      var toLength = _dereq_(118);

      var arraySlice = [].slice; // fallback for not array-like ES3 strings and DOM objects

      $export($export.P + $export.F * _dereq_(35)(function () {
        if (html) arraySlice.call(html);
      }), 'Array', {
        slice: function slice(begin, end) {
          var len = toLength(this.length);
          var klass = cof(this);
          end = end === undefined ? len : end;
          if (klass == 'Array') return arraySlice.call(this, begin, end);
          var start = toAbsoluteIndex(begin, len);
          var upTo = toAbsoluteIndex(end, len);
          var size = toLength(upTo - start);
          var cloned = Array(size);
          var i = 0;

          for (; i < size; i++) {
            cloned[i] = klass == 'String' ? this.charAt(start + i) : this[start + i];
          }

          return cloned;
        }
      });
    }, {
      "114": 114,
      "118": 118,
      "18": 18,
      "33": 33,
      "35": 35,
      "43": 43
    }],
    149: [function (_dereq_, module, exports) {

      var $export = _dereq_(33);

      var $some = _dereq_(12)(3);

      $export($export.P + $export.F * !_dereq_(105)([].some, true), 'Array', {
        // 22.1.3.23 / 15.4.4.17 Array.prototype.some(callbackfn [, thisArg])
        some: function some(callbackfn
        /* , thisArg */
        ) {
          return $some(this, callbackfn, arguments[1]);
        }
      });
    }, {
      "105": 105,
      "12": 12,
      "33": 33
    }],
    150: [function (_dereq_, module, exports) {

      var $export = _dereq_(33);

      var aFunction = _dereq_(3);

      var toObject = _dereq_(119);

      var fails = _dereq_(35);

      var $sort = [].sort;
      var test = [1, 2, 3];
      $export($export.P + $export.F * (fails(function () {
        // IE8-
        test.sort(undefined);
      }) || !fails(function () {
        // V8 bug
        test.sort(null); // Old WebKit
      }) || !_dereq_(105)($sort)), 'Array', {
        // 22.1.3.25 Array.prototype.sort(comparefn)
        sort: function sort(comparefn) {
          return comparefn === undefined ? $sort.call(toObject(this)) : $sort.call(toObject(this), aFunction(comparefn));
        }
      });
    }, {
      "105": 105,
      "119": 119,
      "3": 3,
      "33": 33,
      "35": 35
    }],
    151: [function (_dereq_, module, exports) {
      _dereq_(100)('Array');
    }, {
      "100": 100
    }],
    152: [function (_dereq_, module, exports) {
      // 20.3.3.1 / 15.9.4.4 Date.now()
      var $export = _dereq_(33);

      $export($export.S, 'Date', {
        now: function now() {
          return new Date().getTime();
        }
      });
    }, {
      "33": 33
    }],
    153: [function (_dereq_, module, exports) {
      // 20.3.4.36 / 15.9.5.43 Date.prototype.toISOString()
      var $export = _dereq_(33);

      var toISOString = _dereq_(26); // PhantomJS / old WebKit has a broken implementations


      $export($export.P + $export.F * (Date.prototype.toISOString !== toISOString), 'Date', {
        toISOString: toISOString
      });
    }, {
      "26": 26,
      "33": 33
    }],
    154: [function (_dereq_, module, exports) {

      var $export = _dereq_(33);

      var toObject = _dereq_(119);

      var toPrimitive = _dereq_(120);

      $export($export.P + $export.F * _dereq_(35)(function () {
        return new Date(NaN).toJSON() !== null || Date.prototype.toJSON.call({
          toISOString: function toISOString() {
            return 1;
          }
        }) !== 1;
      }), 'Date', {
        // eslint-disable-next-line no-unused-vars
        toJSON: function toJSON(key) {
          var O = toObject(this);
          var pv = toPrimitive(O);
          return typeof pv == 'number' && !isFinite(pv) ? null : O.toISOString();
        }
      });
    }, {
      "119": 119,
      "120": 120,
      "33": 33,
      "35": 35
    }],
    155: [function (_dereq_, module, exports) {
      var TO_PRIMITIVE = _dereq_(128)('toPrimitive');

      var proto = Date.prototype;
      if (!(TO_PRIMITIVE in proto)) _dereq_(42)(proto, TO_PRIMITIVE, _dereq_(27));
    }, {
      "128": 128,
      "27": 27,
      "42": 42
    }],
    156: [function (_dereq_, module, exports) {
      var DateProto = Date.prototype;
      var INVALID_DATE = 'Invalid Date';
      var TO_STRING = 'toString';
      var $toString = DateProto[TO_STRING];
      var getTime = DateProto.getTime;

      if (new Date(NaN) + '' != INVALID_DATE) {
        _dereq_(94)(DateProto, TO_STRING, function toString() {
          var value = getTime.call(this); // eslint-disable-next-line no-self-compare

          return value === value ? $toString.call(this) : INVALID_DATE;
        });
      }
    }, {
      "94": 94
    }],
    157: [function (_dereq_, module, exports) {
      // 19.2.3.2 / 15.3.4.5 Function.prototype.bind(thisArg, args...)
      var $export = _dereq_(33);

      $export($export.P, 'Function', {
        bind: _dereq_(16)
      });
    }, {
      "16": 16,
      "33": 33
    }],
    158: [function (_dereq_, module, exports) {

      var isObject = _dereq_(51);

      var getPrototypeOf = _dereq_(79);

      var HAS_INSTANCE = _dereq_(128)('hasInstance');

      var FunctionProto = Function.prototype; // 19.2.3.6 Function.prototype[@@hasInstance](V)

      if (!(HAS_INSTANCE in FunctionProto)) _dereq_(72).f(FunctionProto, HAS_INSTANCE, {
        value: function value(O) {
          if (typeof this != 'function' || !isObject(O)) return false;
          if (!isObject(this.prototype)) return O instanceof this; // for environment w/o native `@@hasInstance` logic enough `instanceof`, but add this:

          while (O = getPrototypeOf(O)) {
            if (this.prototype === O) return true;
          }

          return false;
        }
      });
    }, {
      "128": 128,
      "51": 51,
      "72": 72,
      "79": 79
    }],
    159: [function (_dereq_, module, exports) {
      var dP = _dereq_(72).f;

      var FProto = Function.prototype;
      var nameRE = /^\s*function ([^ (]*)/;
      var NAME = 'name'; // 19.2.4.2 name

      NAME in FProto || _dereq_(29) && dP(FProto, NAME, {
        configurable: true,
        get: function get() {
          try {
            return ('' + this).match(nameRE)[1];
          } catch (e) {
            return '';
          }
        }
      });
    }, {
      "29": 29,
      "72": 72
    }],
    160: [function (_dereq_, module, exports) {

      var strong = _dereq_(19);

      var validate = _dereq_(125);

      var MAP = 'Map'; // 23.1 Map Objects

      module.exports = _dereq_(22)(MAP, function (get) {
        return function Map() {
          return get(this, arguments.length > 0 ? arguments[0] : undefined);
        };
      }, {
        // 23.1.3.6 Map.prototype.get(key)
        get: function get(key) {
          var entry = strong.getEntry(validate(this, MAP), key);
          return entry && entry.v;
        },
        // 23.1.3.9 Map.prototype.set(key, value)
        set: function set(key, value) {
          return strong.def(validate(this, MAP), key === 0 ? 0 : key, value);
        }
      }, strong, true);
    }, {
      "125": 125,
      "19": 19,
      "22": 22
    }],
    161: [function (_dereq_, module, exports) {
      // 20.2.2.3 Math.acosh(x)
      var $export = _dereq_(33);

      var log1p = _dereq_(63);

      var sqrt = Math.sqrt;
      var $acosh = Math.acosh;
      $export($export.S + $export.F * !($acosh // V8 bug: https://code.google.com/p/v8/issues/detail?id=3509
      && Math.floor($acosh(Number.MAX_VALUE)) == 710 // Tor Browser bug: Math.acosh(Infinity) -> NaN
      && $acosh(Infinity) == Infinity), 'Math', {
        acosh: function acosh(x) {
          return (x = +x) < 1 ? NaN : x > 94906265.62425156 ? Math.log(x) + Math.LN2 : log1p(x - 1 + sqrt(x - 1) * sqrt(x + 1));
        }
      });
    }, {
      "33": 33,
      "63": 63
    }],
    162: [function (_dereq_, module, exports) {
      // 20.2.2.5 Math.asinh(x)
      var $export = _dereq_(33);

      var $asinh = Math.asinh;

      function asinh(x) {
        return !isFinite(x = +x) || x == 0 ? x : x < 0 ? -asinh(-x) : Math.log(x + Math.sqrt(x * x + 1));
      } // Tor Browser bug: Math.asinh(0) -> -0


      $export($export.S + $export.F * !($asinh && 1 / $asinh(0) > 0), 'Math', {
        asinh: asinh
      });
    }, {
      "33": 33
    }],
    163: [function (_dereq_, module, exports) {
      // 20.2.2.7 Math.atanh(x)
      var $export = _dereq_(33);

      var $atanh = Math.atanh; // Tor Browser bug: Math.atanh(-0) -> 0

      $export($export.S + $export.F * !($atanh && 1 / $atanh(-0) < 0), 'Math', {
        atanh: function atanh(x) {
          return (x = +x) == 0 ? x : Math.log((1 + x) / (1 - x)) / 2;
        }
      });
    }, {
      "33": 33
    }],
    164: [function (_dereq_, module, exports) {
      // 20.2.2.9 Math.cbrt(x)
      var $export = _dereq_(33);

      var sign = _dereq_(65);

      $export($export.S, 'Math', {
        cbrt: function cbrt(x) {
          return sign(x = +x) * Math.pow(Math.abs(x), 1 / 3);
        }
      });
    }, {
      "33": 33,
      "65": 65
    }],
    165: [function (_dereq_, module, exports) {
      // 20.2.2.11 Math.clz32(x)
      var $export = _dereq_(33);

      $export($export.S, 'Math', {
        clz32: function clz32(x) {
          return (x >>>= 0) ? 31 - Math.floor(Math.log(x + 0.5) * Math.LOG2E) : 32;
        }
      });
    }, {
      "33": 33
    }],
    166: [function (_dereq_, module, exports) {
      // 20.2.2.12 Math.cosh(x)
      var $export = _dereq_(33);

      var exp = Math.exp;
      $export($export.S, 'Math', {
        cosh: function cosh(x) {
          return (exp(x = +x) + exp(-x)) / 2;
        }
      });
    }, {
      "33": 33
    }],
    167: [function (_dereq_, module, exports) {
      // 20.2.2.14 Math.expm1(x)
      var $export = _dereq_(33);

      var $expm1 = _dereq_(61);

      $export($export.S + $export.F * ($expm1 != Math.expm1), 'Math', {
        expm1: $expm1
      });
    }, {
      "33": 33,
      "61": 61
    }],
    168: [function (_dereq_, module, exports) {
      // 20.2.2.16 Math.fround(x)
      var $export = _dereq_(33);

      $export($export.S, 'Math', {
        fround: _dereq_(62)
      });
    }, {
      "33": 33,
      "62": 62
    }],
    169: [function (_dereq_, module, exports) {
      // 20.2.2.17 Math.hypot([value1[, value2[, … ]]])
      var $export = _dereq_(33);

      var abs = Math.abs;
      $export($export.S, 'Math', {
        hypot: function hypot(value1, value2) {
          // eslint-disable-line no-unused-vars
          var sum = 0;
          var i = 0;
          var aLen = arguments.length;
          var larg = 0;
          var arg, div;

          while (i < aLen) {
            arg = abs(arguments[i++]);

            if (larg < arg) {
              div = larg / arg;
              sum = sum * div * div + 1;
              larg = arg;
            } else if (arg > 0) {
              div = arg / larg;
              sum += div * div;
            } else sum += arg;
          }

          return larg === Infinity ? Infinity : larg * Math.sqrt(sum);
        }
      });
    }, {
      "33": 33
    }],
    170: [function (_dereq_, module, exports) {
      // 20.2.2.18 Math.imul(x, y)
      var $export = _dereq_(33);

      var $imul = Math.imul; // some WebKit versions fails with big numbers, some has wrong arity

      $export($export.S + $export.F * _dereq_(35)(function () {
        return $imul(0xffffffff, 5) != -5 || $imul.length != 2;
      }), 'Math', {
        imul: function imul(x, y) {
          var UINT16 = 0xffff;
          var xn = +x;
          var yn = +y;
          var xl = UINT16 & xn;
          var yl = UINT16 & yn;
          return 0 | xl * yl + ((UINT16 & xn >>> 16) * yl + xl * (UINT16 & yn >>> 16) << 16 >>> 0);
        }
      });
    }, {
      "33": 33,
      "35": 35
    }],
    171: [function (_dereq_, module, exports) {
      // 20.2.2.21 Math.log10(x)
      var $export = _dereq_(33);

      $export($export.S, 'Math', {
        log10: function log10(x) {
          return Math.log(x) * Math.LOG10E;
        }
      });
    }, {
      "33": 33
    }],
    172: [function (_dereq_, module, exports) {
      // 20.2.2.20 Math.log1p(x)
      var $export = _dereq_(33);

      $export($export.S, 'Math', {
        log1p: _dereq_(63)
      });
    }, {
      "33": 33,
      "63": 63
    }],
    173: [function (_dereq_, module, exports) {
      // 20.2.2.22 Math.log2(x)
      var $export = _dereq_(33);

      $export($export.S, 'Math', {
        log2: function log2(x) {
          return Math.log(x) / Math.LN2;
        }
      });
    }, {
      "33": 33
    }],
    174: [function (_dereq_, module, exports) {
      // 20.2.2.28 Math.sign(x)
      var $export = _dereq_(33);

      $export($export.S, 'Math', {
        sign: _dereq_(65)
      });
    }, {
      "33": 33,
      "65": 65
    }],
    175: [function (_dereq_, module, exports) {
      // 20.2.2.30 Math.sinh(x)
      var $export = _dereq_(33);

      var expm1 = _dereq_(61);

      var exp = Math.exp; // V8 near Chromium 38 has a problem with very small numbers

      $export($export.S + $export.F * _dereq_(35)(function () {
        return !Math.sinh(-2e-17) != -2e-17;
      }), 'Math', {
        sinh: function sinh(x) {
          return Math.abs(x = +x) < 1 ? (expm1(x) - expm1(-x)) / 2 : (exp(x - 1) - exp(-x - 1)) * (Math.E / 2);
        }
      });
    }, {
      "33": 33,
      "35": 35,
      "61": 61
    }],
    176: [function (_dereq_, module, exports) {
      // 20.2.2.33 Math.tanh(x)
      var $export = _dereq_(33);

      var expm1 = _dereq_(61);

      var exp = Math.exp;
      $export($export.S, 'Math', {
        tanh: function tanh(x) {
          var a = expm1(x = +x);
          var b = expm1(-x);
          return a == Infinity ? 1 : b == Infinity ? -1 : (a - b) / (exp(x) + exp(-x));
        }
      });
    }, {
      "33": 33,
      "61": 61
    }],
    177: [function (_dereq_, module, exports) {
      // 20.2.2.34 Math.trunc(x)
      var $export = _dereq_(33);

      $export($export.S, 'Math', {
        trunc: function trunc(it) {
          return (it > 0 ? Math.floor : Math.ceil)(it);
        }
      });
    }, {
      "33": 33
    }],
    178: [function (_dereq_, module, exports) {

      var global = _dereq_(40);

      var has = _dereq_(41);

      var cof = _dereq_(18);

      var inheritIfRequired = _dereq_(45);

      var toPrimitive = _dereq_(120);

      var fails = _dereq_(35);

      var gOPN = _dereq_(77).f;

      var gOPD = _dereq_(75).f;

      var dP = _dereq_(72).f;

      var $trim = _dereq_(111).trim;

      var NUMBER = 'Number';
      var $Number = global[NUMBER];
      var Base = $Number;
      var proto = $Number.prototype; // Opera ~12 has broken Object#toString

      var BROKEN_COF = cof(_dereq_(71)(proto)) == NUMBER;
      var TRIM = 'trim' in String.prototype; // 7.1.3 ToNumber(argument)

      var toNumber = function toNumber(argument) {
        var it = toPrimitive(argument, false);

        if (typeof it == 'string' && it.length > 2) {
          it = TRIM ? it.trim() : $trim(it, 3);
          var first = it.charCodeAt(0);
          var third, radix, maxCode;

          if (first === 43 || first === 45) {
            third = it.charCodeAt(2);
            if (third === 88 || third === 120) return NaN; // Number('+0x1') should be NaN, old V8 fix
          } else if (first === 48) {
            switch (it.charCodeAt(1)) {
              case 66:
              case 98:
                radix = 2;
                maxCode = 49;
                break;
              // fast equal /^0b[01]+$/i

              case 79:
              case 111:
                radix = 8;
                maxCode = 55;
                break;
              // fast equal /^0o[0-7]+$/i

              default:
                return +it;
            }

            for (var digits = it.slice(2), i = 0, l = digits.length, code; i < l; i++) {
              code = digits.charCodeAt(i); // parseInt parses a string to a first unavailable symbol
              // but ToNumber should return NaN if a string contains unavailable symbols

              if (code < 48 || code > maxCode) return NaN;
            }

            return parseInt(digits, radix);
          }
        }

        return +it;
      };

      if (!$Number(' 0o1') || !$Number('0b1') || $Number('+0x1')) {
        $Number = function Number(value) {
          var it = arguments.length < 1 ? 0 : value;
          var that = this;
          return that instanceof $Number // check on 1..constructor(foo) case
          && (BROKEN_COF ? fails(function () {
            proto.valueOf.call(that);
          }) : cof(that) != NUMBER) ? inheritIfRequired(new Base(toNumber(it)), that, $Number) : toNumber(it);
        };

        for (var keys = _dereq_(29) ? gOPN(Base) : ( // ES3:
        'MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,' + // ES6 (in case, if modules with ES6 Number statics required before):
        'EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,' + 'MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger').split(','), j = 0, key; keys.length > j; j++) {
          if (has(Base, key = keys[j]) && !has($Number, key)) {
            dP($Number, key, gOPD(Base, key));
          }
        }

        $Number.prototype = proto;
        proto.constructor = $Number;

        _dereq_(94)(global, NUMBER, $Number);
      }
    }, {
      "111": 111,
      "120": 120,
      "18": 18,
      "29": 29,
      "35": 35,
      "40": 40,
      "41": 41,
      "45": 45,
      "71": 71,
      "72": 72,
      "75": 75,
      "77": 77,
      "94": 94
    }],
    179: [function (_dereq_, module, exports) {
      // 20.1.2.1 Number.EPSILON
      var $export = _dereq_(33);

      $export($export.S, 'Number', {
        EPSILON: Math.pow(2, -52)
      });
    }, {
      "33": 33
    }],
    180: [function (_dereq_, module, exports) {
      // 20.1.2.2 Number.isFinite(number)
      var $export = _dereq_(33);

      var _isFinite = _dereq_(40).isFinite;

      $export($export.S, 'Number', {
        isFinite: function isFinite(it) {
          return typeof it == 'number' && _isFinite(it);
        }
      });
    }, {
      "33": 33,
      "40": 40
    }],
    181: [function (_dereq_, module, exports) {
      // 20.1.2.3 Number.isInteger(number)
      var $export = _dereq_(33);

      $export($export.S, 'Number', {
        isInteger: _dereq_(50)
      });
    }, {
      "33": 33,
      "50": 50
    }],
    182: [function (_dereq_, module, exports) {
      // 20.1.2.4 Number.isNaN(number)
      var $export = _dereq_(33);

      $export($export.S, 'Number', {
        isNaN: function isNaN(number) {
          // eslint-disable-next-line no-self-compare
          return number != number;
        }
      });
    }, {
      "33": 33
    }],
    183: [function (_dereq_, module, exports) {
      // 20.1.2.5 Number.isSafeInteger(number)
      var $export = _dereq_(33);

      var isInteger = _dereq_(50);

      var abs = Math.abs;
      $export($export.S, 'Number', {
        isSafeInteger: function isSafeInteger(number) {
          return isInteger(number) && abs(number) <= 0x1fffffffffffff;
        }
      });
    }, {
      "33": 33,
      "50": 50
    }],
    184: [function (_dereq_, module, exports) {
      // 20.1.2.6 Number.MAX_SAFE_INTEGER
      var $export = _dereq_(33);

      $export($export.S, 'Number', {
        MAX_SAFE_INTEGER: 0x1fffffffffffff
      });
    }, {
      "33": 33
    }],
    185: [function (_dereq_, module, exports) {
      // 20.1.2.10 Number.MIN_SAFE_INTEGER
      var $export = _dereq_(33);

      $export($export.S, 'Number', {
        MIN_SAFE_INTEGER: -0x1fffffffffffff
      });
    }, {
      "33": 33
    }],
    186: [function (_dereq_, module, exports) {
      var $export = _dereq_(33);

      var $parseFloat = _dereq_(86); // 20.1.2.12 Number.parseFloat(string)


      $export($export.S + $export.F * (Number.parseFloat != $parseFloat), 'Number', {
        parseFloat: $parseFloat
      });
    }, {
      "33": 33,
      "86": 86
    }],
    187: [function (_dereq_, module, exports) {
      var $export = _dereq_(33);

      var $parseInt = _dereq_(87); // 20.1.2.13 Number.parseInt(string, radix)


      $export($export.S + $export.F * (Number.parseInt != $parseInt), 'Number', {
        parseInt: $parseInt
      });
    }, {
      "33": 33,
      "87": 87
    }],
    188: [function (_dereq_, module, exports) {

      var $export = _dereq_(33);

      var toInteger = _dereq_(116);

      var aNumberValue = _dereq_(4);

      var repeat = _dereq_(110);

      var $toFixed = 1.0.toFixed;
      var floor = Math.floor;
      var data = [0, 0, 0, 0, 0, 0];
      var ERROR = 'Number.toFixed: incorrect invocation!';
      var ZERO = '0';

      var multiply = function multiply(n, c) {
        var i = -1;
        var c2 = c;

        while (++i < 6) {
          c2 += n * data[i];
          data[i] = c2 % 1e7;
          c2 = floor(c2 / 1e7);
        }
      };

      var divide = function divide(n) {
        var i = 6;
        var c = 0;

        while (--i >= 0) {
          c += data[i];
          data[i] = floor(c / n);
          c = c % n * 1e7;
        }
      };

      var numToString = function numToString() {
        var i = 6;
        var s = '';

        while (--i >= 0) {
          if (s !== '' || i === 0 || data[i] !== 0) {
            var t = String(data[i]);
            s = s === '' ? t : s + repeat.call(ZERO, 7 - t.length) + t;
          }
        }

        return s;
      };

      var pow = function pow(x, n, acc) {
        return n === 0 ? acc : n % 2 === 1 ? pow(x, n - 1, acc * x) : pow(x * x, n / 2, acc);
      };

      var log = function log(x) {
        var n = 0;
        var x2 = x;

        while (x2 >= 4096) {
          n += 12;
          x2 /= 4096;
        }

        while (x2 >= 2) {
          n += 1;
          x2 /= 2;
        }

        return n;
      };

      $export($export.P + $export.F * (!!$toFixed && (0.00008.toFixed(3) !== '0.000' || 0.9.toFixed(0) !== '1' || 1.255.toFixed(2) !== '1.25' || 1000000000000000128.0.toFixed(0) !== '1000000000000000128') || !_dereq_(35)(function () {
        // V8 ~ Android 4.3-
        $toFixed.call({});
      })), 'Number', {
        toFixed: function toFixed(fractionDigits) {
          var x = aNumberValue(this, ERROR);
          var f = toInteger(fractionDigits);
          var s = '';
          var m = ZERO;
          var e, z, j, k;
          if (f < 0 || f > 20) throw RangeError(ERROR); // eslint-disable-next-line no-self-compare

          if (x != x) return 'NaN';
          if (x <= -1e21 || x >= 1e21) return String(x);

          if (x < 0) {
            s = '-';
            x = -x;
          }

          if (x > 1e-21) {
            e = log(x * pow(2, 69, 1)) - 69;
            z = e < 0 ? x * pow(2, -e, 1) : x / pow(2, e, 1);
            z *= 0x10000000000000;
            e = 52 - e;

            if (e > 0) {
              multiply(0, z);
              j = f;

              while (j >= 7) {
                multiply(1e7, 0);
                j -= 7;
              }

              multiply(pow(10, j, 1), 0);
              j = e - 1;

              while (j >= 23) {
                divide(1 << 23);
                j -= 23;
              }

              divide(1 << j);
              multiply(1, 1);
              divide(2);
              m = numToString();
            } else {
              multiply(0, z);
              multiply(1 << -e, 0);
              m = numToString() + repeat.call(ZERO, f);
            }
          }

          if (f > 0) {
            k = m.length;
            m = s + (k <= f ? '0.' + repeat.call(ZERO, f - k) + m : m.slice(0, k - f) + '.' + m.slice(k - f));
          } else {
            m = s + m;
          }

          return m;
        }
      });
    }, {
      "110": 110,
      "116": 116,
      "33": 33,
      "35": 35,
      "4": 4
    }],
    189: [function (_dereq_, module, exports) {

      var $export = _dereq_(33);

      var $fails = _dereq_(35);

      var aNumberValue = _dereq_(4);

      var $toPrecision = 1.0.toPrecision;
      $export($export.P + $export.F * ($fails(function () {
        // IE7-
        return $toPrecision.call(1, undefined) !== '1';
      }) || !$fails(function () {
        // V8 ~ Android 4.3-
        $toPrecision.call({});
      })), 'Number', {
        toPrecision: function toPrecision(precision) {
          var that = aNumberValue(this, 'Number#toPrecision: incorrect invocation!');
          return precision === undefined ? $toPrecision.call(that) : $toPrecision.call(that, precision);
        }
      });
    }, {
      "33": 33,
      "35": 35,
      "4": 4
    }],
    190: [function (_dereq_, module, exports) {
      // 19.1.3.1 Object.assign(target, source)
      var $export = _dereq_(33);

      $export($export.S + $export.F, 'Object', {
        assign: _dereq_(70)
      });
    }, {
      "33": 33,
      "70": 70
    }],
    191: [function (_dereq_, module, exports) {
      var $export = _dereq_(33); // 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])


      $export($export.S, 'Object', {
        create: _dereq_(71)
      });
    }, {
      "33": 33,
      "71": 71
    }],
    192: [function (_dereq_, module, exports) {
      var $export = _dereq_(33); // 19.1.2.3 / 15.2.3.7 Object.defineProperties(O, Properties)


      $export($export.S + $export.F * !_dereq_(29), 'Object', {
        defineProperties: _dereq_(73)
      });
    }, {
      "29": 29,
      "33": 33,
      "73": 73
    }],
    193: [function (_dereq_, module, exports) {
      var $export = _dereq_(33); // 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)


      $export($export.S + $export.F * !_dereq_(29), 'Object', {
        defineProperty: _dereq_(72).f
      });
    }, {
      "29": 29,
      "33": 33,
      "72": 72
    }],
    194: [function (_dereq_, module, exports) {
      // 19.1.2.5 Object.freeze(O)
      var isObject = _dereq_(51);

      var meta = _dereq_(66).onFreeze;

      _dereq_(83)('freeze', function ($freeze) {
        return function freeze(it) {
          return $freeze && isObject(it) ? $freeze(meta(it)) : it;
        };
      });
    }, {
      "51": 51,
      "66": 66,
      "83": 83
    }],
    195: [function (_dereq_, module, exports) {
      // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
      var toIObject = _dereq_(117);

      var $getOwnPropertyDescriptor = _dereq_(75).f;

      _dereq_(83)('getOwnPropertyDescriptor', function () {
        return function getOwnPropertyDescriptor(it, key) {
          return $getOwnPropertyDescriptor(toIObject(it), key);
        };
      });
    }, {
      "117": 117,
      "75": 75,
      "83": 83
    }],
    196: [function (_dereq_, module, exports) {
      // 19.1.2.7 Object.getOwnPropertyNames(O)
      _dereq_(83)('getOwnPropertyNames', function () {
        return _dereq_(76).f;
      });
    }, {
      "76": 76,
      "83": 83
    }],
    197: [function (_dereq_, module, exports) {
      // 19.1.2.9 Object.getPrototypeOf(O)
      var toObject = _dereq_(119);

      var $getPrototypeOf = _dereq_(79);

      _dereq_(83)('getPrototypeOf', function () {
        return function getPrototypeOf(it) {
          return $getPrototypeOf(toObject(it));
        };
      });
    }, {
      "119": 119,
      "79": 79,
      "83": 83
    }],
    198: [function (_dereq_, module, exports) {
      // 19.1.2.11 Object.isExtensible(O)
      var isObject = _dereq_(51);

      _dereq_(83)('isExtensible', function ($isExtensible) {
        return function isExtensible(it) {
          return isObject(it) ? $isExtensible ? $isExtensible(it) : true : false;
        };
      });
    }, {
      "51": 51,
      "83": 83
    }],
    199: [function (_dereq_, module, exports) {
      // 19.1.2.12 Object.isFrozen(O)
      var isObject = _dereq_(51);

      _dereq_(83)('isFrozen', function ($isFrozen) {
        return function isFrozen(it) {
          return isObject(it) ? $isFrozen ? $isFrozen(it) : false : true;
        };
      });
    }, {
      "51": 51,
      "83": 83
    }],
    200: [function (_dereq_, module, exports) {
      // 19.1.2.13 Object.isSealed(O)
      var isObject = _dereq_(51);

      _dereq_(83)('isSealed', function ($isSealed) {
        return function isSealed(it) {
          return isObject(it) ? $isSealed ? $isSealed(it) : false : true;
        };
      });
    }, {
      "51": 51,
      "83": 83
    }],
    201: [function (_dereq_, module, exports) {
      // 19.1.3.10 Object.is(value1, value2)
      var $export = _dereq_(33);

      $export($export.S, 'Object', {
        is: _dereq_(96)
      });
    }, {
      "33": 33,
      "96": 96
    }],
    202: [function (_dereq_, module, exports) {
      // 19.1.2.14 Object.keys(O)
      var toObject = _dereq_(119);

      var $keys = _dereq_(81);

      _dereq_(83)('keys', function () {
        return function keys(it) {
          return $keys(toObject(it));
        };
      });
    }, {
      "119": 119,
      "81": 81,
      "83": 83
    }],
    203: [function (_dereq_, module, exports) {
      // 19.1.2.15 Object.preventExtensions(O)
      var isObject = _dereq_(51);

      var meta = _dereq_(66).onFreeze;

      _dereq_(83)('preventExtensions', function ($preventExtensions) {
        return function preventExtensions(it) {
          return $preventExtensions && isObject(it) ? $preventExtensions(meta(it)) : it;
        };
      });
    }, {
      "51": 51,
      "66": 66,
      "83": 83
    }],
    204: [function (_dereq_, module, exports) {
      // 19.1.2.17 Object.seal(O)
      var isObject = _dereq_(51);

      var meta = _dereq_(66).onFreeze;

      _dereq_(83)('seal', function ($seal) {
        return function seal(it) {
          return $seal && isObject(it) ? $seal(meta(it)) : it;
        };
      });
    }, {
      "51": 51,
      "66": 66,
      "83": 83
    }],
    205: [function (_dereq_, module, exports) {
      // 19.1.3.19 Object.setPrototypeOf(O, proto)
      var $export = _dereq_(33);

      $export($export.S, 'Object', {
        setPrototypeOf: _dereq_(99).set
      });
    }, {
      "33": 33,
      "99": 99
    }],
    206: [function (_dereq_, module, exports) {

      var classof = _dereq_(17);

      var test = {};
      test[_dereq_(128)('toStringTag')] = 'z';

      if (test + '' != '[object z]') {
        _dereq_(94)(Object.prototype, 'toString', function toString() {
          return '[object ' + classof(this) + ']';
        }, true);
      }
    }, {
      "128": 128,
      "17": 17,
      "94": 94
    }],
    207: [function (_dereq_, module, exports) {
      var $export = _dereq_(33);

      var $parseFloat = _dereq_(86); // 18.2.4 parseFloat(string)


      $export($export.G + $export.F * (parseFloat != $parseFloat), {
        parseFloat: $parseFloat
      });
    }, {
      "33": 33,
      "86": 86
    }],
    208: [function (_dereq_, module, exports) {
      var $export = _dereq_(33);

      var $parseInt = _dereq_(87); // 18.2.5 parseInt(string, radix)


      $export($export.G + $export.F * (parseInt != $parseInt), {
        parseInt: $parseInt
      });
    }, {
      "33": 33,
      "87": 87
    }],
    209: [function (_dereq_, module, exports) {

      var LIBRARY = _dereq_(60);

      var global = _dereq_(40);

      var ctx = _dereq_(25);

      var classof = _dereq_(17);

      var $export = _dereq_(33);

      var isObject = _dereq_(51);

      var aFunction = _dereq_(3);

      var anInstance = _dereq_(6);

      var forOf = _dereq_(39);

      var speciesConstructor = _dereq_(104);

      var task = _dereq_(113).set;

      var microtask = _dereq_(68)();

      var newPromiseCapabilityModule = _dereq_(69);

      var perform = _dereq_(90);

      var promiseResolve = _dereq_(91);

      var PROMISE = 'Promise';
      var TypeError = global.TypeError;
      var process = global.process;
      var $Promise = global[PROMISE];
      var isNode = classof(process) == 'process';

      var empty = function empty() {
        /* empty */
      };

      var Internal, newGenericPromiseCapability, OwnPromiseCapability, Wrapper;
      var newPromiseCapability = newGenericPromiseCapability = newPromiseCapabilityModule.f;
      var USE_NATIVE = !!function () {
        try {
          // correct subclassing with @@species support
          var promise = $Promise.resolve(1);

          var FakePromise = (promise.constructor = {})[_dereq_(128)('species')] = function (exec) {
            exec(empty, empty);
          }; // unhandled rejections tracking support, NodeJS Promise without it fails @@species test


          return (isNode || typeof PromiseRejectionEvent == 'function') && promise.then(empty) instanceof FakePromise;
        } catch (e) {
          /* empty */
        }
      }(); // helpers

      var sameConstructor = LIBRARY ? function (a, b) {
        // with library wrapper special case
        return a === b || a === $Promise && b === Wrapper;
      } : function (a, b) {
        return a === b;
      };

      var isThenable = function isThenable(it) {
        var then;
        return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
      };

      var notify = function notify(promise, isReject) {
        if (promise._n) return;
        promise._n = true;
        var chain = promise._c;
        microtask(function () {
          var value = promise._v;
          var ok = promise._s == 1;
          var i = 0;

          var run = function run(reaction) {
            var handler = ok ? reaction.ok : reaction.fail;
            var resolve = reaction.resolve;
            var reject = reaction.reject;
            var domain = reaction.domain;
            var result, then;

            try {
              if (handler) {
                if (!ok) {
                  if (promise._h == 2) onHandleUnhandled(promise);
                  promise._h = 1;
                }

                if (handler === true) result = value;else {
                  if (domain) domain.enter();
                  result = handler(value);
                  if (domain) domain.exit();
                }

                if (result === reaction.promise) {
                  reject(TypeError('Promise-chain cycle'));
                } else if (then = isThenable(result)) {
                  then.call(result, resolve, reject);
                } else resolve(result);
              } else reject(value);
            } catch (e) {
              reject(e);
            }
          };

          while (chain.length > i) {
            run(chain[i++]);
          } // variable length - can't use forEach


          promise._c = [];
          promise._n = false;
          if (isReject && !promise._h) onUnhandled(promise);
        });
      };

      var onUnhandled = function onUnhandled(promise) {
        task.call(global, function () {
          var value = promise._v;
          var unhandled = isUnhandled(promise);
          var result, handler, console;

          if (unhandled) {
            result = perform(function () {
              if (isNode) {
                process.emit('unhandledRejection', value, promise);
              } else if (handler = global.onunhandledrejection) {
                handler({
                  promise: promise,
                  reason: value
                });
              } else if ((console = global.console) && console.error) {
                console.error('Unhandled promise rejection', value);
              }
            }); // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should

            promise._h = isNode || isUnhandled(promise) ? 2 : 1;
          }

          promise._a = undefined;
          if (unhandled && result.e) throw result.v;
        });
      };

      var isUnhandled = function isUnhandled(promise) {
        if (promise._h == 1) return false;
        var chain = promise._a || promise._c;
        var i = 0;
        var reaction;

        while (chain.length > i) {
          reaction = chain[i++];
          if (reaction.fail || !isUnhandled(reaction.promise)) return false;
        }

        return true;
      };

      var onHandleUnhandled = function onHandleUnhandled(promise) {
        task.call(global, function () {
          var handler;

          if (isNode) {
            process.emit('rejectionHandled', promise);
          } else if (handler = global.onrejectionhandled) {
            handler({
              promise: promise,
              reason: promise._v
            });
          }
        });
      };

      var $reject = function $reject(value) {
        var promise = this;
        if (promise._d) return;
        promise._d = true;
        promise = promise._w || promise; // unwrap

        promise._v = value;
        promise._s = 2;
        if (!promise._a) promise._a = promise._c.slice();
        notify(promise, true);
      };

      var $resolve = function $resolve(value) {
        var promise = this;
        var then;
        if (promise._d) return;
        promise._d = true;
        promise = promise._w || promise; // unwrap

        try {
          if (promise === value) throw TypeError("Promise can't be resolved itself");

          if (then = isThenable(value)) {
            microtask(function () {
              var wrapper = {
                _w: promise,
                _d: false
              }; // wrap

              try {
                then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));
              } catch (e) {
                $reject.call(wrapper, e);
              }
            });
          } else {
            promise._v = value;
            promise._s = 1;
            notify(promise, false);
          }
        } catch (e) {
          $reject.call({
            _w: promise,
            _d: false
          }, e); // wrap
        }
      }; // constructor polyfill


      if (!USE_NATIVE) {
        // 25.4.3.1 Promise(executor)
        $Promise = function Promise(executor) {
          anInstance(this, $Promise, PROMISE, '_h');
          aFunction(executor);
          Internal.call(this);

          try {
            executor(ctx($resolve, this, 1), ctx($reject, this, 1));
          } catch (err) {
            $reject.call(this, err);
          }
        }; // eslint-disable-next-line no-unused-vars


        Internal = function Promise(executor) {
          this._c = []; // <- awaiting reactions

          this._a = undefined; // <- checked in isUnhandled reactions

          this._s = 0; // <- state

          this._d = false; // <- done

          this._v = undefined; // <- value

          this._h = 0; // <- rejection state, 0 - default, 1 - handled, 2 - unhandled

          this._n = false; // <- notify
        };

        Internal.prototype = _dereq_(93)($Promise.prototype, {
          // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
          then: function then(onFulfilled, onRejected) {
            var reaction = newPromiseCapability(speciesConstructor(this, $Promise));
            reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;
            reaction.fail = typeof onRejected == 'function' && onRejected;
            reaction.domain = isNode ? process.domain : undefined;

            this._c.push(reaction);

            if (this._a) this._a.push(reaction);
            if (this._s) notify(this, false);
            return reaction.promise;
          },
          // 25.4.5.1 Promise.prototype.catch(onRejected)
          'catch': function _catch(onRejected) {
            return this.then(undefined, onRejected);
          }
        });

        OwnPromiseCapability = function OwnPromiseCapability() {
          var promise = new Internal();
          this.promise = promise;
          this.resolve = ctx($resolve, promise, 1);
          this.reject = ctx($reject, promise, 1);
        };

        newPromiseCapabilityModule.f = newPromiseCapability = function newPromiseCapability(C) {
          return sameConstructor($Promise, C) ? new OwnPromiseCapability(C) : newGenericPromiseCapability(C);
        };
      }

      $export($export.G + $export.W + $export.F * !USE_NATIVE, {
        Promise: $Promise
      });

      _dereq_(101)($Promise, PROMISE);

      _dereq_(100)(PROMISE);

      Wrapper = _dereq_(23)[PROMISE]; // statics

      $export($export.S + $export.F * !USE_NATIVE, PROMISE, {
        // 25.4.4.5 Promise.reject(r)
        reject: function reject(r) {
          var capability = newPromiseCapability(this);
          var $$reject = capability.reject;
          $$reject(r);
          return capability.promise;
        }
      });
      $export($export.S + $export.F * (LIBRARY || !USE_NATIVE), PROMISE, {
        // 25.4.4.6 Promise.resolve(x)
        resolve: function resolve(x) {
          // instanceof instead of internal slot check because we should fix it without replacement native Promise core
          if (x instanceof $Promise && sameConstructor(x.constructor, this)) return x;
          return promiseResolve(this, x);
        }
      });
      $export($export.S + $export.F * !(USE_NATIVE && _dereq_(56)(function (iter) {
        $Promise.all(iter)['catch'](empty);
      })), PROMISE, {
        // 25.4.4.1 Promise.all(iterable)
        all: function all(iterable) {
          var C = this;
          var capability = newPromiseCapability(C);
          var resolve = capability.resolve;
          var reject = capability.reject;
          var result = perform(function () {
            var values = [];
            var index = 0;
            var remaining = 1;
            forOf(iterable, false, function (promise) {
              var $index = index++;
              var alreadyCalled = false;
              values.push(undefined);
              remaining++;
              C.resolve(promise).then(function (value) {
                if (alreadyCalled) return;
                alreadyCalled = true;
                values[$index] = value;
                --remaining || resolve(values);
              }, reject);
            });
            --remaining || resolve(values);
          });
          if (result.e) reject(result.v);
          return capability.promise;
        },
        // 25.4.4.4 Promise.race(iterable)
        race: function race(iterable) {
          var C = this;
          var capability = newPromiseCapability(C);
          var reject = capability.reject;
          var result = perform(function () {
            forOf(iterable, false, function (promise) {
              C.resolve(promise).then(capability.resolve, reject);
            });
          });
          if (result.e) reject(result.v);
          return capability.promise;
        }
      });
    }, {
      "100": 100,
      "101": 101,
      "104": 104,
      "113": 113,
      "128": 128,
      "17": 17,
      "23": 23,
      "25": 25,
      "3": 3,
      "33": 33,
      "39": 39,
      "40": 40,
      "51": 51,
      "56": 56,
      "6": 6,
      "60": 60,
      "68": 68,
      "69": 69,
      "90": 90,
      "91": 91,
      "93": 93
    }],
    210: [function (_dereq_, module, exports) {
      // 26.1.1 Reflect.apply(target, thisArgument, argumentsList)
      var $export = _dereq_(33);

      var aFunction = _dereq_(3);

      var anObject = _dereq_(7);

      var rApply = (_dereq_(40).Reflect || {}).apply;
      var fApply = Function.apply; // MS Edge argumentsList argument is optional

      $export($export.S + $export.F * !_dereq_(35)(function () {
        rApply(function () {
          /* empty */
        });
      }), 'Reflect', {
        apply: function apply(target, thisArgument, argumentsList) {
          var T = aFunction(target);
          var L = anObject(argumentsList);
          return rApply ? rApply(T, thisArgument, L) : fApply.call(T, thisArgument, L);
        }
      });
    }, {
      "3": 3,
      "33": 33,
      "35": 35,
      "40": 40,
      "7": 7
    }],
    211: [function (_dereq_, module, exports) {
      // 26.1.2 Reflect.construct(target, argumentsList [, newTarget])
      var $export = _dereq_(33);

      var create = _dereq_(71);

      var aFunction = _dereq_(3);

      var anObject = _dereq_(7);

      var isObject = _dereq_(51);

      var fails = _dereq_(35);

      var bind = _dereq_(16);

      var rConstruct = (_dereq_(40).Reflect || {}).construct; // MS Edge supports only 2 arguments and argumentsList argument is optional
      // FF Nightly sets third argument as `new.target`, but does not create `this` from it

      var NEW_TARGET_BUG = fails(function () {
        function F() {
          /* empty */
        }

        return !(rConstruct(function () {
          /* empty */
        }, [], F) instanceof F);
      });
      var ARGS_BUG = !fails(function () {
        rConstruct(function () {
          /* empty */
        });
      });
      $export($export.S + $export.F * (NEW_TARGET_BUG || ARGS_BUG), 'Reflect', {
        construct: function construct(Target, args
        /* , newTarget */
        ) {
          aFunction(Target);
          anObject(args);
          var newTarget = arguments.length < 3 ? Target : aFunction(arguments[2]);
          if (ARGS_BUG && !NEW_TARGET_BUG) return rConstruct(Target, args, newTarget);

          if (Target == newTarget) {
            // w/o altered newTarget, optimization for 0-4 arguments
            switch (args.length) {
              case 0:
                return new Target();

              case 1:
                return new Target(args[0]);

              case 2:
                return new Target(args[0], args[1]);

              case 3:
                return new Target(args[0], args[1], args[2]);

              case 4:
                return new Target(args[0], args[1], args[2], args[3]);
            } // w/o altered newTarget, lot of arguments case


            var $args = [null];
            $args.push.apply($args, args);
            return new (bind.apply(Target, $args))();
          } // with altered newTarget, not support built-in constructors


          var proto = newTarget.prototype;
          var instance = create(isObject(proto) ? proto : Object.prototype);
          var result = Function.apply.call(Target, instance, args);
          return isObject(result) ? result : instance;
        }
      });
    }, {
      "16": 16,
      "3": 3,
      "33": 33,
      "35": 35,
      "40": 40,
      "51": 51,
      "7": 7,
      "71": 71
    }],
    212: [function (_dereq_, module, exports) {
      // 26.1.3 Reflect.defineProperty(target, propertyKey, attributes)
      var dP = _dereq_(72);

      var $export = _dereq_(33);

      var anObject = _dereq_(7);

      var toPrimitive = _dereq_(120); // MS Edge has broken Reflect.defineProperty - throwing instead of returning false


      $export($export.S + $export.F * _dereq_(35)(function () {
        // eslint-disable-next-line no-undef
        Reflect.defineProperty(dP.f({}, 1, {
          value: 1
        }), 1, {
          value: 2
        });
      }), 'Reflect', {
        defineProperty: function defineProperty(target, propertyKey, attributes) {
          anObject(target);
          propertyKey = toPrimitive(propertyKey, true);
          anObject(attributes);

          try {
            dP.f(target, propertyKey, attributes);
            return true;
          } catch (e) {
            return false;
          }
        }
      });
    }, {
      "120": 120,
      "33": 33,
      "35": 35,
      "7": 7,
      "72": 72
    }],
    213: [function (_dereq_, module, exports) {
      // 26.1.4 Reflect.deleteProperty(target, propertyKey)
      var $export = _dereq_(33);

      var gOPD = _dereq_(75).f;

      var anObject = _dereq_(7);

      $export($export.S, 'Reflect', {
        deleteProperty: function deleteProperty(target, propertyKey) {
          var desc = gOPD(anObject(target), propertyKey);
          return desc && !desc.configurable ? false : delete target[propertyKey];
        }
      });
    }, {
      "33": 33,
      "7": 7,
      "75": 75
    }],
    214: [function (_dereq_, module, exports) {

      var $export = _dereq_(33);

      var anObject = _dereq_(7);

      var Enumerate = function Enumerate(iterated) {
        this._t = anObject(iterated); // target

        this._i = 0; // next index

        var keys = this._k = []; // keys

        var key;

        for (key in iterated) {
          keys.push(key);
        }
      };

      _dereq_(54)(Enumerate, 'Object', function () {
        var that = this;
        var keys = that._k;
        var key;

        do {
          if (that._i >= keys.length) return {
            value: undefined,
            done: true
          };
        } while (!((key = keys[that._i++]) in that._t));

        return {
          value: key,
          done: false
        };
      });

      $export($export.S, 'Reflect', {
        enumerate: function enumerate(target) {
          return new Enumerate(target);
        }
      });
    }, {
      "33": 33,
      "54": 54,
      "7": 7
    }],
    215: [function (_dereq_, module, exports) {
      // 26.1.7 Reflect.getOwnPropertyDescriptor(target, propertyKey)
      var gOPD = _dereq_(75);

      var $export = _dereq_(33);

      var anObject = _dereq_(7);

      $export($export.S, 'Reflect', {
        getOwnPropertyDescriptor: function getOwnPropertyDescriptor(target, propertyKey) {
          return gOPD.f(anObject(target), propertyKey);
        }
      });
    }, {
      "33": 33,
      "7": 7,
      "75": 75
    }],
    216: [function (_dereq_, module, exports) {
      // 26.1.8 Reflect.getPrototypeOf(target)
      var $export = _dereq_(33);

      var getProto = _dereq_(79);

      var anObject = _dereq_(7);

      $export($export.S, 'Reflect', {
        getPrototypeOf: function getPrototypeOf(target) {
          return getProto(anObject(target));
        }
      });
    }, {
      "33": 33,
      "7": 7,
      "79": 79
    }],
    217: [function (_dereq_, module, exports) {
      // 26.1.6 Reflect.get(target, propertyKey [, receiver])
      var gOPD = _dereq_(75);

      var getPrototypeOf = _dereq_(79);

      var has = _dereq_(41);

      var $export = _dereq_(33);

      var isObject = _dereq_(51);

      var anObject = _dereq_(7);

      function get(target, propertyKey
      /* , receiver */
      ) {
        var receiver = arguments.length < 3 ? target : arguments[2];
        var desc, proto;
        if (anObject(target) === receiver) return target[propertyKey];
        if (desc = gOPD.f(target, propertyKey)) return has(desc, 'value') ? desc.value : desc.get !== undefined ? desc.get.call(receiver) : undefined;
        if (isObject(proto = getPrototypeOf(target))) return get(proto, propertyKey, receiver);
      }

      $export($export.S, 'Reflect', {
        get: get
      });
    }, {
      "33": 33,
      "41": 41,
      "51": 51,
      "7": 7,
      "75": 75,
      "79": 79
    }],
    218: [function (_dereq_, module, exports) {
      // 26.1.9 Reflect.has(target, propertyKey)
      var $export = _dereq_(33);

      $export($export.S, 'Reflect', {
        has: function has(target, propertyKey) {
          return propertyKey in target;
        }
      });
    }, {
      "33": 33
    }],
    219: [function (_dereq_, module, exports) {
      // 26.1.10 Reflect.isExtensible(target)
      var $export = _dereq_(33);

      var anObject = _dereq_(7);

      var $isExtensible = Object.isExtensible;
      $export($export.S, 'Reflect', {
        isExtensible: function isExtensible(target) {
          anObject(target);
          return $isExtensible ? $isExtensible(target) : true;
        }
      });
    }, {
      "33": 33,
      "7": 7
    }],
    220: [function (_dereq_, module, exports) {
      // 26.1.11 Reflect.ownKeys(target)
      var $export = _dereq_(33);

      $export($export.S, 'Reflect', {
        ownKeys: _dereq_(85)
      });
    }, {
      "33": 33,
      "85": 85
    }],
    221: [function (_dereq_, module, exports) {
      // 26.1.12 Reflect.preventExtensions(target)
      var $export = _dereq_(33);

      var anObject = _dereq_(7);

      var $preventExtensions = Object.preventExtensions;
      $export($export.S, 'Reflect', {
        preventExtensions: function preventExtensions(target) {
          anObject(target);

          try {
            if ($preventExtensions) $preventExtensions(target);
            return true;
          } catch (e) {
            return false;
          }
        }
      });
    }, {
      "33": 33,
      "7": 7
    }],
    222: [function (_dereq_, module, exports) {
      // 26.1.14 Reflect.setPrototypeOf(target, proto)
      var $export = _dereq_(33);

      var setProto = _dereq_(99);

      if (setProto) $export($export.S, 'Reflect', {
        setPrototypeOf: function setPrototypeOf(target, proto) {
          setProto.check(target, proto);

          try {
            setProto.set(target, proto);
            return true;
          } catch (e) {
            return false;
          }
        }
      });
    }, {
      "33": 33,
      "99": 99
    }],
    223: [function (_dereq_, module, exports) {
      // 26.1.13 Reflect.set(target, propertyKey, V [, receiver])
      var dP = _dereq_(72);

      var gOPD = _dereq_(75);

      var getPrototypeOf = _dereq_(79);

      var has = _dereq_(41);

      var $export = _dereq_(33);

      var createDesc = _dereq_(92);

      var anObject = _dereq_(7);

      var isObject = _dereq_(51);

      function set(target, propertyKey, V
      /* , receiver */
      ) {
        var receiver = arguments.length < 4 ? target : arguments[3];
        var ownDesc = gOPD.f(anObject(target), propertyKey);
        var existingDescriptor, proto;

        if (!ownDesc) {
          if (isObject(proto = getPrototypeOf(target))) {
            return set(proto, propertyKey, V, receiver);
          }

          ownDesc = createDesc(0);
        }

        if (has(ownDesc, 'value')) {
          if (ownDesc.writable === false || !isObject(receiver)) return false;
          existingDescriptor = gOPD.f(receiver, propertyKey) || createDesc(0);
          existingDescriptor.value = V;
          dP.f(receiver, propertyKey, existingDescriptor);
          return true;
        }

        return ownDesc.set === undefined ? false : (ownDesc.set.call(receiver, V), true);
      }

      $export($export.S, 'Reflect', {
        set: set
      });
    }, {
      "33": 33,
      "41": 41,
      "51": 51,
      "7": 7,
      "72": 72,
      "75": 75,
      "79": 79,
      "92": 92
    }],
    224: [function (_dereq_, module, exports) {
      var global = _dereq_(40);

      var inheritIfRequired = _dereq_(45);

      var dP = _dereq_(72).f;

      var gOPN = _dereq_(77).f;

      var isRegExp = _dereq_(52);

      var $flags = _dereq_(37);

      var $RegExp = global.RegExp;
      var Base = $RegExp;
      var proto = $RegExp.prototype;
      var re1 = /a/g;
      var re2 = /a/g; // "new" creates a new object, old webkit buggy here

      var CORRECT_NEW = new $RegExp(re1) !== re1;

      if (_dereq_(29) && (!CORRECT_NEW || _dereq_(35)(function () {
        re2[_dereq_(128)('match')] = false; // RegExp constructor can alter flags and IsRegExp works correct with @@match

        return $RegExp(re1) != re1 || $RegExp(re2) == re2 || $RegExp(re1, 'i') != '/a/i';
      }))) {
        $RegExp = function RegExp(p, f) {
          var tiRE = this instanceof $RegExp;
          var piRE = isRegExp(p);
          var fiU = f === undefined;
          return !tiRE && piRE && p.constructor === $RegExp && fiU ? p : inheritIfRequired(CORRECT_NEW ? new Base(piRE && !fiU ? p.source : p, f) : Base((piRE = p instanceof $RegExp) ? p.source : p, piRE && fiU ? $flags.call(p) : f), tiRE ? this : proto, $RegExp);
        };

        var proxy = function proxy(key) {
          key in $RegExp || dP($RegExp, key, {
            configurable: true,
            get: function get() {
              return Base[key];
            },
            set: function set(it) {
              Base[key] = it;
            }
          });
        };

        for (var keys = gOPN(Base), i = 0; keys.length > i;) {
          proxy(keys[i++]);
        }

        proto.constructor = $RegExp;
        $RegExp.prototype = proto;

        _dereq_(94)(global, 'RegExp', $RegExp);
      }

      _dereq_(100)('RegExp');
    }, {
      "100": 100,
      "128": 128,
      "29": 29,
      "35": 35,
      "37": 37,
      "40": 40,
      "45": 45,
      "52": 52,
      "72": 72,
      "77": 77,
      "94": 94
    }],
    225: [function (_dereq_, module, exports) {
      // 21.2.5.3 get RegExp.prototype.flags()
      if (_dereq_(29) && /./g.flags != 'g') _dereq_(72).f(RegExp.prototype, 'flags', {
        configurable: true,
        get: _dereq_(37)
      });
    }, {
      "29": 29,
      "37": 37,
      "72": 72
    }],
    226: [function (_dereq_, module, exports) {
      // @@match logic
      _dereq_(36)('match', 1, function (defined, MATCH, $match) {
        // 21.1.3.11 String.prototype.match(regexp)
        return [function match(regexp) {

          var O = defined(this);
          var fn = regexp == undefined ? undefined : regexp[MATCH];
          return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[MATCH](String(O));
        }, $match];
      });
    }, {
      "36": 36
    }],
    227: [function (_dereq_, module, exports) {
      // @@replace logic
      _dereq_(36)('replace', 2, function (defined, REPLACE, $replace) {
        // 21.1.3.14 String.prototype.replace(searchValue, replaceValue)
        return [function replace(searchValue, replaceValue) {

          var O = defined(this);
          var fn = searchValue == undefined ? undefined : searchValue[REPLACE];
          return fn !== undefined ? fn.call(searchValue, O, replaceValue) : $replace.call(String(O), searchValue, replaceValue);
        }, $replace];
      });
    }, {
      "36": 36
    }],
    228: [function (_dereq_, module, exports) {
      // @@search logic
      _dereq_(36)('search', 1, function (defined, SEARCH, $search) {
        // 21.1.3.15 String.prototype.search(regexp)
        return [function search(regexp) {

          var O = defined(this);
          var fn = regexp == undefined ? undefined : regexp[SEARCH];
          return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[SEARCH](String(O));
        }, $search];
      });
    }, {
      "36": 36
    }],
    229: [function (_dereq_, module, exports) {
      // @@split logic
      _dereq_(36)('split', 2, function (defined, SPLIT, $split) {

        var isRegExp = _dereq_(52);

        var _split = $split;
        var $push = [].push;
        var $SPLIT = 'split';
        var LENGTH = 'length';
        var LAST_INDEX = 'lastIndex';

        if ('abbc'[$SPLIT](/(b)*/)[1] == 'c' || 'test'[$SPLIT](/(?:)/, -1)[LENGTH] != 4 || 'ab'[$SPLIT](/(?:ab)*/)[LENGTH] != 2 || '.'[$SPLIT](/(.?)(.?)/)[LENGTH] != 4 || '.'[$SPLIT](/()()/)[LENGTH] > 1 || ''[$SPLIT](/.?/)[LENGTH]) {
          var NPCG = /()??/.exec('')[1] === undefined; // nonparticipating capturing group
          // based on es5-shim implementation, need to rework it

          $split = function $split(separator, limit) {
            var string = String(this);
            if (separator === undefined && limit === 0) return []; // If `separator` is not a regex, use native split

            if (!isRegExp(separator)) return _split.call(string, separator, limit);
            var output = [];
            var flags = (separator.ignoreCase ? 'i' : '') + (separator.multiline ? 'm' : '') + (separator.unicode ? 'u' : '') + (separator.sticky ? 'y' : '');
            var lastLastIndex = 0;
            var splitLimit = limit === undefined ? 4294967295 : limit >>> 0; // Make `global` and avoid `lastIndex` issues by working with a copy

            var separatorCopy = new RegExp(separator.source, flags + 'g');
            var separator2, match, lastIndex, lastLength, i; // Doesn't need flags gy, but they don't hurt

            if (!NPCG) separator2 = new RegExp('^' + separatorCopy.source + '$(?!\\s)', flags);

            while (match = separatorCopy.exec(string)) {
              // `separatorCopy.lastIndex` is not reliable cross-browser
              lastIndex = match.index + match[0][LENGTH];

              if (lastIndex > lastLastIndex) {
                output.push(string.slice(lastLastIndex, match.index)); // Fix browsers whose `exec` methods don't consistently return `undefined` for NPCG
                // eslint-disable-next-line no-loop-func

                if (!NPCG && match[LENGTH] > 1) match[0].replace(separator2, function () {
                  for (i = 1; i < arguments[LENGTH] - 2; i++) {
                    if (arguments[i] === undefined) match[i] = undefined;
                  }
                });
                if (match[LENGTH] > 1 && match.index < string[LENGTH]) $push.apply(output, match.slice(1));
                lastLength = match[0][LENGTH];
                lastLastIndex = lastIndex;
                if (output[LENGTH] >= splitLimit) break;
              }

              if (separatorCopy[LAST_INDEX] === match.index) separatorCopy[LAST_INDEX]++; // Avoid an infinite loop
            }

            if (lastLastIndex === string[LENGTH]) {
              if (lastLength || !separatorCopy.test('')) output.push('');
            } else output.push(string.slice(lastLastIndex));

            return output[LENGTH] > splitLimit ? output.slice(0, splitLimit) : output;
          }; // Chakra, V8

        } else if ('0'[$SPLIT](undefined, 0)[LENGTH]) {
          $split = function $split(separator, limit) {
            return separator === undefined && limit === 0 ? [] : _split.call(this, separator, limit);
          };
        } // 21.1.3.17 String.prototype.split(separator, limit)


        return [function split(separator, limit) {
          var O = defined(this);
          var fn = separator == undefined ? undefined : separator[SPLIT];
          return fn !== undefined ? fn.call(separator, O, limit) : $split.call(String(O), separator, limit);
        }, $split];
      });
    }, {
      "36": 36,
      "52": 52
    }],
    230: [function (_dereq_, module, exports) {

      _dereq_(225);

      var anObject = _dereq_(7);

      var $flags = _dereq_(37);

      var DESCRIPTORS = _dereq_(29);

      var TO_STRING = 'toString';
      var $toString = /./[TO_STRING];

      var define = function define(fn) {
        _dereq_(94)(RegExp.prototype, TO_STRING, fn, true);
      }; // 21.2.5.14 RegExp.prototype.toString()


      if (_dereq_(35)(function () {
        return $toString.call({
          source: 'a',
          flags: 'b'
        }) != '/a/b';
      })) {
        define(function toString() {
          var R = anObject(this);
          return '/'.concat(R.source, '/', 'flags' in R ? R.flags : !DESCRIPTORS && R instanceof RegExp ? $flags.call(R) : undefined);
        }); // FF44- RegExp#toString has a wrong name
      } else if ($toString.name != TO_STRING) {
        define(function toString() {
          return $toString.call(this);
        });
      }
    }, {
      "225": 225,
      "29": 29,
      "35": 35,
      "37": 37,
      "7": 7,
      "94": 94
    }],
    231: [function (_dereq_, module, exports) {

      var strong = _dereq_(19);

      var validate = _dereq_(125);

      var SET = 'Set'; // 23.2 Set Objects

      module.exports = _dereq_(22)(SET, function (get) {
        return function Set() {
          return get(this, arguments.length > 0 ? arguments[0] : undefined);
        };
      }, {
        // 23.2.3.1 Set.prototype.add(value)
        add: function add(value) {
          return strong.def(validate(this, SET), value = value === 0 ? 0 : value, value);
        }
      }, strong);
    }, {
      "125": 125,
      "19": 19,
      "22": 22
    }],
    232: [function (_dereq_, module, exports) {

      _dereq_(108)('anchor', function (createHTML) {
        return function anchor(name) {
          return createHTML(this, 'a', 'name', name);
        };
      });
    }, {
      "108": 108
    }],
    233: [function (_dereq_, module, exports) {

      _dereq_(108)('big', function (createHTML) {
        return function big() {
          return createHTML(this, 'big', '', '');
        };
      });
    }, {
      "108": 108
    }],
    234: [function (_dereq_, module, exports) {

      _dereq_(108)('blink', function (createHTML) {
        return function blink() {
          return createHTML(this, 'blink', '', '');
        };
      });
    }, {
      "108": 108
    }],
    235: [function (_dereq_, module, exports) {

      _dereq_(108)('bold', function (createHTML) {
        return function bold() {
          return createHTML(this, 'b', '', '');
        };
      });
    }, {
      "108": 108
    }],
    236: [function (_dereq_, module, exports) {

      var $export = _dereq_(33);

      var $at = _dereq_(106)(false);

      $export($export.P, 'String', {
        // 21.1.3.3 String.prototype.codePointAt(pos)
        codePointAt: function codePointAt(pos) {
          return $at(this, pos);
        }
      });
    }, {
      "106": 106,
      "33": 33
    }],
    237: [function (_dereq_, module, exports) {

      var $export = _dereq_(33);

      var toLength = _dereq_(118);

      var context = _dereq_(107);

      var ENDS_WITH = 'endsWith';
      var $endsWith = ''[ENDS_WITH];
      $export($export.P + $export.F * _dereq_(34)(ENDS_WITH), 'String', {
        endsWith: function endsWith(searchString
        /* , endPosition = @length */
        ) {
          var that = context(this, searchString, ENDS_WITH);
          var endPosition = arguments.length > 1 ? arguments[1] : undefined;
          var len = toLength(that.length);
          var end = endPosition === undefined ? len : Math.min(toLength(endPosition), len);
          var search = String(searchString);
          return $endsWith ? $endsWith.call(that, search, end) : that.slice(end - search.length, end) === search;
        }
      });
    }, {
      "107": 107,
      "118": 118,
      "33": 33,
      "34": 34
    }],
    238: [function (_dereq_, module, exports) {

      _dereq_(108)('fixed', function (createHTML) {
        return function fixed() {
          return createHTML(this, 'tt', '', '');
        };
      });
    }, {
      "108": 108
    }],
    239: [function (_dereq_, module, exports) {

      _dereq_(108)('fontcolor', function (createHTML) {
        return function fontcolor(color) {
          return createHTML(this, 'font', 'color', color);
        };
      });
    }, {
      "108": 108
    }],
    240: [function (_dereq_, module, exports) {

      _dereq_(108)('fontsize', function (createHTML) {
        return function fontsize(size) {
          return createHTML(this, 'font', 'size', size);
        };
      });
    }, {
      "108": 108
    }],
    241: [function (_dereq_, module, exports) {
      var $export = _dereq_(33);

      var toAbsoluteIndex = _dereq_(114);

      var fromCharCode = String.fromCharCode;
      var $fromCodePoint = String.fromCodePoint; // length should be 1, old FF problem

      $export($export.S + $export.F * (!!$fromCodePoint && $fromCodePoint.length != 1), 'String', {
        // 21.1.2.2 String.fromCodePoint(...codePoints)
        fromCodePoint: function fromCodePoint(x) {
          // eslint-disable-line no-unused-vars
          var res = [];
          var aLen = arguments.length;
          var i = 0;
          var code;

          while (aLen > i) {
            code = +arguments[i++];
            if (toAbsoluteIndex(code, 0x10ffff) !== code) throw RangeError(code + ' is not a valid code point');
            res.push(code < 0x10000 ? fromCharCode(code) : fromCharCode(((code -= 0x10000) >> 10) + 0xd800, code % 0x400 + 0xdc00));
          }

          return res.join('');
        }
      });
    }, {
      "114": 114,
      "33": 33
    }],
    242: [function (_dereq_, module, exports) {

      var $export = _dereq_(33);

      var context = _dereq_(107);

      var INCLUDES = 'includes';
      $export($export.P + $export.F * _dereq_(34)(INCLUDES), 'String', {
        includes: function includes(searchString
        /* , position = 0 */
        ) {
          return !!~context(this, searchString, INCLUDES).indexOf(searchString, arguments.length > 1 ? arguments[1] : undefined);
        }
      });
    }, {
      "107": 107,
      "33": 33,
      "34": 34
    }],
    243: [function (_dereq_, module, exports) {

      _dereq_(108)('italics', function (createHTML) {
        return function italics() {
          return createHTML(this, 'i', '', '');
        };
      });
    }, {
      "108": 108
    }],
    244: [function (_dereq_, module, exports) {

      var $at = _dereq_(106)(true); // 21.1.3.27 String.prototype[@@iterator]()


      _dereq_(55)(String, 'String', function (iterated) {
        this._t = String(iterated); // target

        this._i = 0; // next index
        // 21.1.5.2.1 %StringIteratorPrototype%.next()
      }, function () {
        var O = this._t;
        var index = this._i;
        var point;
        if (index >= O.length) return {
          value: undefined,
          done: true
        };
        point = $at(O, index);
        this._i += point.length;
        return {
          value: point,
          done: false
        };
      });
    }, {
      "106": 106,
      "55": 55
    }],
    245: [function (_dereq_, module, exports) {

      _dereq_(108)('link', function (createHTML) {
        return function link(url) {
          return createHTML(this, 'a', 'href', url);
        };
      });
    }, {
      "108": 108
    }],
    246: [function (_dereq_, module, exports) {
      var $export = _dereq_(33);

      var toIObject = _dereq_(117);

      var toLength = _dereq_(118);

      $export($export.S, 'String', {
        // 21.1.2.4 String.raw(callSite, ...substitutions)
        raw: function raw(callSite) {
          var tpl = toIObject(callSite.raw);
          var len = toLength(tpl.length);
          var aLen = arguments.length;
          var res = [];
          var i = 0;

          while (len > i) {
            res.push(String(tpl[i++]));
            if (i < aLen) res.push(String(arguments[i]));
          }

          return res.join('');
        }
      });
    }, {
      "117": 117,
      "118": 118,
      "33": 33
    }],
    247: [function (_dereq_, module, exports) {
      var $export = _dereq_(33);

      $export($export.P, 'String', {
        // 21.1.3.13 String.prototype.repeat(count)
        repeat: _dereq_(110)
      });
    }, {
      "110": 110,
      "33": 33
    }],
    248: [function (_dereq_, module, exports) {

      _dereq_(108)('small', function (createHTML) {
        return function small() {
          return createHTML(this, 'small', '', '');
        };
      });
    }, {
      "108": 108
    }],
    249: [function (_dereq_, module, exports) {

      var $export = _dereq_(33);

      var toLength = _dereq_(118);

      var context = _dereq_(107);

      var STARTS_WITH = 'startsWith';
      var $startsWith = ''[STARTS_WITH];
      $export($export.P + $export.F * _dereq_(34)(STARTS_WITH), 'String', {
        startsWith: function startsWith(searchString
        /* , position = 0 */
        ) {
          var that = context(this, searchString, STARTS_WITH);
          var index = toLength(Math.min(arguments.length > 1 ? arguments[1] : undefined, that.length));
          var search = String(searchString);
          return $startsWith ? $startsWith.call(that, search, index) : that.slice(index, index + search.length) === search;
        }
      });
    }, {
      "107": 107,
      "118": 118,
      "33": 33,
      "34": 34
    }],
    250: [function (_dereq_, module, exports) {

      _dereq_(108)('strike', function (createHTML) {
        return function strike() {
          return createHTML(this, 'strike', '', '');
        };
      });
    }, {
      "108": 108
    }],
    251: [function (_dereq_, module, exports) {

      _dereq_(108)('sub', function (createHTML) {
        return function sub() {
          return createHTML(this, 'sub', '', '');
        };
      });
    }, {
      "108": 108
    }],
    252: [function (_dereq_, module, exports) {

      _dereq_(108)('sup', function (createHTML) {
        return function sup() {
          return createHTML(this, 'sup', '', '');
        };
      });
    }, {
      "108": 108
    }],
    253: [function (_dereq_, module, exports) {

      _dereq_(111)('trim', function ($trim) {
        return function trim() {
          return $trim(this, 3);
        };
      });
    }, {
      "111": 111
    }],
    254: [function (_dereq_, module, exports) {

      var global = _dereq_(40);

      var has = _dereq_(41);

      var DESCRIPTORS = _dereq_(29);

      var $export = _dereq_(33);

      var redefine = _dereq_(94);

      var META = _dereq_(66).KEY;

      var $fails = _dereq_(35);

      var shared = _dereq_(103);

      var setToStringTag = _dereq_(101);

      var uid = _dereq_(124);

      var wks = _dereq_(128);

      var wksExt = _dereq_(127);

      var wksDefine = _dereq_(126);

      var keyOf = _dereq_(59);

      var enumKeys = _dereq_(32);

      var isArray = _dereq_(49);

      var anObject = _dereq_(7);

      var toIObject = _dereq_(117);

      var toPrimitive = _dereq_(120);

      var createDesc = _dereq_(92);

      var _create = _dereq_(71);

      var gOPNExt = _dereq_(76);

      var $GOPD = _dereq_(75);

      var $DP = _dereq_(72);

      var $keys = _dereq_(81);

      var gOPD = $GOPD.f;
      var dP = $DP.f;
      var gOPN = gOPNExt.f;
      var $Symbol = global.Symbol;
      var $JSON = global.JSON;

      var _stringify = $JSON && $JSON.stringify;

      var PROTOTYPE = 'prototype';
      var HIDDEN = wks('_hidden');
      var TO_PRIMITIVE = wks('toPrimitive');
      var isEnum = {}.propertyIsEnumerable;
      var SymbolRegistry = shared('symbol-registry');
      var AllSymbols = shared('symbols');
      var OPSymbols = shared('op-symbols');
      var ObjectProto = Object[PROTOTYPE];
      var USE_NATIVE = typeof $Symbol == 'function';
      var QObject = global.QObject; // Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173

      var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild; // fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687

      var setSymbolDesc = DESCRIPTORS && $fails(function () {
        return _create(dP({}, 'a', {
          get: function get() {
            return dP(this, 'a', {
              value: 7
            }).a;
          }
        })).a != 7;
      }) ? function (it, key, D) {
        var protoDesc = gOPD(ObjectProto, key);
        if (protoDesc) delete ObjectProto[key];
        dP(it, key, D);
        if (protoDesc && it !== ObjectProto) dP(ObjectProto, key, protoDesc);
      } : dP;

      var wrap = function wrap(tag) {
        var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);

        sym._k = tag;
        return sym;
      };

      var isSymbol = USE_NATIVE && _typeof($Symbol.iterator) == 'symbol' ? function (it) {
        return _typeof(it) == 'symbol';
      } : function (it) {
        return it instanceof $Symbol;
      };

      var $defineProperty = function defineProperty(it, key, D) {
        if (it === ObjectProto) $defineProperty(OPSymbols, key, D);
        anObject(it);
        key = toPrimitive(key, true);
        anObject(D);

        if (has(AllSymbols, key)) {
          if (!D.enumerable) {
            if (!has(it, HIDDEN)) dP(it, HIDDEN, createDesc(1, {}));
            it[HIDDEN][key] = true;
          } else {
            if (has(it, HIDDEN) && it[HIDDEN][key]) it[HIDDEN][key] = false;
            D = _create(D, {
              enumerable: createDesc(0, false)
            });
          }

          return setSymbolDesc(it, key, D);
        }

        return dP(it, key, D);
      };

      var $defineProperties = function defineProperties(it, P) {
        anObject(it);
        var keys = enumKeys(P = toIObject(P));
        var i = 0;
        var l = keys.length;
        var key;

        while (l > i) {
          $defineProperty(it, key = keys[i++], P[key]);
        }

        return it;
      };

      var $create = function create(it, P) {
        return P === undefined ? _create(it) : $defineProperties(_create(it), P);
      };

      var $propertyIsEnumerable = function propertyIsEnumerable(key) {
        var E = isEnum.call(this, key = toPrimitive(key, true));
        if (this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return false;
        return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
      };

      var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) {
        it = toIObject(it);
        key = toPrimitive(key, true);
        if (it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return;
        var D = gOPD(it, key);
        if (D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) D.enumerable = true;
        return D;
      };

      var $getOwnPropertyNames = function getOwnPropertyNames(it) {
        var names = gOPN(toIObject(it));
        var result = [];
        var i = 0;
        var key;

        while (names.length > i) {
          if (!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META) result.push(key);
        }

        return result;
      };

      var $getOwnPropertySymbols = function getOwnPropertySymbols(it) {
        var IS_OP = it === ObjectProto;
        var names = gOPN(IS_OP ? OPSymbols : toIObject(it));
        var result = [];
        var i = 0;
        var key;

        while (names.length > i) {
          if (has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true)) result.push(AllSymbols[key]);
        }

        return result;
      }; // 19.4.1.1 Symbol([description])


      if (!USE_NATIVE) {
        $Symbol = function _Symbol2() {
          if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor!');
          var tag = uid(arguments.length > 0 ? arguments[0] : undefined);

          var $set = function $set(value) {
            if (this === ObjectProto) $set.call(OPSymbols, value);
            if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
            setSymbolDesc(this, tag, createDesc(1, value));
          };

          if (DESCRIPTORS && setter) setSymbolDesc(ObjectProto, tag, {
            configurable: true,
            set: $set
          });
          return wrap(tag);
        };

        redefine($Symbol[PROTOTYPE], 'toString', function toString() {
          return this._k;
        });
        $GOPD.f = $getOwnPropertyDescriptor;
        $DP.f = $defineProperty;
        _dereq_(77).f = gOPNExt.f = $getOwnPropertyNames;
        _dereq_(82).f = $propertyIsEnumerable;
        _dereq_(78).f = $getOwnPropertySymbols;

        if (DESCRIPTORS && !_dereq_(60)) {
          redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
        }

        wksExt.f = function (name) {
          return wrap(wks(name));
        };
      }

      $export($export.G + $export.W + $export.F * !USE_NATIVE, {
        Symbol: $Symbol
      });

      for (var es6Symbols = // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
      'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'.split(','), j = 0; es6Symbols.length > j;) {
        wks(es6Symbols[j++]);
      }

      for (var wellKnownSymbols = $keys(wks.store), k = 0; wellKnownSymbols.length > k;) {
        wksDefine(wellKnownSymbols[k++]);
      }

      $export($export.S + $export.F * !USE_NATIVE, 'Symbol', {
        // 19.4.2.1 Symbol.for(key)
        'for': function _for(key) {
          return has(SymbolRegistry, key += '') ? SymbolRegistry[key] : SymbolRegistry[key] = $Symbol(key);
        },
        // 19.4.2.5 Symbol.keyFor(sym)
        keyFor: function keyFor(key) {
          if (isSymbol(key)) return keyOf(SymbolRegistry, key);
          throw TypeError(key + ' is not a symbol!');
        },
        useSetter: function useSetter() {
          setter = true;
        },
        useSimple: function useSimple() {
          setter = false;
        }
      });
      $export($export.S + $export.F * !USE_NATIVE, 'Object', {
        // 19.1.2.2 Object.create(O [, Properties])
        create: $create,
        // 19.1.2.4 Object.defineProperty(O, P, Attributes)
        defineProperty: $defineProperty,
        // 19.1.2.3 Object.defineProperties(O, Properties)
        defineProperties: $defineProperties,
        // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
        getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
        // 19.1.2.7 Object.getOwnPropertyNames(O)
        getOwnPropertyNames: $getOwnPropertyNames,
        // 19.1.2.8 Object.getOwnPropertySymbols(O)
        getOwnPropertySymbols: $getOwnPropertySymbols
      }); // 24.3.2 JSON.stringify(value [, replacer [, space]])

      $JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function () {
        var S = $Symbol(); // MS Edge converts symbol values to JSON as {}
        // WebKit converts symbol values to JSON as null
        // V8 throws on boxed symbols

        return _stringify([S]) != '[null]' || _stringify({
          a: S
        }) != '{}' || _stringify(Object(S)) != '{}';
      })), 'JSON', {
        stringify: function stringify(it) {
          if (it === undefined || isSymbol(it)) return; // IE8 returns string on undefined

          var args = [it];
          var i = 1;
          var replacer, $replacer;

          while (arguments.length > i) {
            args.push(arguments[i++]);
          }

          replacer = args[1];
          if (typeof replacer == 'function') $replacer = replacer;
          if ($replacer || !isArray(replacer)) replacer = function replacer(key, value) {
            if ($replacer) value = $replacer.call(this, key, value);
            if (!isSymbol(value)) return value;
          };
          args[1] = replacer;
          return _stringify.apply($JSON, args);
        }
      }); // 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)

      $Symbol[PROTOTYPE][TO_PRIMITIVE] || _dereq_(42)($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf); // 19.4.3.5 Symbol.prototype[@@toStringTag]

      setToStringTag($Symbol, 'Symbol'); // 20.2.1.9 Math[@@toStringTag]

      setToStringTag(Math, 'Math', true); // 24.3.3 JSON[@@toStringTag]

      setToStringTag(global.JSON, 'JSON', true);
    }, {
      "101": 101,
      "103": 103,
      "117": 117,
      "120": 120,
      "124": 124,
      "126": 126,
      "127": 127,
      "128": 128,
      "29": 29,
      "32": 32,
      "33": 33,
      "35": 35,
      "40": 40,
      "41": 41,
      "42": 42,
      "49": 49,
      "59": 59,
      "60": 60,
      "66": 66,
      "7": 7,
      "71": 71,
      "72": 72,
      "75": 75,
      "76": 76,
      "77": 77,
      "78": 78,
      "81": 81,
      "82": 82,
      "92": 92,
      "94": 94
    }],
    255: [function (_dereq_, module, exports) {

      var $export = _dereq_(33);

      var $typed = _dereq_(123);

      var buffer = _dereq_(122);

      var anObject = _dereq_(7);

      var toAbsoluteIndex = _dereq_(114);

      var toLength = _dereq_(118);

      var isObject = _dereq_(51);

      var ArrayBuffer = _dereq_(40).ArrayBuffer;

      var speciesConstructor = _dereq_(104);

      var $ArrayBuffer = buffer.ArrayBuffer;
      var $DataView = buffer.DataView;
      var $isView = $typed.ABV && ArrayBuffer.isView;
      var $slice = $ArrayBuffer.prototype.slice;
      var VIEW = $typed.VIEW;
      var ARRAY_BUFFER = 'ArrayBuffer';
      $export($export.G + $export.W + $export.F * (ArrayBuffer !== $ArrayBuffer), {
        ArrayBuffer: $ArrayBuffer
      });
      $export($export.S + $export.F * !$typed.CONSTR, ARRAY_BUFFER, {
        // 24.1.3.1 ArrayBuffer.isView(arg)
        isView: function isView(it) {
          return $isView && $isView(it) || isObject(it) && VIEW in it;
        }
      });
      $export($export.P + $export.U + $export.F * _dereq_(35)(function () {
        return !new $ArrayBuffer(2).slice(1, undefined).byteLength;
      }), ARRAY_BUFFER, {
        // 24.1.4.3 ArrayBuffer.prototype.slice(start, end)
        slice: function slice(start, end) {
          if ($slice !== undefined && end === undefined) return $slice.call(anObject(this), start); // FF fix

          var len = anObject(this).byteLength;
          var first = toAbsoluteIndex(start, len);

          var _final = toAbsoluteIndex(end === undefined ? len : end, len);

          var result = new (speciesConstructor(this, $ArrayBuffer))(toLength(_final - first));
          var viewS = new $DataView(this);
          var viewT = new $DataView(result);
          var index = 0;

          while (first < _final) {
            viewT.setUint8(index++, viewS.getUint8(first++));
          }

          return result;
        }
      });

      _dereq_(100)(ARRAY_BUFFER);
    }, {
      "100": 100,
      "104": 104,
      "114": 114,
      "118": 118,
      "122": 122,
      "123": 123,
      "33": 33,
      "35": 35,
      "40": 40,
      "51": 51,
      "7": 7
    }],
    256: [function (_dereq_, module, exports) {
      var $export = _dereq_(33);

      $export($export.G + $export.W + $export.F * !_dereq_(123).ABV, {
        DataView: _dereq_(122).DataView
      });
    }, {
      "122": 122,
      "123": 123,
      "33": 33
    }],
    257: [function (_dereq_, module, exports) {
      _dereq_(121)('Float32', 4, function (init) {
        return function Float32Array(data, byteOffset, length) {
          return init(this, data, byteOffset, length);
        };
      });
    }, {
      "121": 121
    }],
    258: [function (_dereq_, module, exports) {
      _dereq_(121)('Float64', 8, function (init) {
        return function Float64Array(data, byteOffset, length) {
          return init(this, data, byteOffset, length);
        };
      });
    }, {
      "121": 121
    }],
    259: [function (_dereq_, module, exports) {
      _dereq_(121)('Int16', 2, function (init) {
        return function Int16Array(data, byteOffset, length) {
          return init(this, data, byteOffset, length);
        };
      });
    }, {
      "121": 121
    }],
    260: [function (_dereq_, module, exports) {
      _dereq_(121)('Int32', 4, function (init) {
        return function Int32Array(data, byteOffset, length) {
          return init(this, data, byteOffset, length);
        };
      });
    }, {
      "121": 121
    }],
    261: [function (_dereq_, module, exports) {
      _dereq_(121)('Int8', 1, function (init) {
        return function Int8Array(data, byteOffset, length) {
          return init(this, data, byteOffset, length);
        };
      });
    }, {
      "121": 121
    }],
    262: [function (_dereq_, module, exports) {
      _dereq_(121)('Uint16', 2, function (init) {
        return function Uint16Array(data, byteOffset, length) {
          return init(this, data, byteOffset, length);
        };
      });
    }, {
      "121": 121
    }],
    263: [function (_dereq_, module, exports) {
      _dereq_(121)('Uint32', 4, function (init) {
        return function Uint32Array(data, byteOffset, length) {
          return init(this, data, byteOffset, length);
        };
      });
    }, {
      "121": 121
    }],
    264: [function (_dereq_, module, exports) {
      _dereq_(121)('Uint8', 1, function (init) {
        return function Uint8Array(data, byteOffset, length) {
          return init(this, data, byteOffset, length);
        };
      });
    }, {
      "121": 121
    }],
    265: [function (_dereq_, module, exports) {
      _dereq_(121)('Uint8', 1, function (init) {
        return function Uint8ClampedArray(data, byteOffset, length) {
          return init(this, data, byteOffset, length);
        };
      }, true);
    }, {
      "121": 121
    }],
    266: [function (_dereq_, module, exports) {

      var each = _dereq_(12)(0);

      var redefine = _dereq_(94);

      var meta = _dereq_(66);

      var assign = _dereq_(70);

      var weak = _dereq_(21);

      var isObject = _dereq_(51);

      var fails = _dereq_(35);

      var validate = _dereq_(125);

      var WEAK_MAP = 'WeakMap';
      var getWeak = meta.getWeak;
      var isExtensible = Object.isExtensible;
      var uncaughtFrozenStore = weak.ufstore;
      var tmp = {};
      var InternalMap;

      var wrapper = function wrapper(get) {
        return function WeakMap() {
          return get(this, arguments.length > 0 ? arguments[0] : undefined);
        };
      };

      var methods = {
        // 23.3.3.3 WeakMap.prototype.get(key)
        get: function get(key) {
          if (isObject(key)) {
            var data = getWeak(key);
            if (data === true) return uncaughtFrozenStore(validate(this, WEAK_MAP)).get(key);
            return data ? data[this._i] : undefined;
          }
        },
        // 23.3.3.5 WeakMap.prototype.set(key, value)
        set: function set(key, value) {
          return weak.def(validate(this, WEAK_MAP), key, value);
        }
      }; // 23.3 WeakMap Objects

      var $WeakMap = module.exports = _dereq_(22)(WEAK_MAP, wrapper, methods, weak, true, true); // IE11 WeakMap frozen keys fix


      if (fails(function () {
        return new $WeakMap().set((Object.freeze || Object)(tmp), 7).get(tmp) != 7;
      })) {
        InternalMap = weak.getConstructor(wrapper, WEAK_MAP);
        assign(InternalMap.prototype, methods);
        meta.NEED = true;
        each(['delete', 'has', 'get', 'set'], function (key) {
          var proto = $WeakMap.prototype;
          var method = proto[key];
          redefine(proto, key, function (a, b) {
            // store frozen objects on internal weakmap shim
            if (isObject(a) && !isExtensible(a)) {
              if (!this._f) this._f = new InternalMap();

              var result = this._f[key](a, b);

              return key == 'set' ? this : result; // store all the rest on native weakmap
            }

            return method.call(this, a, b);
          });
        });
      }
    }, {
      "12": 12,
      "125": 125,
      "21": 21,
      "22": 22,
      "35": 35,
      "51": 51,
      "66": 66,
      "70": 70,
      "94": 94
    }],
    267: [function (_dereq_, module, exports) {

      var weak = _dereq_(21);

      var validate = _dereq_(125);

      var WEAK_SET = 'WeakSet'; // 23.4 WeakSet Objects

      _dereq_(22)(WEAK_SET, function (get) {
        return function WeakSet() {
          return get(this, arguments.length > 0 ? arguments[0] : undefined);
        };
      }, {
        // 23.4.3.1 WeakSet.prototype.add(value)
        add: function add(value) {
          return weak.def(validate(this, WEAK_SET), value, true);
        }
      }, weak, false, true);
    }, {
      "125": 125,
      "21": 21,
      "22": 22
    }],
    268: [function (_dereq_, module, exports) {

      var $export = _dereq_(33);

      var flattenIntoArray = _dereq_(38);

      var toObject = _dereq_(119);

      var toLength = _dereq_(118);

      var aFunction = _dereq_(3);

      var arraySpeciesCreate = _dereq_(15);

      $export($export.P, 'Array', {
        flatMap: function flatMap(callbackfn
        /* , thisArg */
        ) {
          var O = toObject(this);
          var sourceLen, A;
          aFunction(callbackfn);
          sourceLen = toLength(O.length);
          A = arraySpeciesCreate(O, 0);
          flattenIntoArray(A, O, O, sourceLen, 0, 1, callbackfn, arguments[1]);
          return A;
        }
      });

      _dereq_(5)('flatMap');
    }, {
      "118": 118,
      "119": 119,
      "15": 15,
      "3": 3,
      "33": 33,
      "38": 38,
      "5": 5
    }],
    269: [function (_dereq_, module, exports) {

      var $export = _dereq_(33);

      var flattenIntoArray = _dereq_(38);

      var toObject = _dereq_(119);

      var toLength = _dereq_(118);

      var toInteger = _dereq_(116);

      var arraySpeciesCreate = _dereq_(15);

      $export($export.P, 'Array', {
        flatten: function flatten()
        /* depthArg = 1 */
        {
          var depthArg = arguments[0];
          var O = toObject(this);
          var sourceLen = toLength(O.length);
          var A = arraySpeciesCreate(O, 0);
          flattenIntoArray(A, O, O, sourceLen, 0, depthArg === undefined ? 1 : toInteger(depthArg));
          return A;
        }
      });

      _dereq_(5)('flatten');
    }, {
      "116": 116,
      "118": 118,
      "119": 119,
      "15": 15,
      "33": 33,
      "38": 38,
      "5": 5
    }],
    270: [function (_dereq_, module, exports) {

      var $export = _dereq_(33);

      var $includes = _dereq_(11)(true);

      $export($export.P, 'Array', {
        includes: function includes(el
        /* , fromIndex = 0 */
        ) {
          return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);
        }
      });

      _dereq_(5)('includes');
    }, {
      "11": 11,
      "33": 33,
      "5": 5
    }],
    271: [function (_dereq_, module, exports) {
      // https://github.com/rwaldron/tc39-notes/blob/master/es6/2014-09/sept-25.md#510-globalasap-for-enqueuing-a-microtask
      var $export = _dereq_(33);

      var microtask = _dereq_(68)();

      var process = _dereq_(40).process;

      var isNode = _dereq_(18)(process) == 'process';
      $export($export.G, {
        asap: function asap(fn) {
          var domain = isNode && process.domain;
          microtask(domain ? domain.bind(fn) : fn);
        }
      });
    }, {
      "18": 18,
      "33": 33,
      "40": 40,
      "68": 68
    }],
    272: [function (_dereq_, module, exports) {
      // https://github.com/ljharb/proposal-is-error
      var $export = _dereq_(33);

      var cof = _dereq_(18);

      $export($export.S, 'Error', {
        isError: function isError(it) {
          return cof(it) === 'Error';
        }
      });
    }, {
      "18": 18,
      "33": 33
    }],
    273: [function (_dereq_, module, exports) {
      // https://github.com/tc39/proposal-global
      var $export = _dereq_(33);

      $export($export.G, {
        global: _dereq_(40)
      });
    }, {
      "33": 33,
      "40": 40
    }],
    274: [function (_dereq_, module, exports) {
      // https://tc39.github.io/proposal-setmap-offrom/#sec-map.from
      _dereq_(97)('Map');
    }, {
      "97": 97
    }],
    275: [function (_dereq_, module, exports) {
      // https://tc39.github.io/proposal-setmap-offrom/#sec-map.of
      _dereq_(98)('Map');
    }, {
      "98": 98
    }],
    276: [function (_dereq_, module, exports) {
      // https://github.com/DavidBruant/Map-Set.prototype.toJSON
      var $export = _dereq_(33);

      $export($export.P + $export.R, 'Map', {
        toJSON: _dereq_(20)('Map')
      });
    }, {
      "20": 20,
      "33": 33
    }],
    277: [function (_dereq_, module, exports) {
      // https://rwaldron.github.io/proposal-math-extensions/
      var $export = _dereq_(33);

      $export($export.S, 'Math', {
        clamp: function clamp(x, lower, upper) {
          return Math.min(upper, Math.max(lower, x));
        }
      });
    }, {
      "33": 33
    }],
    278: [function (_dereq_, module, exports) {
      // https://rwaldron.github.io/proposal-math-extensions/
      var $export = _dereq_(33);

      $export($export.S, 'Math', {
        DEG_PER_RAD: Math.PI / 180
      });
    }, {
      "33": 33
    }],
    279: [function (_dereq_, module, exports) {
      // https://rwaldron.github.io/proposal-math-extensions/
      var $export = _dereq_(33);

      var RAD_PER_DEG = 180 / Math.PI;
      $export($export.S, 'Math', {
        degrees: function degrees(radians) {
          return radians * RAD_PER_DEG;
        }
      });
    }, {
      "33": 33
    }],
    280: [function (_dereq_, module, exports) {
      // https://rwaldron.github.io/proposal-math-extensions/
      var $export = _dereq_(33);

      var scale = _dereq_(64);

      var fround = _dereq_(62);

      $export($export.S, 'Math', {
        fscale: function fscale(x, inLow, inHigh, outLow, outHigh) {
          return fround(scale(x, inLow, inHigh, outLow, outHigh));
        }
      });
    }, {
      "33": 33,
      "62": 62,
      "64": 64
    }],
    281: [function (_dereq_, module, exports) {
      // https://gist.github.com/BrendanEich/4294d5c212a6d2254703
      var $export = _dereq_(33);

      $export($export.S, 'Math', {
        iaddh: function iaddh(x0, x1, y0, y1) {
          var $x0 = x0 >>> 0;
          var $x1 = x1 >>> 0;
          var $y0 = y0 >>> 0;
          return $x1 + (y1 >>> 0) + (($x0 & $y0 | ($x0 | $y0) & ~($x0 + $y0 >>> 0)) >>> 31) | 0;
        }
      });
    }, {
      "33": 33
    }],
    282: [function (_dereq_, module, exports) {
      // https://gist.github.com/BrendanEich/4294d5c212a6d2254703
      var $export = _dereq_(33);

      $export($export.S, 'Math', {
        imulh: function imulh(u, v) {
          var UINT16 = 0xffff;
          var $u = +u;
          var $v = +v;
          var u0 = $u & UINT16;
          var v0 = $v & UINT16;
          var u1 = $u >> 16;
          var v1 = $v >> 16;
          var t = (u1 * v0 >>> 0) + (u0 * v0 >>> 16);
          return u1 * v1 + (t >> 16) + ((u0 * v1 >>> 0) + (t & UINT16) >> 16);
        }
      });
    }, {
      "33": 33
    }],
    283: [function (_dereq_, module, exports) {
      // https://gist.github.com/BrendanEich/4294d5c212a6d2254703
      var $export = _dereq_(33);

      $export($export.S, 'Math', {
        isubh: function isubh(x0, x1, y0, y1) {
          var $x0 = x0 >>> 0;
          var $x1 = x1 >>> 0;
          var $y0 = y0 >>> 0;
          return $x1 - (y1 >>> 0) - ((~$x0 & $y0 | ~($x0 ^ $y0) & $x0 - $y0 >>> 0) >>> 31) | 0;
        }
      });
    }, {
      "33": 33
    }],
    284: [function (_dereq_, module, exports) {
      // https://rwaldron.github.io/proposal-math-extensions/
      var $export = _dereq_(33);

      $export($export.S, 'Math', {
        RAD_PER_DEG: 180 / Math.PI
      });
    }, {
      "33": 33
    }],
    285: [function (_dereq_, module, exports) {
      // https://rwaldron.github.io/proposal-math-extensions/
      var $export = _dereq_(33);

      var DEG_PER_RAD = Math.PI / 180;
      $export($export.S, 'Math', {
        radians: function radians(degrees) {
          return degrees * DEG_PER_RAD;
        }
      });
    }, {
      "33": 33
    }],
    286: [function (_dereq_, module, exports) {
      // https://rwaldron.github.io/proposal-math-extensions/
      var $export = _dereq_(33);

      $export($export.S, 'Math', {
        scale: _dereq_(64)
      });
    }, {
      "33": 33,
      "64": 64
    }],
    287: [function (_dereq_, module, exports) {
      // http://jfbastien.github.io/papers/Math.signbit.html
      var $export = _dereq_(33);

      $export($export.S, 'Math', {
        signbit: function signbit(x) {
          // eslint-disable-next-line no-self-compare
          return (x = +x) != x ? x : x == 0 ? 1 / x == Infinity : x > 0;
        }
      });
    }, {
      "33": 33
    }],
    288: [function (_dereq_, module, exports) {
      // https://gist.github.com/BrendanEich/4294d5c212a6d2254703
      var $export = _dereq_(33);

      $export($export.S, 'Math', {
        umulh: function umulh(u, v) {
          var UINT16 = 0xffff;
          var $u = +u;
          var $v = +v;
          var u0 = $u & UINT16;
          var v0 = $v & UINT16;
          var u1 = $u >>> 16;
          var v1 = $v >>> 16;
          var t = (u1 * v0 >>> 0) + (u0 * v0 >>> 16);
          return u1 * v1 + (t >>> 16) + ((u0 * v1 >>> 0) + (t & UINT16) >>> 16);
        }
      });
    }, {
      "33": 33
    }],
    289: [function (_dereq_, module, exports) {

      var $export = _dereq_(33);

      var toObject = _dereq_(119);

      var aFunction = _dereq_(3);

      var $defineProperty = _dereq_(72); // B.2.2.2 Object.prototype.__defineGetter__(P, getter)


      _dereq_(29) && $export($export.P + _dereq_(74), 'Object', {
        __defineGetter__: function __defineGetter__(P, getter) {
          $defineProperty.f(toObject(this), P, {
            get: aFunction(getter),
            enumerable: true,
            configurable: true
          });
        }
      });
    }, {
      "119": 119,
      "29": 29,
      "3": 3,
      "33": 33,
      "72": 72,
      "74": 74
    }],
    290: [function (_dereq_, module, exports) {

      var $export = _dereq_(33);

      var toObject = _dereq_(119);

      var aFunction = _dereq_(3);

      var $defineProperty = _dereq_(72); // B.2.2.3 Object.prototype.__defineSetter__(P, setter)


      _dereq_(29) && $export($export.P + _dereq_(74), 'Object', {
        __defineSetter__: function __defineSetter__(P, setter) {
          $defineProperty.f(toObject(this), P, {
            set: aFunction(setter),
            enumerable: true,
            configurable: true
          });
        }
      });
    }, {
      "119": 119,
      "29": 29,
      "3": 3,
      "33": 33,
      "72": 72,
      "74": 74
    }],
    291: [function (_dereq_, module, exports) {
      // https://github.com/tc39/proposal-object-values-entries
      var $export = _dereq_(33);

      var $entries = _dereq_(84)(true);

      $export($export.S, 'Object', {
        entries: function entries(it) {
          return $entries(it);
        }
      });
    }, {
      "33": 33,
      "84": 84
    }],
    292: [function (_dereq_, module, exports) {
      // https://github.com/tc39/proposal-object-getownpropertydescriptors
      var $export = _dereq_(33);

      var ownKeys = _dereq_(85);

      var toIObject = _dereq_(117);

      var gOPD = _dereq_(75);

      var createProperty = _dereq_(24);

      $export($export.S, 'Object', {
        getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object) {
          var O = toIObject(object);
          var getDesc = gOPD.f;
          var keys = ownKeys(O);
          var result = {};
          var i = 0;
          var key, desc;

          while (keys.length > i) {
            desc = getDesc(O, key = keys[i++]);
            if (desc !== undefined) createProperty(result, key, desc);
          }

          return result;
        }
      });
    }, {
      "117": 117,
      "24": 24,
      "33": 33,
      "75": 75,
      "85": 85
    }],
    293: [function (_dereq_, module, exports) {

      var $export = _dereq_(33);

      var toObject = _dereq_(119);

      var toPrimitive = _dereq_(120);

      var getPrototypeOf = _dereq_(79);

      var getOwnPropertyDescriptor = _dereq_(75).f; // B.2.2.4 Object.prototype.__lookupGetter__(P)


      _dereq_(29) && $export($export.P + _dereq_(74), 'Object', {
        __lookupGetter__: function __lookupGetter__(P) {
          var O = toObject(this);
          var K = toPrimitive(P, true);
          var D;

          do {
            if (D = getOwnPropertyDescriptor(O, K)) return D.get;
          } while (O = getPrototypeOf(O));
        }
      });
    }, {
      "119": 119,
      "120": 120,
      "29": 29,
      "33": 33,
      "74": 74,
      "75": 75,
      "79": 79
    }],
    294: [function (_dereq_, module, exports) {

      var $export = _dereq_(33);

      var toObject = _dereq_(119);

      var toPrimitive = _dereq_(120);

      var getPrototypeOf = _dereq_(79);

      var getOwnPropertyDescriptor = _dereq_(75).f; // B.2.2.5 Object.prototype.__lookupSetter__(P)


      _dereq_(29) && $export($export.P + _dereq_(74), 'Object', {
        __lookupSetter__: function __lookupSetter__(P) {
          var O = toObject(this);
          var K = toPrimitive(P, true);
          var D;

          do {
            if (D = getOwnPropertyDescriptor(O, K)) return D.set;
          } while (O = getPrototypeOf(O));
        }
      });
    }, {
      "119": 119,
      "120": 120,
      "29": 29,
      "33": 33,
      "74": 74,
      "75": 75,
      "79": 79
    }],
    295: [function (_dereq_, module, exports) {
      // https://github.com/tc39/proposal-object-values-entries
      var $export = _dereq_(33);

      var $values = _dereq_(84)(false);

      $export($export.S, 'Object', {
        values: function values(it) {
          return $values(it);
        }
      });
    }, {
      "33": 33,
      "84": 84
    }],
    296: [function (_dereq_, module, exports) {

      var $export = _dereq_(33);

      var global = _dereq_(40);

      var core = _dereq_(23);

      var microtask = _dereq_(68)();

      var OBSERVABLE = _dereq_(128)('observable');

      var aFunction = _dereq_(3);

      var anObject = _dereq_(7);

      var anInstance = _dereq_(6);

      var redefineAll = _dereq_(93);

      var hide = _dereq_(42);

      var forOf = _dereq_(39);

      var RETURN = forOf.RETURN;

      var getMethod = function getMethod(fn) {
        return fn == null ? undefined : aFunction(fn);
      };

      var cleanupSubscription = function cleanupSubscription(subscription) {
        var cleanup = subscription._c;

        if (cleanup) {
          subscription._c = undefined;
          cleanup();
        }
      };

      var subscriptionClosed = function subscriptionClosed(subscription) {
        return subscription._o === undefined;
      };

      var closeSubscription = function closeSubscription(subscription) {
        if (!subscriptionClosed(subscription)) {
          subscription._o = undefined;
          cleanupSubscription(subscription);
        }
      };

      var Subscription = function Subscription(observer, subscriber) {
        anObject(observer);
        this._c = undefined;
        this._o = observer;
        observer = new SubscriptionObserver(this);

        try {
          var cleanup = subscriber(observer);
          var subscription = cleanup;

          if (cleanup != null) {
            if (typeof cleanup.unsubscribe === 'function') cleanup = function cleanup() {
              subscription.unsubscribe();
            };else aFunction(cleanup);
            this._c = cleanup;
          }
        } catch (e) {
          observer.error(e);
          return;
        }

        if (subscriptionClosed(this)) cleanupSubscription(this);
      };

      Subscription.prototype = redefineAll({}, {
        unsubscribe: function unsubscribe() {
          closeSubscription(this);
        }
      });

      var SubscriptionObserver = function SubscriptionObserver(subscription) {
        this._s = subscription;
      };

      SubscriptionObserver.prototype = redefineAll({}, {
        next: function next(value) {
          var subscription = this._s;

          if (!subscriptionClosed(subscription)) {
            var observer = subscription._o;

            try {
              var m = getMethod(observer.next);
              if (m) return m.call(observer, value);
            } catch (e) {
              try {
                closeSubscription(subscription);
              } finally {
                throw e;
              }
            }
          }
        },
        error: function error(value) {
          var subscription = this._s;
          if (subscriptionClosed(subscription)) throw value;
          var observer = subscription._o;
          subscription._o = undefined;

          try {
            var m = getMethod(observer.error);
            if (!m) throw value;
            value = m.call(observer, value);
          } catch (e) {
            try {
              cleanupSubscription(subscription);
            } finally {
              throw e;
            }
          }

          cleanupSubscription(subscription);
          return value;
        },
        complete: function complete(value) {
          var subscription = this._s;

          if (!subscriptionClosed(subscription)) {
            var observer = subscription._o;
            subscription._o = undefined;

            try {
              var m = getMethod(observer.complete);
              value = m ? m.call(observer, value) : undefined;
            } catch (e) {
              try {
                cleanupSubscription(subscription);
              } finally {
                throw e;
              }
            }

            cleanupSubscription(subscription);
            return value;
          }
        }
      });

      var $Observable = function Observable(subscriber) {
        anInstance(this, $Observable, 'Observable', '_f')._f = aFunction(subscriber);
      };

      redefineAll($Observable.prototype, {
        subscribe: function subscribe(observer) {
          return new Subscription(observer, this._f);
        },
        forEach: function forEach(fn) {
          var that = this;
          return new (core.Promise || global.Promise)(function (resolve, reject) {
            aFunction(fn);
            var subscription = that.subscribe({
              next: function next(value) {
                try {
                  return fn(value);
                } catch (e) {
                  reject(e);
                  subscription.unsubscribe();
                }
              },
              error: reject,
              complete: resolve
            });
          });
        }
      });
      redefineAll($Observable, {
        from: function from(x) {
          var C = typeof this === 'function' ? this : $Observable;
          var method = getMethod(anObject(x)[OBSERVABLE]);

          if (method) {
            var observable = anObject(method.call(x));
            return observable.constructor === C ? observable : new C(function (observer) {
              return observable.subscribe(observer);
            });
          }

          return new C(function (observer) {
            var done = false;
            microtask(function () {
              if (!done) {
                try {
                  if (forOf(x, false, function (it) {
                    observer.next(it);
                    if (done) return RETURN;
                  }) === RETURN) return;
                } catch (e) {
                  if (done) throw e;
                  observer.error(e);
                  return;
                }

                observer.complete();
              }
            });
            return function () {
              done = true;
            };
          });
        },
        of: function of() {
          for (var i = 0, l = arguments.length, items = Array(l); i < l;) {
            items[i] = arguments[i++];
          }

          return new (typeof this === 'function' ? this : $Observable)(function (observer) {
            var done = false;
            microtask(function () {
              if (!done) {
                for (var j = 0; j < items.length; ++j) {
                  observer.next(items[j]);
                  if (done) return;
                }

                observer.complete();
              }
            });
            return function () {
              done = true;
            };
          });
        }
      });
      hide($Observable.prototype, OBSERVABLE, function () {
        return this;
      });
      $export($export.G, {
        Observable: $Observable
      });

      _dereq_(100)('Observable');
    }, {
      "100": 100,
      "128": 128,
      "23": 23,
      "3": 3,
      "33": 33,
      "39": 39,
      "40": 40,
      "42": 42,
      "6": 6,
      "68": 68,
      "7": 7,
      "93": 93
    }],
    297: [function (_dereq_, module, exports) {

      var $export = _dereq_(33);

      var core = _dereq_(23);

      var global = _dereq_(40);

      var speciesConstructor = _dereq_(104);

      var promiseResolve = _dereq_(91);

      $export($export.P + $export.R, 'Promise', {
        'finally': function _finally(onFinally) {
          var C = speciesConstructor(this, core.Promise || global.Promise);
          var isFunction = typeof onFinally == 'function';
          return this.then(isFunction ? function (x) {
            return promiseResolve(C, onFinally()).then(function () {
              return x;
            });
          } : onFinally, isFunction ? function (e) {
            return promiseResolve(C, onFinally()).then(function () {
              throw e;
            });
          } : onFinally);
        }
      });
    }, {
      "104": 104,
      "23": 23,
      "33": 33,
      "40": 40,
      "91": 91
    }],
    298: [function (_dereq_, module, exports) {

      var $export = _dereq_(33);

      var newPromiseCapability = _dereq_(69);

      var perform = _dereq_(90);

      $export($export.S, 'Promise', {
        'try': function _try(callbackfn) {
          var promiseCapability = newPromiseCapability.f(this);
          var result = perform(callbackfn);
          (result.e ? promiseCapability.reject : promiseCapability.resolve)(result.v);
          return promiseCapability.promise;
        }
      });
    }, {
      "33": 33,
      "69": 69,
      "90": 90
    }],
    299: [function (_dereq_, module, exports) {
      var metadata = _dereq_(67);

      var anObject = _dereq_(7);

      var toMetaKey = metadata.key;
      var ordinaryDefineOwnMetadata = metadata.set;
      metadata.exp({
        defineMetadata: function defineMetadata(metadataKey, metadataValue, target, targetKey) {
          ordinaryDefineOwnMetadata(metadataKey, metadataValue, anObject(target), toMetaKey(targetKey));
        }
      });
    }, {
      "67": 67,
      "7": 7
    }],
    300: [function (_dereq_, module, exports) {
      var metadata = _dereq_(67);

      var anObject = _dereq_(7);

      var toMetaKey = metadata.key;
      var getOrCreateMetadataMap = metadata.map;
      var store = metadata.store;
      metadata.exp({
        deleteMetadata: function deleteMetadata(metadataKey, target
        /* , targetKey */
        ) {
          var targetKey = arguments.length < 3 ? undefined : toMetaKey(arguments[2]);
          var metadataMap = getOrCreateMetadataMap(anObject(target), targetKey, false);
          if (metadataMap === undefined || !metadataMap['delete'](metadataKey)) return false;
          if (metadataMap.size) return true;
          var targetMetadata = store.get(target);
          targetMetadata['delete'](targetKey);
          return !!targetMetadata.size || store['delete'](target);
        }
      });
    }, {
      "67": 67,
      "7": 7
    }],
    301: [function (_dereq_, module, exports) {
      var Set = _dereq_(231);

      var from = _dereq_(10);

      var metadata = _dereq_(67);

      var anObject = _dereq_(7);

      var getPrototypeOf = _dereq_(79);

      var ordinaryOwnMetadataKeys = metadata.keys;
      var toMetaKey = metadata.key;

      var ordinaryMetadataKeys = function ordinaryMetadataKeys(O, P) {
        var oKeys = ordinaryOwnMetadataKeys(O, P);
        var parent = getPrototypeOf(O);
        if (parent === null) return oKeys;
        var pKeys = ordinaryMetadataKeys(parent, P);
        return pKeys.length ? oKeys.length ? from(new Set(oKeys.concat(pKeys))) : pKeys : oKeys;
      };

      metadata.exp({
        getMetadataKeys: function getMetadataKeys(target
        /* , targetKey */
        ) {
          return ordinaryMetadataKeys(anObject(target), arguments.length < 2 ? undefined : toMetaKey(arguments[1]));
        }
      });
    }, {
      "10": 10,
      "231": 231,
      "67": 67,
      "7": 7,
      "79": 79
    }],
    302: [function (_dereq_, module, exports) {
      var metadata = _dereq_(67);

      var anObject = _dereq_(7);

      var getPrototypeOf = _dereq_(79);

      var ordinaryHasOwnMetadata = metadata.has;
      var ordinaryGetOwnMetadata = metadata.get;
      var toMetaKey = metadata.key;

      var ordinaryGetMetadata = function ordinaryGetMetadata(MetadataKey, O, P) {
        var hasOwn = ordinaryHasOwnMetadata(MetadataKey, O, P);
        if (hasOwn) return ordinaryGetOwnMetadata(MetadataKey, O, P);
        var parent = getPrototypeOf(O);
        return parent !== null ? ordinaryGetMetadata(MetadataKey, parent, P) : undefined;
      };

      metadata.exp({
        getMetadata: function getMetadata(metadataKey, target
        /* , targetKey */
        ) {
          return ordinaryGetMetadata(metadataKey, anObject(target), arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
        }
      });
    }, {
      "67": 67,
      "7": 7,
      "79": 79
    }],
    303: [function (_dereq_, module, exports) {
      var metadata = _dereq_(67);

      var anObject = _dereq_(7);

      var ordinaryOwnMetadataKeys = metadata.keys;
      var toMetaKey = metadata.key;
      metadata.exp({
        getOwnMetadataKeys: function getOwnMetadataKeys(target
        /* , targetKey */
        ) {
          return ordinaryOwnMetadataKeys(anObject(target), arguments.length < 2 ? undefined : toMetaKey(arguments[1]));
        }
      });
    }, {
      "67": 67,
      "7": 7
    }],
    304: [function (_dereq_, module, exports) {
      var metadata = _dereq_(67);

      var anObject = _dereq_(7);

      var ordinaryGetOwnMetadata = metadata.get;
      var toMetaKey = metadata.key;
      metadata.exp({
        getOwnMetadata: function getOwnMetadata(metadataKey, target
        /* , targetKey */
        ) {
          return ordinaryGetOwnMetadata(metadataKey, anObject(target), arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
        }
      });
    }, {
      "67": 67,
      "7": 7
    }],
    305: [function (_dereq_, module, exports) {
      var metadata = _dereq_(67);

      var anObject = _dereq_(7);

      var getPrototypeOf = _dereq_(79);

      var ordinaryHasOwnMetadata = metadata.has;
      var toMetaKey = metadata.key;

      var ordinaryHasMetadata = function ordinaryHasMetadata(MetadataKey, O, P) {
        var hasOwn = ordinaryHasOwnMetadata(MetadataKey, O, P);
        if (hasOwn) return true;
        var parent = getPrototypeOf(O);
        return parent !== null ? ordinaryHasMetadata(MetadataKey, parent, P) : false;
      };

      metadata.exp({
        hasMetadata: function hasMetadata(metadataKey, target
        /* , targetKey */
        ) {
          return ordinaryHasMetadata(metadataKey, anObject(target), arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
        }
      });
    }, {
      "67": 67,
      "7": 7,
      "79": 79
    }],
    306: [function (_dereq_, module, exports) {
      var metadata = _dereq_(67);

      var anObject = _dereq_(7);

      var ordinaryHasOwnMetadata = metadata.has;
      var toMetaKey = metadata.key;
      metadata.exp({
        hasOwnMetadata: function hasOwnMetadata(metadataKey, target
        /* , targetKey */
        ) {
          return ordinaryHasOwnMetadata(metadataKey, anObject(target), arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
        }
      });
    }, {
      "67": 67,
      "7": 7
    }],
    307: [function (_dereq_, module, exports) {
      var $metadata = _dereq_(67);

      var anObject = _dereq_(7);

      var aFunction = _dereq_(3);

      var toMetaKey = $metadata.key;
      var ordinaryDefineOwnMetadata = $metadata.set;
      $metadata.exp({
        metadata: function metadata(metadataKey, metadataValue) {
          return function decorator(target, targetKey) {
            ordinaryDefineOwnMetadata(metadataKey, metadataValue, (targetKey !== undefined ? anObject : aFunction)(target), toMetaKey(targetKey));
          };
        }
      });
    }, {
      "3": 3,
      "67": 67,
      "7": 7
    }],
    308: [function (_dereq_, module, exports) {
      // https://tc39.github.io/proposal-setmap-offrom/#sec-set.from
      _dereq_(97)('Set');
    }, {
      "97": 97
    }],
    309: [function (_dereq_, module, exports) {
      // https://tc39.github.io/proposal-setmap-offrom/#sec-set.of
      _dereq_(98)('Set');
    }, {
      "98": 98
    }],
    310: [function (_dereq_, module, exports) {
      // https://github.com/DavidBruant/Map-Set.prototype.toJSON
      var $export = _dereq_(33);

      $export($export.P + $export.R, 'Set', {
        toJSON: _dereq_(20)('Set')
      });
    }, {
      "20": 20,
      "33": 33
    }],
    311: [function (_dereq_, module, exports) {

      var $export = _dereq_(33);

      var $at = _dereq_(106)(true);

      $export($export.P, 'String', {
        at: function at(pos) {
          return $at(this, pos);
        }
      });
    }, {
      "106": 106,
      "33": 33
    }],
    312: [function (_dereq_, module, exports) {

      var $export = _dereq_(33);

      var defined = _dereq_(28);

      var toLength = _dereq_(118);

      var isRegExp = _dereq_(52);

      var getFlags = _dereq_(37);

      var RegExpProto = RegExp.prototype;

      var $RegExpStringIterator = function $RegExpStringIterator(regexp, string) {
        this._r = regexp;
        this._s = string;
      };

      _dereq_(54)($RegExpStringIterator, 'RegExp String', function next() {
        var match = this._r.exec(this._s);

        return {
          value: match,
          done: match === null
        };
      });

      $export($export.P, 'String', {
        matchAll: function matchAll(regexp) {
          defined(this);
          if (!isRegExp(regexp)) throw TypeError(regexp + ' is not a regexp!');
          var S = String(this);
          var flags = 'flags' in RegExpProto ? String(regexp.flags) : getFlags.call(regexp);
          var rx = new RegExp(regexp.source, ~flags.indexOf('g') ? flags : 'g' + flags);
          rx.lastIndex = toLength(regexp.lastIndex);
          return new $RegExpStringIterator(rx, S);
        }
      });
    }, {
      "118": 118,
      "28": 28,
      "33": 33,
      "37": 37,
      "52": 52,
      "54": 54
    }],
    313: [function (_dereq_, module, exports) {

      var $export = _dereq_(33);

      var $pad = _dereq_(109);

      $export($export.P, 'String', {
        padEnd: function padEnd(maxLength
        /* , fillString = ' ' */
        ) {
          return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, false);
        }
      });
    }, {
      "109": 109,
      "33": 33
    }],
    314: [function (_dereq_, module, exports) {

      var $export = _dereq_(33);

      var $pad = _dereq_(109);

      $export($export.P, 'String', {
        padStart: function padStart(maxLength
        /* , fillString = ' ' */
        ) {
          return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, true);
        }
      });
    }, {
      "109": 109,
      "33": 33
    }],
    315: [function (_dereq_, module, exports) {

      _dereq_(111)('trimLeft', function ($trim) {
        return function trimLeft() {
          return $trim(this, 1);
        };
      }, 'trimStart');
    }, {
      "111": 111
    }],
    316: [function (_dereq_, module, exports) {

      _dereq_(111)('trimRight', function ($trim) {
        return function trimRight() {
          return $trim(this, 2);
        };
      }, 'trimEnd');
    }, {
      "111": 111
    }],
    317: [function (_dereq_, module, exports) {
      _dereq_(126)('asyncIterator');
    }, {
      "126": 126
    }],
    318: [function (_dereq_, module, exports) {
      _dereq_(126)('observable');
    }, {
      "126": 126
    }],
    319: [function (_dereq_, module, exports) {
      // https://github.com/tc39/proposal-global
      var $export = _dereq_(33);

      $export($export.S, 'System', {
        global: _dereq_(40)
      });
    }, {
      "33": 33,
      "40": 40
    }],
    320: [function (_dereq_, module, exports) {
      // https://tc39.github.io/proposal-setmap-offrom/#sec-weakmap.from
      _dereq_(97)('WeakMap');
    }, {
      "97": 97
    }],
    321: [function (_dereq_, module, exports) {
      // https://tc39.github.io/proposal-setmap-offrom/#sec-weakmap.of
      _dereq_(98)('WeakMap');
    }, {
      "98": 98
    }],
    322: [function (_dereq_, module, exports) {
      // https://tc39.github.io/proposal-setmap-offrom/#sec-weakset.from
      _dereq_(97)('WeakSet');
    }, {
      "97": 97
    }],
    323: [function (_dereq_, module, exports) {
      // https://tc39.github.io/proposal-setmap-offrom/#sec-weakset.of
      _dereq_(98)('WeakSet');
    }, {
      "98": 98
    }],
    324: [function (_dereq_, module, exports) {
      var $iterators = _dereq_(141);

      var getKeys = _dereq_(81);

      var redefine = _dereq_(94);

      var global = _dereq_(40);

      var hide = _dereq_(42);

      var Iterators = _dereq_(58);

      var wks = _dereq_(128);

      var ITERATOR = wks('iterator');
      var TO_STRING_TAG = wks('toStringTag');
      var ArrayValues = Iterators.Array;
      var DOMIterables = {
        CSSRuleList: true,
        // TODO: Not spec compliant, should be false.
        CSSStyleDeclaration: false,
        CSSValueList: false,
        ClientRectList: false,
        DOMRectList: false,
        DOMStringList: false,
        DOMTokenList: true,
        DataTransferItemList: false,
        FileList: false,
        HTMLAllCollection: false,
        HTMLCollection: false,
        HTMLFormElement: false,
        HTMLSelectElement: false,
        MediaList: true,
        // TODO: Not spec compliant, should be false.
        MimeTypeArray: false,
        NamedNodeMap: false,
        NodeList: true,
        PaintRequestList: false,
        Plugin: false,
        PluginArray: false,
        SVGLengthList: false,
        SVGNumberList: false,
        SVGPathSegList: false,
        SVGPointList: false,
        SVGStringList: false,
        SVGTransformList: false,
        SourceBufferList: false,
        StyleSheetList: true,
        // TODO: Not spec compliant, should be false.
        TextTrackCueList: false,
        TextTrackList: false,
        TouchList: false
      };

      for (var collections = getKeys(DOMIterables), i = 0; i < collections.length; i++) {
        var NAME = collections[i];
        var explicit = DOMIterables[NAME];
        var Collection = global[NAME];
        var proto = Collection && Collection.prototype;
        var key;

        if (proto) {
          if (!proto[ITERATOR]) hide(proto, ITERATOR, ArrayValues);
          if (!proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME);
          Iterators[NAME] = ArrayValues;
          if (explicit) for (key in $iterators) {
            if (!proto[key]) redefine(proto, key, $iterators[key], true);
          }
        }
      }
    }, {
      "128": 128,
      "141": 141,
      "40": 40,
      "42": 42,
      "58": 58,
      "81": 81,
      "94": 94
    }],
    325: [function (_dereq_, module, exports) {
      var $export = _dereq_(33);

      var $task = _dereq_(113);

      $export($export.G + $export.B, {
        setImmediate: $task.set,
        clearImmediate: $task.clear
      });
    }, {
      "113": 113,
      "33": 33
    }],
    326: [function (_dereq_, module, exports) {
      // ie9- setTimeout & setInterval additional parameters fix
      var global = _dereq_(40);

      var $export = _dereq_(33);

      var invoke = _dereq_(46);

      var partial = _dereq_(88);

      var navigator = global.navigator;
      var MSIE = !!navigator && /MSIE .\./.test(navigator.userAgent); // <- dirty ie9- check

      var wrap = function wrap(set) {
        return MSIE ? function (fn, time
        /* , ...args */
        ) {
          return set(invoke(partial, [].slice.call(arguments, 2), // eslint-disable-next-line no-new-func
          typeof fn == 'function' ? fn : Function(fn)), time);
        } : set;
      };

      $export($export.G + $export.B + $export.F * MSIE, {
        setTimeout: wrap(global.setTimeout),
        setInterval: wrap(global.setInterval)
      });
    }, {
      "33": 33,
      "40": 40,
      "46": 46,
      "88": 88
    }],
    327: [function (_dereq_, module, exports) {
      _dereq_(254);

      _dereq_(191);

      _dereq_(193);

      _dereq_(192);

      _dereq_(195);

      _dereq_(197);

      _dereq_(202);

      _dereq_(196);

      _dereq_(194);

      _dereq_(204);

      _dereq_(203);

      _dereq_(199);

      _dereq_(200);

      _dereq_(198);

      _dereq_(190);

      _dereq_(201);

      _dereq_(205);

      _dereq_(206);

      _dereq_(157);

      _dereq_(159);

      _dereq_(158);

      _dereq_(208);

      _dereq_(207);

      _dereq_(178);

      _dereq_(188);

      _dereq_(189);

      _dereq_(179);

      _dereq_(180);

      _dereq_(181);

      _dereq_(182);

      _dereq_(183);

      _dereq_(184);

      _dereq_(185);

      _dereq_(186);

      _dereq_(187);

      _dereq_(161);

      _dereq_(162);

      _dereq_(163);

      _dereq_(164);

      _dereq_(165);

      _dereq_(166);

      _dereq_(167);

      _dereq_(168);

      _dereq_(169);

      _dereq_(170);

      _dereq_(171);

      _dereq_(172);

      _dereq_(173);

      _dereq_(174);

      _dereq_(175);

      _dereq_(176);

      _dereq_(177);

      _dereq_(241);

      _dereq_(246);

      _dereq_(253);

      _dereq_(244);

      _dereq_(236);

      _dereq_(237);

      _dereq_(242);

      _dereq_(247);

      _dereq_(249);

      _dereq_(232);

      _dereq_(233);

      _dereq_(234);

      _dereq_(235);

      _dereq_(238);

      _dereq_(239);

      _dereq_(240);

      _dereq_(243);

      _dereq_(245);

      _dereq_(248);

      _dereq_(250);

      _dereq_(251);

      _dereq_(252);

      _dereq_(152);

      _dereq_(154);

      _dereq_(153);

      _dereq_(156);

      _dereq_(155);

      _dereq_(140);

      _dereq_(138);

      _dereq_(145);

      _dereq_(142);

      _dereq_(148);

      _dereq_(150);

      _dereq_(137);

      _dereq_(144);

      _dereq_(134);

      _dereq_(149);

      _dereq_(132);

      _dereq_(147);

      _dereq_(146);

      _dereq_(139);

      _dereq_(143);

      _dereq_(131);

      _dereq_(133);

      _dereq_(136);

      _dereq_(135);

      _dereq_(151);

      _dereq_(141);

      _dereq_(224);

      _dereq_(230);

      _dereq_(225);

      _dereq_(226);

      _dereq_(227);

      _dereq_(228);

      _dereq_(229);

      _dereq_(209);

      _dereq_(160);

      _dereq_(231);

      _dereq_(266);

      _dereq_(267);

      _dereq_(255);

      _dereq_(256);

      _dereq_(261);

      _dereq_(264);

      _dereq_(265);

      _dereq_(259);

      _dereq_(262);

      _dereq_(260);

      _dereq_(263);

      _dereq_(257);

      _dereq_(258);

      _dereq_(210);

      _dereq_(211);

      _dereq_(212);

      _dereq_(213);

      _dereq_(214);

      _dereq_(217);

      _dereq_(215);

      _dereq_(216);

      _dereq_(218);

      _dereq_(219);

      _dereq_(220);

      _dereq_(221);

      _dereq_(223);

      _dereq_(222);

      _dereq_(270);

      _dereq_(268);

      _dereq_(269);

      _dereq_(311);

      _dereq_(314);

      _dereq_(313);

      _dereq_(315);

      _dereq_(316);

      _dereq_(312);

      _dereq_(317);

      _dereq_(318);

      _dereq_(292);

      _dereq_(295);

      _dereq_(291);

      _dereq_(289);

      _dereq_(290);

      _dereq_(293);

      _dereq_(294);

      _dereq_(276);

      _dereq_(310);

      _dereq_(275);

      _dereq_(309);

      _dereq_(321);

      _dereq_(323);

      _dereq_(274);

      _dereq_(308);

      _dereq_(320);

      _dereq_(322);

      _dereq_(273);

      _dereq_(319);

      _dereq_(272);

      _dereq_(277);

      _dereq_(278);

      _dereq_(279);

      _dereq_(280);

      _dereq_(281);

      _dereq_(283);

      _dereq_(282);

      _dereq_(284);

      _dereq_(285);

      _dereq_(286);

      _dereq_(288);

      _dereq_(287);

      _dereq_(297);

      _dereq_(298);

      _dereq_(299);

      _dereq_(300);

      _dereq_(302);

      _dereq_(301);

      _dereq_(304);

      _dereq_(303);

      _dereq_(305);

      _dereq_(306);

      _dereq_(307);

      _dereq_(271);

      _dereq_(296);

      _dereq_(326);

      _dereq_(325);

      _dereq_(324);

      module.exports = _dereq_(23);
    }, {
      "131": 131,
      "132": 132,
      "133": 133,
      "134": 134,
      "135": 135,
      "136": 136,
      "137": 137,
      "138": 138,
      "139": 139,
      "140": 140,
      "141": 141,
      "142": 142,
      "143": 143,
      "144": 144,
      "145": 145,
      "146": 146,
      "147": 147,
      "148": 148,
      "149": 149,
      "150": 150,
      "151": 151,
      "152": 152,
      "153": 153,
      "154": 154,
      "155": 155,
      "156": 156,
      "157": 157,
      "158": 158,
      "159": 159,
      "160": 160,
      "161": 161,
      "162": 162,
      "163": 163,
      "164": 164,
      "165": 165,
      "166": 166,
      "167": 167,
      "168": 168,
      "169": 169,
      "170": 170,
      "171": 171,
      "172": 172,
      "173": 173,
      "174": 174,
      "175": 175,
      "176": 176,
      "177": 177,
      "178": 178,
      "179": 179,
      "180": 180,
      "181": 181,
      "182": 182,
      "183": 183,
      "184": 184,
      "185": 185,
      "186": 186,
      "187": 187,
      "188": 188,
      "189": 189,
      "190": 190,
      "191": 191,
      "192": 192,
      "193": 193,
      "194": 194,
      "195": 195,
      "196": 196,
      "197": 197,
      "198": 198,
      "199": 199,
      "200": 200,
      "201": 201,
      "202": 202,
      "203": 203,
      "204": 204,
      "205": 205,
      "206": 206,
      "207": 207,
      "208": 208,
      "209": 209,
      "210": 210,
      "211": 211,
      "212": 212,
      "213": 213,
      "214": 214,
      "215": 215,
      "216": 216,
      "217": 217,
      "218": 218,
      "219": 219,
      "220": 220,
      "221": 221,
      "222": 222,
      "223": 223,
      "224": 224,
      "225": 225,
      "226": 226,
      "227": 227,
      "228": 228,
      "229": 229,
      "23": 23,
      "230": 230,
      "231": 231,
      "232": 232,
      "233": 233,
      "234": 234,
      "235": 235,
      "236": 236,
      "237": 237,
      "238": 238,
      "239": 239,
      "240": 240,
      "241": 241,
      "242": 242,
      "243": 243,
      "244": 244,
      "245": 245,
      "246": 246,
      "247": 247,
      "248": 248,
      "249": 249,
      "250": 250,
      "251": 251,
      "252": 252,
      "253": 253,
      "254": 254,
      "255": 255,
      "256": 256,
      "257": 257,
      "258": 258,
      "259": 259,
      "260": 260,
      "261": 261,
      "262": 262,
      "263": 263,
      "264": 264,
      "265": 265,
      "266": 266,
      "267": 267,
      "268": 268,
      "269": 269,
      "270": 270,
      "271": 271,
      "272": 272,
      "273": 273,
      "274": 274,
      "275": 275,
      "276": 276,
      "277": 277,
      "278": 278,
      "279": 279,
      "280": 280,
      "281": 281,
      "282": 282,
      "283": 283,
      "284": 284,
      "285": 285,
      "286": 286,
      "287": 287,
      "288": 288,
      "289": 289,
      "290": 290,
      "291": 291,
      "292": 292,
      "293": 293,
      "294": 294,
      "295": 295,
      "296": 296,
      "297": 297,
      "298": 298,
      "299": 299,
      "300": 300,
      "301": 301,
      "302": 302,
      "303": 303,
      "304": 304,
      "305": 305,
      "306": 306,
      "307": 307,
      "308": 308,
      "309": 309,
      "310": 310,
      "311": 311,
      "312": 312,
      "313": 313,
      "314": 314,
      "315": 315,
      "316": 316,
      "317": 317,
      "318": 318,
      "319": 319,
      "320": 320,
      "321": 321,
      "322": 322,
      "323": 323,
      "324": 324,
      "325": 325,
      "326": 326
    }],
    328: [function (_dereq_, module, exports) {
      (function (global) {
        /**
         * Copyright (c) 2014, Facebook, Inc.
         * All rights reserved.
         *
         * This source code is licensed under the BSD-style license found in the
         * https://raw.github.com/facebook/regenerator/master/LICENSE file. An
         * additional grant of patent rights can be found in the PATENTS file in
         * the same directory.
         */
        !function (global) {

          var Op = Object.prototype;
          var hasOwn = Op.hasOwnProperty;
          var undefined$1; // More compressible than void 0.

          var $Symbol = typeof Symbol === "function" ? Symbol : {};
          var iteratorSymbol = $Symbol.iterator || "@@iterator";
          var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
          var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
          var inModule = _typeof(module) === "object";
          var runtime = global.regeneratorRuntime;

          if (runtime) {
            if (inModule) {
              // If regeneratorRuntime is defined globally and we're in a module,
              // make the exports object identical to regeneratorRuntime.
              module.exports = runtime;
            } // Don't bother evaluating the rest of this file if the runtime was
            // already defined globally.


            return;
          } // Define the runtime globally (as expected by generated code) as either
          // module.exports (if we're in a module) or a new, empty object.


          runtime = global.regeneratorRuntime = inModule ? module.exports : {};

          function wrap(innerFn, outerFn, self, tryLocsList) {
            // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
            var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
            var generator = Object.create(protoGenerator.prototype);
            var context = new Context(tryLocsList || []); // The ._invoke method unifies the implementations of the .next,
            // .throw, and .return methods.

            generator._invoke = makeInvokeMethod(innerFn, self, context);
            return generator;
          }

          runtime.wrap = wrap; // Try/catch helper to minimize deoptimizations. Returns a completion
          // record like context.tryEntries[i].completion. This interface could
          // have been (and was previously) designed to take a closure to be
          // invoked without arguments, but in all the cases we care about we
          // already have an existing method we want to call, so there's no need
          // to create a new function object. We can even get away with assuming
          // the method takes exactly one argument, since that happens to be true
          // in every case, so we don't have to touch the arguments object. The
          // only additional allocation required is the completion record, which
          // has a stable shape and so hopefully should be cheap to allocate.

          function tryCatch(fn, obj, arg) {
            try {
              return {
                type: "normal",
                arg: fn.call(obj, arg)
              };
            } catch (err) {
              return {
                type: "throw",
                arg: err
              };
            }
          }

          var GenStateSuspendedStart = "suspendedStart";
          var GenStateSuspendedYield = "suspendedYield";
          var GenStateExecuting = "executing";
          var GenStateCompleted = "completed"; // Returning this object from the innerFn has the same effect as
          // breaking out of the dispatch switch statement.

          var ContinueSentinel = {}; // Dummy constructor functions that we use as the .constructor and
          // .constructor.prototype properties for functions that return Generator
          // objects. For full spec compliance, you may wish to configure your
          // minifier not to mangle the names of these two functions.

          function Generator() {}

          function GeneratorFunction() {}

          function GeneratorFunctionPrototype() {} // This is a polyfill for %IteratorPrototype% for environments that
          // don't natively support it.


          var IteratorPrototype = {};

          IteratorPrototype[iteratorSymbol] = function () {
            return this;
          };

          var getProto = Object.getPrototypeOf;
          var NativeIteratorPrototype = getProto && getProto(getProto(values([])));

          if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
            // This environment has a native %IteratorPrototype%; use it instead
            // of the polyfill.
            IteratorPrototype = NativeIteratorPrototype;
          }

          var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
          GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
          GeneratorFunctionPrototype.constructor = GeneratorFunction;
          GeneratorFunctionPrototype[toStringTagSymbol] = GeneratorFunction.displayName = "GeneratorFunction"; // Helper for defining the .next, .throw, and .return methods of the
          // Iterator interface in terms of a single ._invoke method.

          function defineIteratorMethods(prototype) {
            ["next", "throw", "return"].forEach(function (method) {
              prototype[method] = function (arg) {
                return this._invoke(method, arg);
              };
            });
          }

          runtime.isGeneratorFunction = function (genFun) {
            var ctor = typeof genFun === "function" && genFun.constructor;
            return ctor ? ctor === GeneratorFunction || // For the native GeneratorFunction constructor, the best we can
            // do is to check its .name property.
            (ctor.displayName || ctor.name) === "GeneratorFunction" : false;
          };

          runtime.mark = function (genFun) {
            if (Object.setPrototypeOf) {
              Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
            } else {
              genFun.__proto__ = GeneratorFunctionPrototype;

              if (!(toStringTagSymbol in genFun)) {
                genFun[toStringTagSymbol] = "GeneratorFunction";
              }
            }

            genFun.prototype = Object.create(Gp);
            return genFun;
          }; // Within the body of any async function, `await x` is transformed to
          // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
          // `hasOwn.call(value, "__await")` to determine if the yielded value is
          // meant to be awaited.


          runtime.awrap = function (arg) {
            return {
              __await: arg
            };
          };

          function AsyncIterator(generator) {
            function invoke(method, arg, resolve, reject) {
              var record = tryCatch(generator[method], generator, arg);

              if (record.type === "throw") {
                reject(record.arg);
              } else {
                var result = record.arg;
                var value = result.value;

                if (value && _typeof(value) === "object" && hasOwn.call(value, "__await")) {
                  return Promise.resolve(value.__await).then(function (value) {
                    invoke("next", value, resolve, reject);
                  }, function (err) {
                    invoke("throw", err, resolve, reject);
                  });
                }

                return Promise.resolve(value).then(function (unwrapped) {
                  // When a yielded Promise is resolved, its final value becomes
                  // the .value of the Promise<{value,done}> result for the
                  // current iteration. If the Promise is rejected, however, the
                  // result for this iteration will be rejected with the same
                  // reason. Note that rejections of yielded Promises are not
                  // thrown back into the generator function, as is the case
                  // when an awaited Promise is rejected. This difference in
                  // behavior between yield and await is important, because it
                  // allows the consumer to decide what to do with the yielded
                  // rejection (swallow it and continue, manually .throw it back
                  // into the generator, abandon iteration, whatever). With
                  // await, by contrast, there is no opportunity to examine the
                  // rejection reason outside the generator function, so the
                  // only option is to throw it from the await expression, and
                  // let the generator function handle the exception.
                  result.value = unwrapped;
                  resolve(result);
                }, reject);
              }
            }

            if (_typeof(global.process) === "object" && global.process.domain) {
              invoke = global.process.domain.bind(invoke);
            }

            var previousPromise;

            function enqueue(method, arg) {
              function callInvokeWithMethodAndArg() {
                return new Promise(function (resolve, reject) {
                  invoke(method, arg, resolve, reject);
                });
              }

              return previousPromise = // If enqueue has been called before, then we want to wait until
              // all previous Promises have been resolved before calling invoke,
              // so that results are always delivered in the correct order. If
              // enqueue has not been called before, then it is important to
              // call invoke immediately, without waiting on a callback to fire,
              // so that the async generator function has the opportunity to do
              // any necessary setup in a predictable way. This predictability
              // is why the Promise constructor synchronously invokes its
              // executor callback, and why async functions synchronously
              // execute code before the first await. Since we implement simple
              // async functions in terms of async generators, it is especially
              // important to get this right, even though it requires care.
              previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, // Avoid propagating failures to Promises returned by later
              // invocations of the iterator.
              callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
            } // Define the unified helper method that is used to implement .next,
            // .throw, and .return (see defineIteratorMethods).


            this._invoke = enqueue;
          }

          defineIteratorMethods(AsyncIterator.prototype);

          AsyncIterator.prototype[asyncIteratorSymbol] = function () {
            return this;
          };

          runtime.AsyncIterator = AsyncIterator; // Note that simple async functions are implemented on top of
          // AsyncIterator objects; they just return a Promise for the value of
          // the final result produced by the iterator.

          runtime.async = function (innerFn, outerFn, self, tryLocsList) {
            var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList));
            return runtime.isGeneratorFunction(outerFn) ? iter // If outerFn is a generator, return the full iterator.
            : iter.next().then(function (result) {
              return result.done ? result.value : iter.next();
            });
          };

          function makeInvokeMethod(innerFn, self, context) {
            var state = GenStateSuspendedStart;
            return function invoke(method, arg) {
              if (state === GenStateExecuting) {
                throw new Error("Generator is already running");
              }

              if (state === GenStateCompleted) {
                if (method === "throw") {
                  throw arg;
                } // Be forgiving, per 25.3.3.3.3 of the spec:
                // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume


                return doneResult();
              }

              context.method = method;
              context.arg = arg;

              while (true) {
                var delegate = context.delegate;

                if (delegate) {
                  var delegateResult = maybeInvokeDelegate(delegate, context);

                  if (delegateResult) {
                    if (delegateResult === ContinueSentinel) continue;
                    return delegateResult;
                  }
                }

                if (context.method === "next") {
                  // Setting context._sent for legacy support of Babel's
                  // function.sent implementation.
                  context.sent = context._sent = context.arg;
                } else if (context.method === "throw") {
                  if (state === GenStateSuspendedStart) {
                    state = GenStateCompleted;
                    throw context.arg;
                  }

                  context.dispatchException(context.arg);
                } else if (context.method === "return") {
                  context.abrupt("return", context.arg);
                }

                state = GenStateExecuting;
                var record = tryCatch(innerFn, self, context);

                if (record.type === "normal") {
                  // If an exception is thrown from innerFn, we leave state ===
                  // GenStateExecuting and loop back for another invocation.
                  state = context.done ? GenStateCompleted : GenStateSuspendedYield;

                  if (record.arg === ContinueSentinel) {
                    continue;
                  }

                  return {
                    value: record.arg,
                    done: context.done
                  };
                } else if (record.type === "throw") {
                  state = GenStateCompleted; // Dispatch the exception by looping back around to the
                  // context.dispatchException(context.arg) call above.

                  context.method = "throw";
                  context.arg = record.arg;
                }
              }
            };
          } // Call delegate.iterator[context.method](context.arg) and handle the
          // result, either by returning a { value, done } result from the
          // delegate iterator, or by modifying context.method and context.arg,
          // setting context.delegate to null, and returning the ContinueSentinel.


          function maybeInvokeDelegate(delegate, context) {
            var method = delegate.iterator[context.method];

            if (method === undefined$1) {
              // A .throw or .return when the delegate iterator has no .throw
              // method always terminates the yield* loop.
              context.delegate = null;

              if (context.method === "throw") {
                if (delegate.iterator["return"]) {
                  // If the delegate iterator has a return method, give it a
                  // chance to clean up.
                  context.method = "return";
                  context.arg = undefined$1;
                  maybeInvokeDelegate(delegate, context);

                  if (context.method === "throw") {
                    // If maybeInvokeDelegate(context) changed context.method from
                    // "return" to "throw", let that override the TypeError below.
                    return ContinueSentinel;
                  }
                }

                context.method = "throw";
                context.arg = new TypeError("The iterator does not provide a 'throw' method");
              }

              return ContinueSentinel;
            }

            var record = tryCatch(method, delegate.iterator, context.arg);

            if (record.type === "throw") {
              context.method = "throw";
              context.arg = record.arg;
              context.delegate = null;
              return ContinueSentinel;
            }

            var info = record.arg;

            if (!info) {
              context.method = "throw";
              context.arg = new TypeError("iterator result is not an object");
              context.delegate = null;
              return ContinueSentinel;
            }

            if (info.done) {
              // Assign the result of the finished delegate to the temporary
              // variable specified by delegate.resultName (see delegateYield).
              context[delegate.resultName] = info.value; // Resume execution at the desired location (see delegateYield).

              context.next = delegate.nextLoc; // If context.method was "throw" but the delegate handled the
              // exception, let the outer generator proceed normally. If
              // context.method was "next", forget context.arg since it has been
              // "consumed" by the delegate iterator. If context.method was
              // "return", allow the original .return call to continue in the
              // outer generator.

              if (context.method !== "return") {
                context.method = "next";
                context.arg = undefined$1;
              }
            } else {
              // Re-yield the result returned by the delegate method.
              return info;
            } // The delegate iterator is finished, so forget it and continue with
            // the outer generator.


            context.delegate = null;
            return ContinueSentinel;
          } // Define Generator.prototype.{next,throw,return} in terms of the
          // unified ._invoke helper method.


          defineIteratorMethods(Gp);
          Gp[toStringTagSymbol] = "Generator"; // A Generator should always return itself as the iterator object when the
          // @@iterator function is called on it. Some browsers' implementations of the
          // iterator prototype chain incorrectly implement this, causing the Generator
          // object to not be returned from this call. This ensures that doesn't happen.
          // See https://github.com/facebook/regenerator/issues/274 for more details.

          Gp[iteratorSymbol] = function () {
            return this;
          };

          Gp.toString = function () {
            return "[object Generator]";
          };

          function pushTryEntry(locs) {
            var entry = {
              tryLoc: locs[0]
            };

            if (1 in locs) {
              entry.catchLoc = locs[1];
            }

            if (2 in locs) {
              entry.finallyLoc = locs[2];
              entry.afterLoc = locs[3];
            }

            this.tryEntries.push(entry);
          }

          function resetTryEntry(entry) {
            var record = entry.completion || {};
            record.type = "normal";
            delete record.arg;
            entry.completion = record;
          }

          function Context(tryLocsList) {
            // The root entry object (effectively a try statement without a catch
            // or a finally block) gives us a place to store values thrown from
            // locations where there is no enclosing try statement.
            this.tryEntries = [{
              tryLoc: "root"
            }];
            tryLocsList.forEach(pushTryEntry, this);
            this.reset(true);
          }

          runtime.keys = function (object) {
            var keys = [];

            for (var key in object) {
              keys.push(key);
            }

            keys.reverse(); // Rather than returning an object with a next method, we keep
            // things simple and return the next function itself.

            return function next() {
              while (keys.length) {
                var key = keys.pop();

                if (key in object) {
                  next.value = key;
                  next.done = false;
                  return next;
                }
              } // To avoid creating an additional object, we just hang the .value
              // and .done properties off the next function object itself. This
              // also ensures that the minifier will not anonymize the function.


              next.done = true;
              return next;
            };
          };

          function values(iterable) {
            if (iterable) {
              var iteratorMethod = iterable[iteratorSymbol];

              if (iteratorMethod) {
                return iteratorMethod.call(iterable);
              }

              if (typeof iterable.next === "function") {
                return iterable;
              }

              if (!isNaN(iterable.length)) {
                var i = -1,
                    next = function next() {
                  while (++i < iterable.length) {
                    if (hasOwn.call(iterable, i)) {
                      next.value = iterable[i];
                      next.done = false;
                      return next;
                    }
                  }

                  next.value = undefined$1;
                  next.done = true;
                  return next;
                };

                return next.next = next;
              }
            } // Return an iterator with no values.


            return {
              next: doneResult
            };
          }

          runtime.values = values;

          function doneResult() {
            return {
              value: undefined$1,
              done: true
            };
          }

          Context.prototype = {
            constructor: Context,
            reset: function reset(skipTempReset) {
              this.prev = 0;
              this.next = 0; // Resetting context._sent for legacy support of Babel's
              // function.sent implementation.

              this.sent = this._sent = undefined$1;
              this.done = false;
              this.delegate = null;
              this.method = "next";
              this.arg = undefined$1;
              this.tryEntries.forEach(resetTryEntry);

              if (!skipTempReset) {
                for (var name in this) {
                  // Not sure about the optimal order of these conditions:
                  if (name.charAt(0) === "t" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {
                    this[name] = undefined$1;
                  }
                }
              }
            },
            stop: function stop() {
              this.done = true;
              var rootEntry = this.tryEntries[0];
              var rootRecord = rootEntry.completion;

              if (rootRecord.type === "throw") {
                throw rootRecord.arg;
              }

              return this.rval;
            },
            dispatchException: function dispatchException(exception) {
              if (this.done) {
                throw exception;
              }

              var context = this;

              function handle(loc, caught) {
                record.type = "throw";
                record.arg = exception;
                context.next = loc;

                if (caught) {
                  // If the dispatched exception was caught by a catch block,
                  // then let that catch block handle the exception normally.
                  context.method = "next";
                  context.arg = undefined$1;
                }

                return !!caught;
              }

              for (var i = this.tryEntries.length - 1; i >= 0; --i) {
                var entry = this.tryEntries[i];
                var record = entry.completion;

                if (entry.tryLoc === "root") {
                  // Exception thrown outside of any try block that could handle
                  // it, so set the completion value of the entire function to
                  // throw the exception.
                  return handle("end");
                }

                if (entry.tryLoc <= this.prev) {
                  var hasCatch = hasOwn.call(entry, "catchLoc");
                  var hasFinally = hasOwn.call(entry, "finallyLoc");

                  if (hasCatch && hasFinally) {
                    if (this.prev < entry.catchLoc) {
                      return handle(entry.catchLoc, true);
                    } else if (this.prev < entry.finallyLoc) {
                      return handle(entry.finallyLoc);
                    }
                  } else if (hasCatch) {
                    if (this.prev < entry.catchLoc) {
                      return handle(entry.catchLoc, true);
                    }
                  } else if (hasFinally) {
                    if (this.prev < entry.finallyLoc) {
                      return handle(entry.finallyLoc);
                    }
                  } else {
                    throw new Error("try statement without catch or finally");
                  }
                }
              }
            },
            abrupt: function abrupt(type, arg) {
              for (var i = this.tryEntries.length - 1; i >= 0; --i) {
                var entry = this.tryEntries[i];

                if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
                  var finallyEntry = entry;
                  break;
                }
              }

              if (finallyEntry && (type === "break" || type === "continue") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {
                // Ignore the finally entry if control is not jumping to a
                // location outside the try/catch block.
                finallyEntry = null;
              }

              var record = finallyEntry ? finallyEntry.completion : {};
              record.type = type;
              record.arg = arg;

              if (finallyEntry) {
                this.method = "next";
                this.next = finallyEntry.finallyLoc;
                return ContinueSentinel;
              }

              return this.complete(record);
            },
            complete: function complete(record, afterLoc) {
              if (record.type === "throw") {
                throw record.arg;
              }

              if (record.type === "break" || record.type === "continue") {
                this.next = record.arg;
              } else if (record.type === "return") {
                this.rval = this.arg = record.arg;
                this.method = "return";
                this.next = "end";
              } else if (record.type === "normal" && afterLoc) {
                this.next = afterLoc;
              }

              return ContinueSentinel;
            },
            finish: function finish(finallyLoc) {
              for (var i = this.tryEntries.length - 1; i >= 0; --i) {
                var entry = this.tryEntries[i];

                if (entry.finallyLoc === finallyLoc) {
                  this.complete(entry.completion, entry.afterLoc);
                  resetTryEntry(entry);
                  return ContinueSentinel;
                }
              }
            },
            "catch": function _catch(tryLoc) {
              for (var i = this.tryEntries.length - 1; i >= 0; --i) {
                var entry = this.tryEntries[i];

                if (entry.tryLoc === tryLoc) {
                  var record = entry.completion;

                  if (record.type === "throw") {
                    var thrown = record.arg;
                    resetTryEntry(entry);
                  }

                  return thrown;
                }
              } // The context.catch method must only be called with a location
              // argument that corresponds to a known catch block.


              throw new Error("illegal catch attempt");
            },
            delegateYield: function delegateYield(iterable, resultName, nextLoc) {
              this.delegate = {
                iterator: values(iterable),
                resultName: resultName,
                nextLoc: nextLoc
              };

              if (this.method === "next") {
                // Deliberately forget the last sent value so that we don't
                // accidentally pass it on to the delegate.
                this.arg = undefined$1;
              }

              return ContinueSentinel;
            }
          };
        }( // Among the various tricks for obtaining a reference to the global
        // object, this seems to be the most reliable technique that does not
        // use indirect eval (which violates Content Security Policy).
        _typeof(global) === "object" ? global : (typeof window === "undefined" ? "undefined" : _typeof(window)) === "object" ? window : (typeof self === "undefined" ? "undefined" : _typeof(self)) === "object" ? self : this);
      }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
    }, {}]
  }, {}, [1]);

  /* */

  (function (self) {

    if (self.fetch) {
      return;
    }

    var support = {
      searchParams: 'URLSearchParams' in self,
      iterable: 'Symbol' in self && 'iterator' in Symbol,
      blob: 'FileReader' in self && 'Blob' in self && function () {
        try {
          new Blob();
          return true;
        } catch (e) {
          return false;
        }
      }(),
      formData: 'FormData' in self,
      arrayBuffer: 'ArrayBuffer' in self
    };

    if (support.arrayBuffer) {
      var viewClasses = ['[object Int8Array]', '[object Uint8Array]', '[object Uint8ClampedArray]', '[object Int16Array]', '[object Uint16Array]', '[object Int32Array]', '[object Uint32Array]', '[object Float32Array]', '[object Float64Array]'];

      var isDataView = function isDataView(obj) {
        return obj && DataView.prototype.isPrototypeOf(obj);
      };

      var isArrayBufferView = ArrayBuffer.isView || function (obj) {
        return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1;
      };
    }

    function normalizeName(name) {
      if (typeof name !== 'string') {
        name = String(name);
      }

      if (/[^a-z0-9\-#$%&'*+.\^_`|~]/i.test(name)) {
        throw new TypeError('Invalid character in header field name');
      }

      return name.toLowerCase();
    }

    function normalizeValue(value) {
      if (typeof value !== 'string') {
        value = String(value);
      }

      return value;
    } // Build a destructive iterator for the value list


    function iteratorFor(items) {
      var iterator = {
        next: function next() {
          var value = items.shift();
          return {
            done: value === undefined,
            value: value
          };
        }
      };

      if (support.iterable) {
        iterator[Symbol.iterator] = function () {
          return iterator;
        };
      }

      return iterator;
    }

    function Headers(headers) {
      this.map = {};

      if (headers instanceof Headers) {
        headers.forEach(function (value, name) {
          this.append(name, value);
        }, this);
      } else if (headers) {
        Object.getOwnPropertyNames(headers).forEach(function (name) {
          this.append(name, headers[name]);
        }, this);
      }
    }

    Headers.prototype.append = function (name, value) {
      name = normalizeName(name);
      value = normalizeValue(value);
      var list = this.map[name];

      if (!list) {
        list = [];
        this.map[name] = list;
      }

      list.push(value);
    };

    Headers.prototype['delete'] = function (name) {
      delete this.map[normalizeName(name)];
    };

    Headers.prototype.get = function (name) {
      var values = this.map[normalizeName(name)];
      return values ? values[0] : null;
    };

    Headers.prototype.getAll = function (name) {
      return this.map[normalizeName(name)] || [];
    };

    Headers.prototype.has = function (name) {
      return this.map.hasOwnProperty(normalizeName(name));
    };

    Headers.prototype.set = function (name, value) {
      this.map[normalizeName(name)] = [normalizeValue(value)];
    };

    Headers.prototype.forEach = function (callback, thisArg) {
      Object.getOwnPropertyNames(this.map).forEach(function (name) {
        this.map[name].forEach(function (value) {
          callback.call(thisArg, value, name, this);
        }, this);
      }, this);
    };

    Headers.prototype.keys = function () {
      var items = [];
      this.forEach(function (value, name) {
        items.push(name);
      });
      return iteratorFor(items);
    };

    Headers.prototype.values = function () {
      var items = [];
      this.forEach(function (value) {
        items.push(value);
      });
      return iteratorFor(items);
    };

    Headers.prototype.entries = function () {
      var items = [];
      this.forEach(function (value, name) {
        items.push([name, value]);
      });
      return iteratorFor(items);
    };

    if (support.iterable) {
      Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
    }

    function consumed(body) {
      if (body.bodyUsed) {
        return Promise.reject(new TypeError('Already read'));
      }

      body.bodyUsed = true;
    }

    function fileReaderReady(reader) {
      return new Promise(function (resolve, reject) {
        reader.onload = function () {
          resolve(reader.result);
        };

        reader.onerror = function () {
          reject(reader.error);
        };
      });
    }

    function readBlobAsArrayBuffer(blob) {
      var reader = new FileReader();
      var promise = fileReaderReady(reader);
      reader.readAsArrayBuffer(blob);
      return promise;
    }

    function readBlobAsText(blob) {
      var reader = new FileReader();
      var promise = fileReaderReady(reader);
      reader.readAsText(blob);
      return promise;
    }

    function readArrayBufferAsText(buf) {
      var view = new Uint8Array(buf);
      var chars = new Array(view.length);

      for (var i = 0; i < view.length; i++) {
        chars[i] = String.fromCharCode(view[i]);
      }

      return chars.join('');
    }

    function bufferClone(buf) {
      if (buf.slice) {
        return buf.slice(0);
      } else {
        var view = new Uint8Array(buf.byteLength);
        view.set(new Uint8Array(buf));
        return view.buffer;
      }
    }

    function Body() {
      this.bodyUsed = false;

      this._initBody = function (body) {
        this._bodyInit = body;

        if (!body) {
          this._bodyText = '';
        } else if (typeof body === 'string') {
          this._bodyText = body;
        } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
          this._bodyBlob = body;
        } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
          this._bodyFormData = body;
        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
          this._bodyText = body.toString();
        } else if (support.arrayBuffer && support.blob && isDataView(body)) {
          this._bodyArrayBuffer = bufferClone(body.buffer); // IE 10-11 can't handle a DataView body.

          this._bodyInit = new Blob([this._bodyArrayBuffer]);
        } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
          this._bodyArrayBuffer = bufferClone(body);
        } else {
          throw new Error('unsupported BodyInit type');
        }

        if (!this.headers.get('content-type')) {
          if (typeof body === 'string') {
            this.headers.set('content-type', 'text/plain;charset=UTF-8');
          } else if (this._bodyBlob && this._bodyBlob.type) {
            this.headers.set('content-type', this._bodyBlob.type);
          } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
            this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');
          }
        }
      };

      if (support.blob) {
        this.blob = function () {
          var rejected = consumed(this);

          if (rejected) {
            return rejected;
          }

          if (this._bodyBlob) {
            return Promise.resolve(this._bodyBlob);
          } else if (this._bodyArrayBuffer) {
            return Promise.resolve(new Blob([this._bodyArrayBuffer]));
          } else if (this._bodyFormData) {
            throw new Error('could not read FormData body as blob');
          } else {
            return Promise.resolve(new Blob([this._bodyText]));
          }
        };

        this.arrayBuffer = function () {
          if (this._bodyArrayBuffer) {
            return consumed(this) || Promise.resolve(this._bodyArrayBuffer);
          } else {
            return this.blob().then(readBlobAsArrayBuffer);
          }
        };
      }

      this.text = function () {
        var rejected = consumed(this);

        if (rejected) {
          return rejected;
        }

        if (this._bodyBlob) {
          return readBlobAsText(this._bodyBlob);
        } else if (this._bodyArrayBuffer) {
          return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer));
        } else if (this._bodyFormData) {
          throw new Error('could not read FormData body as text');
        } else {
          return Promise.resolve(this._bodyText);
        }
      };

      if (support.formData) {
        this.formData = function () {
          return this.text().then(decode);
        };
      }

      this.json = function () {
        return this.text().then(JSON.parse);
      };

      return this;
    } // HTTP methods whose capitalization should be normalized


    var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT'];

    function normalizeMethod(method) {
      var upcased = method.toUpperCase();
      return methods.indexOf(upcased) > -1 ? upcased : method;
    }

    function Request(input, options) {
      options = options || {};
      var body = options.body;

      if (typeof input === 'string') {
        this.url = input;
      } else {
        if (input.bodyUsed) {
          throw new TypeError('Already read');
        }

        this.url = input.url;
        this.credentials = input.credentials;

        if (!options.headers) {
          this.headers = new Headers(input.headers);
        }

        this.method = input.method;
        this.mode = input.mode;

        if (!body && input._bodyInit != null) {
          body = input._bodyInit;
          input.bodyUsed = true;
        }
      }

      this.credentials = options.credentials || this.credentials || 'omit';

      if (options.headers || !this.headers) {
        this.headers = new Headers(options.headers);
      }

      this.method = normalizeMethod(options.method || this.method || 'GET');
      this.mode = options.mode || this.mode || null;
      this.referrer = null;

      if ((this.method === 'GET' || this.method === 'HEAD') && body) {
        throw new TypeError('Body not allowed for GET or HEAD requests');
      }

      this._initBody(body);
    }

    Request.prototype.clone = function () {
      return new Request(this, {
        body: this._bodyInit
      });
    };

    function decode(body) {
      var form = new FormData();
      body.trim().split('&').forEach(function (bytes) {
        if (bytes) {
          var split = bytes.split('=');
          var name = split.shift().replace(/\+/g, ' ');
          var value = split.join('=').replace(/\+/g, ' ');
          form.append(decodeURIComponent(name), decodeURIComponent(value));
        }
      });
      return form;
    }

    function parseHeaders(rawHeaders) {
      var headers = new Headers();
      rawHeaders.split('\r\n').forEach(function (line) {
        var parts = line.split(':');
        var key = parts.shift().trim();

        if (key) {
          var value = parts.join(':').trim();
          headers.append(key, value);
        }
      });
      return headers;
    }

    Body.call(Request.prototype);

    function Response(bodyInit, options) {
      if (!options) {
        options = {};
      }

      this.type = 'default';
      this.status = 'status' in options ? options.status : 200;
      this.ok = this.status >= 200 && this.status < 300;
      this.statusText = 'statusText' in options ? options.statusText : 'OK';
      this.headers = new Headers(options.headers);
      this.url = options.url || '';

      this._initBody(bodyInit);
    }

    Body.call(Response.prototype);

    Response.prototype.clone = function () {
      return new Response(this._bodyInit, {
        status: this.status,
        statusText: this.statusText,
        headers: new Headers(this.headers),
        url: this.url
      });
    };

    Response.error = function () {
      var response = new Response(null, {
        status: 0,
        statusText: ''
      });
      response.type = 'error';
      return response;
    };

    var redirectStatuses = [301, 302, 303, 307, 308];

    Response.redirect = function (url, status) {
      if (redirectStatuses.indexOf(status) === -1) {
        throw new RangeError('Invalid status code');
      }

      return new Response(null, {
        status: status,
        headers: {
          location: url
        }
      });
    };

    self.Headers = Headers;
    self.Request = Request;
    self.Response = Response;

    self.fetch = function (input, init) {
      return new Promise(function (resolve, reject) {
        var request = new Request(input, init);
        var xhr = new XMLHttpRequest();

        xhr.onload = function () {
          var options = {
            status: xhr.status,
            statusText: xhr.statusText,
            headers: parseHeaders(xhr.getAllResponseHeaders() || '')
          };
          options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL');
          var body = 'response' in xhr ? xhr.response : xhr.responseText;
          resolve(new Response(body, options));
        };

        xhr.onerror = function () {
          reject(new TypeError('Network request failed'));
        };

        xhr.ontimeout = function () {
          reject(new TypeError('Network request failed'));
        };

        xhr.open(request.method, request.url, true);

        if (request.credentials === 'include') {
          xhr.withCredentials = true;
        }

        if ('responseType' in xhr && support.blob) {
          xhr.responseType = 'blob';
        }

        request.headers.forEach(function (value, name) {
          xhr.setRequestHeader(name, value);
        });
        xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit);
      });
    };

    self.fetch.polyfill = true;
  })(typeof self !== 'undefined' ? self : undefined);

  (function () {
    /**
     * @preserve FastClick: polyfill to remove click delays on browsers with touch UIs.
     *
     * @codingstandard ftlabs-jsv2
     * @copyright The Financial Times Limited [All Rights Reserved]
     * @license MIT License (see LICENSE.txt)
     */

    /*jslint browser:true, node:true*/

    /*global define, Event, Node*/

    /**
     * Instantiate fast-clicking listeners on the specified layer.
     *
     * @constructor
     * @param {Element} layer The layer to listen on
     * @param {Object} [options={}] The options to override the defaults
     */

    function FastClick(layer, options) {
      var oldOnClick;
      options = options || {};
      /**
       * Whether a click is currently being tracked.
       *
       * @type boolean
       */

      this.trackingClick = false;
      /**
       * Timestamp for when click tracking started.
       *
       * @type number
       */

      this.trackingClickStart = 0;
      /**
       * The element being tracked for a click.
       *
       * @type EventTarget
       */

      this.targetElement = null;
      /**
       * X-coordinate of touch start event.
       *
       * @type number
       */

      this.touchStartX = 0;
      /**
       * Y-coordinate of touch start event.
       *
       * @type number
       */

      this.touchStartY = 0;
      /**
       * ID of the last touch, retrieved from Touch.identifier.
       *
       * @type number
       */

      this.lastTouchIdentifier = 0;
      /**
       * Touchmove boundary, beyond which a click will be cancelled.
       *
       * @type number
       */

      this.touchBoundary = options.touchBoundary || 10;
      /**
       * The FastClick layer.
       *
       * @type Element
       */

      this.layer = layer;
      /**
       * The minimum time between tap(touchstart and touchend) events
       *
       * @type number
       */

      this.tapDelay = options.tapDelay || 200;
      /**
       * The maximum time for a tap
       *
       * @type number
       */

      this.tapTimeout = options.tapTimeout || 700;

      if (FastClick.notNeeded(layer)) {
        return;
      } // Some old versions of Android don't have Function.prototype.bind


      function bind(method, context) {
        return function () {
          return method.apply(context, arguments);
        };
      }

      var methods = ['onMouse', 'onClick', 'onTouchStart', 'onTouchMove', 'onTouchEnd', 'onTouchCancel'];
      var context = this;

      for (var i = 0, l = methods.length; i < l; i++) {
        context[methods[i]] = bind(context[methods[i]], context);
      } // Set up event handlers as required


      if (deviceIsAndroid) {
        layer.addEventListener('mouseover', this.onMouse, true);
        layer.addEventListener('mousedown', this.onMouse, true);
        layer.addEventListener('mouseup', this.onMouse, true);
      }

      layer.addEventListener('click', this.onClick, true);
      layer.addEventListener('touchstart', this.onTouchStart, false);
      layer.addEventListener('touchmove', this.onTouchMove, false);
      layer.addEventListener('touchend', this.onTouchEnd, false);
      layer.addEventListener('touchcancel', this.onTouchCancel, false); // Hack is required for browsers that don't support Event#stopImmediatePropagation (e.g. Android 2)
      // which is how FastClick normally stops click events bubbling to callbacks registered on the FastClick
      // layer when they are cancelled.

      if (!Event.prototype.stopImmediatePropagation) {
        layer.removeEventListener = function (type, callback, capture) {
          var rmv = Node.prototype.removeEventListener;

          if (type === 'click') {
            rmv.call(layer, type, callback.hijacked || callback, capture);
          } else {
            rmv.call(layer, type, callback, capture);
          }
        };

        layer.addEventListener = function (type, callback, capture) {
          var adv = Node.prototype.addEventListener;

          if (type === 'click') {
            adv.call(layer, type, callback.hijacked || (callback.hijacked = function (event) {
              if (!event.propagationStopped) {
                callback(event);
              }
            }), capture);
          } else {
            adv.call(layer, type, callback, capture);
          }
        };
      } // If a handler is already declared in the element's onclick attribute, it will be fired before
      // FastClick's onClick handler. Fix this by pulling out the user-defined handler function and
      // adding it as listener.


      if (typeof layer.onclick === 'function') {
        // Android browser on at least 3.2 requires a new reference to the function in layer.onclick
        // - the old one won't work if passed to addEventListener directly.
        oldOnClick = layer.onclick;
        layer.addEventListener('click', function (event) {
          oldOnClick(event);
        }, false);
        layer.onclick = null;
      }
    }
    /**
    * Windows Phone 8.1 fakes user agent string to look like Android and iPhone.
    *
    * @type boolean
    */


    var deviceIsWindowsPhone = navigator.userAgent.indexOf("Windows Phone") >= 0;
    /**
     * Android requires exceptions.
     *
     * @type boolean
     */

    var deviceIsAndroid = navigator.userAgent.indexOf('Android') > 0 && !deviceIsWindowsPhone;
    /**
     * iOS requires exceptions.
     *
     * @type boolean
     */

    var deviceIsIOS = /iP(ad|hone|od)/.test(navigator.userAgent) && !deviceIsWindowsPhone;
    /**
     * iOS 4 requires an exception for select elements.
     *
     * @type boolean
     */

    var deviceIsIOS4 = deviceIsIOS && /OS 4_\d(_\d)?/.test(navigator.userAgent);
    /**
     * iOS 6.0-7.* requires the target element to be manually derived
     *
     * @type boolean
     */

    var deviceIsIOSWithBadTarget = deviceIsIOS && /OS [6-7]_\d/.test(navigator.userAgent);
    /**
     * BlackBerry requires exceptions.
     *
     * @type boolean
     */

    var deviceIsBlackBerry10 = navigator.userAgent.indexOf('BB10') > 0;
    /**
     * Determine whether a given element requires a native click.
     *
     * @param {EventTarget|Element} target Target DOM element
     * @returns {boolean} Returns true if the element needs a native click
     */

    FastClick.prototype.needsClick = function (target) {
      switch (target.nodeName.toLowerCase()) {
        // Don't send a synthetic click to disabled inputs (issue #62)
        case 'button':
        case 'select':
        case 'textarea':
          if (target.disabled) {
            return true;
          }

          break;

        case 'input':
          // File inputs need real clicks on iOS 6 due to a browser bug (issue #68)
          if (deviceIsIOS && target.type === 'file' || target.disabled) {
            return true;
          }

          break;

        case 'label':
        case 'iframe': // iOS8 homescreen apps can prevent events bubbling into frames

        case 'video':
          return true;
      }

      return /\bneedsclick\b/.test(target.className);
    };
    /**
     * Determine whether a given element requires a call to focus to simulate click into element.
     *
     * @param {EventTarget|Element} target Target DOM element
     * @returns {boolean} Returns true if the element requires a call to focus to simulate native click.
     */


    FastClick.prototype.needsFocus = function (target) {
      switch (target.nodeName.toLowerCase()) {
        case 'textarea':
          return true;

        case 'select':
          return !deviceIsAndroid;

        case 'input':
          switch (target.type) {
            case 'button':
            case 'checkbox':
            case 'file':
            case 'image':
            case 'radio':
            case 'submit':
              return false;
          } // No point in attempting to focus disabled inputs


          return !target.disabled && !target.readOnly;

        default:
          return /\bneedsfocus\b/.test(target.className);
      }
    };
    /**
     * Send a click event to the specified element.
     *
     * @param {EventTarget|Element} targetElement
     * @param {Event} event
     */


    FastClick.prototype.sendClick = function (targetElement, event) {
      var clickEvent, touch; // On some Android devices activeElement needs to be blurred otherwise the synthetic click will have no effect (#24)

      if (document.activeElement && document.activeElement !== targetElement) {
        document.activeElement.blur();
      }

      touch = event.changedTouches[0]; // Synthesise a click event, with an extra attribute so it can be tracked

      clickEvent = document.createEvent('MouseEvents');
      clickEvent.initMouseEvent(this.determineEventType(targetElement), true, true, window, 1, touch.screenX, touch.screenY, touch.clientX, touch.clientY, false, false, false, false, 0, null);
      clickEvent.forwardedTouchEvent = true;
      targetElement.dispatchEvent(clickEvent);
    };

    FastClick.prototype.determineEventType = function (targetElement) {
      //Issue #159: Android Chrome Select Box does not open with a synthetic click event
      if (deviceIsAndroid && targetElement.tagName.toLowerCase() === 'select') {
        return 'mousedown';
      }

      return 'click';
    };
    /**
     * @param {EventTarget|Element} targetElement
     */


    FastClick.prototype.focus = function (targetElement) {
      var length; // Issue #160: on iOS 7, some input elements (e.g. date datetime month) throw a vague TypeError on setSelectionRange. These elements don't have an integer value for the selectionStart and selectionEnd properties, but unfortunately that can't be used for detection because accessing the properties also throws a TypeError. Just check the type instead. Filed as Apple bug #15122724.

      if (deviceIsIOS && targetElement.setSelectionRange && targetElement.type.indexOf('date') !== 0 && targetElement.type !== 'time' && targetElement.type !== 'month') {
        length = targetElement.value.length;
        targetElement.setSelectionRange(length, length);
      } else {
        targetElement.focus();
      }
    };
    /**
     * Check whether the given target element is a child of a scrollable layer and if so, set a flag on it.
     *
     * @param {EventTarget|Element} targetElement
     */


    FastClick.prototype.updateScrollParent = function (targetElement) {
      var scrollParent, parentElement;
      scrollParent = targetElement.fastClickScrollParent; // Attempt to discover whether the target element is contained within a scrollable layer. Re-check if the
      // target element was moved to another parent.

      if (!scrollParent || !scrollParent.contains(targetElement)) {
        parentElement = targetElement;

        do {
          if (parentElement.scrollHeight > parentElement.offsetHeight) {
            scrollParent = parentElement;
            targetElement.fastClickScrollParent = parentElement;
            break;
          }

          parentElement = parentElement.parentElement;
        } while (parentElement);
      } // Always update the scroll top tracker if possible.


      if (scrollParent) {
        scrollParent.fastClickLastScrollTop = scrollParent.scrollTop;
      }
    };
    /**
     * @param {EventTarget} targetElement
     * @returns {Element|EventTarget}
     */


    FastClick.prototype.getTargetElementFromEventTarget = function (eventTarget) {
      // On some older browsers (notably Safari on iOS 4.1 - see issue #56) the event target may be a text node.
      if (eventTarget.nodeType === Node.TEXT_NODE) {
        return eventTarget.parentNode;
      }

      return eventTarget;
    };
    /**
     * On touch start, record the position and scroll offset.
     *
     * @param {Event} event
     * @returns {boolean}
     */


    FastClick.prototype.onTouchStart = function (event) {
      var targetElement, touch, selection; // Ignore multiple touches, otherwise pinch-to-zoom is prevented if both fingers are on the FastClick element (issue #111).

      if (event.targetTouches.length > 1) {
        return true;
      }

      targetElement = this.getTargetElementFromEventTarget(event.target);
      touch = event.targetTouches[0];

      if (deviceIsIOS) {
        // Only trusted events will deselect text on iOS (issue #49)
        selection = window.getSelection();

        if (selection.rangeCount && !selection.isCollapsed) {
          return true;
        }

        if (!deviceIsIOS4) {
          // Weird things happen on iOS when an alert or confirm dialog is opened from a click event callback (issue #23):
          // when the user next taps anywhere else on the page, new touchstart and touchend events are dispatched
          // with the same identifier as the touch event that previously triggered the click that triggered the alert.
          // Sadly, there is an issue on iOS 4 that causes some normal touch events to have the same identifier as an
          // immediately preceeding touch event (issue #52), so this fix is unavailable on that platform.
          // Issue 120: touch.identifier is 0 when Chrome dev tools 'Emulate touch events' is set with an iOS device UA string,
          // which causes all touch events to be ignored. As this block only applies to iOS, and iOS identifiers are always long,
          // random integers, it's safe to to continue if the identifier is 0 here.
          if (touch.identifier && touch.identifier === this.lastTouchIdentifier) {
            event.preventDefault();
            return false;
          }

          this.lastTouchIdentifier = touch.identifier; // If the target element is a child of a scrollable layer (using -webkit-overflow-scrolling: touch) and:
          // 1) the user does a fling scroll on the scrollable layer
          // 2) the user stops the fling scroll with another tap
          // then the event.target of the last 'touchend' event will be the element that was under the user's finger
          // when the fling scroll was started, causing FastClick to send a click event to that layer - unless a check
          // is made to ensure that a parent layer was not scrolled before sending a synthetic click (issue #42).

          this.updateScrollParent(targetElement);
        }
      }

      this.trackingClick = true;
      this.trackingClickStart = event.timeStamp;
      this.targetElement = targetElement;
      this.touchStartX = touch.pageX;
      this.touchStartY = touch.pageY; // Prevent phantom clicks on fast double-tap (issue #36)

      if (event.timeStamp - this.lastClickTime < this.tapDelay) {
        event.preventDefault();
      }

      return true;
    };
    /**
     * Based on a touchmove event object, check whether the touch has moved past a boundary since it started.
     *
     * @param {Event} event
     * @returns {boolean}
     */


    FastClick.prototype.touchHasMoved = function (event) {
      var touch = event.changedTouches[0],
          boundary = this.touchBoundary;

      if (Math.abs(touch.pageX - this.touchStartX) > boundary || Math.abs(touch.pageY - this.touchStartY) > boundary) {
        return true;
      }

      return false;
    };
    /**
     * Update the last position.
     *
     * @param {Event} event
     * @returns {boolean}
     */


    FastClick.prototype.onTouchMove = function (event) {
      if (!this.trackingClick) {
        return true;
      } // If the touch has moved, cancel the click tracking


      if (this.targetElement !== this.getTargetElementFromEventTarget(event.target) || this.touchHasMoved(event)) {
        this.trackingClick = false;
        this.targetElement = null;
      }

      return true;
    };
    /**
     * Attempt to find the labelled control for the given label element.
     *
     * @param {EventTarget|HTMLLabelElement} labelElement
     * @returns {Element|null}
     */


    FastClick.prototype.findControl = function (labelElement) {
      // Fast path for newer browsers supporting the HTML5 control attribute
      if (labelElement.control !== undefined) {
        return labelElement.control;
      } // All browsers under test that support touch events also support the HTML5 htmlFor attribute


      if (labelElement.htmlFor) {
        return document.getElementById(labelElement.htmlFor);
      } // If no for attribute exists, attempt to retrieve the first labellable descendant element
      // the list of which is defined here: http://www.w3.org/TR/html5/forms.html#category-label


      return labelElement.querySelector('button, input:not([type=hidden]), keygen, meter, output, progress, select, textarea');
    };
    /**
     * On touch end, determine whether to send a click event at once.
     *
     * @param {Event} event
     * @returns {boolean}
     */


    FastClick.prototype.onTouchEnd = function (event) {
      var forElement,
          trackingClickStart,
          targetTagName,
          scrollParent,
          touch,
          targetElement = this.targetElement;

      if (!this.trackingClick) {
        return true;
      } // Prevent phantom clicks on fast double-tap (issue #36)


      if (event.timeStamp - this.lastClickTime < this.tapDelay) {
        this.cancelNextClick = true;
        return true;
      }

      if (event.timeStamp - this.trackingClickStart > this.tapTimeout) {
        return true;
      } // Reset to prevent wrong click cancel on input (issue #156).


      this.cancelNextClick = false;
      this.lastClickTime = event.timeStamp;
      trackingClickStart = this.trackingClickStart;
      this.trackingClick = false;
      this.trackingClickStart = 0; // On some iOS devices, the targetElement supplied with the event is invalid if the layer
      // is performing a transition or scroll, and has to be re-detected manually. Note that
      // for this to function correctly, it must be called *after* the event target is checked!
      // See issue #57; also filed as rdar://13048589 .

      if (deviceIsIOSWithBadTarget) {
        touch = event.changedTouches[0]; // In certain cases arguments of elementFromPoint can be negative, so prevent setting targetElement to null

        targetElement = document.elementFromPoint(touch.pageX - window.pageXOffset, touch.pageY - window.pageYOffset) || targetElement;
        targetElement.fastClickScrollParent = this.targetElement.fastClickScrollParent;
      }

      targetTagName = targetElement.tagName.toLowerCase();

      if (targetTagName === 'label') {
        forElement = this.findControl(targetElement);

        if (forElement) {
          this.focus(targetElement);

          if (deviceIsAndroid) {
            return false;
          }

          targetElement = forElement;
        }
      } else if (this.needsFocus(targetElement)) {
        // Case 1: If the touch started a while ago (best guess is 100ms based on tests for issue #36) then focus will be triggered anyway. Return early and unset the target element reference so that the subsequent click will be allowed through.
        // Case 2: Without this exception for input elements tapped when the document is contained in an iframe, then any inputted text won't be visible even though the value attribute is updated as the user types (issue #37).
        if (event.timeStamp - trackingClickStart > 100 || deviceIsIOS && window.top !== window && targetTagName === 'input') {
          this.targetElement = null;
          return false;
        }

        this.focus(targetElement);
        this.sendClick(targetElement, event); // Select elements need the event to go through on iOS 4, otherwise the selector menu won't open.
        // Also this breaks opening selects when VoiceOver is active on iOS6, iOS7 (and possibly others)

        if (!deviceIsIOS || targetTagName !== 'select') {
          this.targetElement = null;
          event.preventDefault();
        }

        return false;
      }

      if (deviceIsIOS && !deviceIsIOS4) {
        // Don't send a synthetic click event if the target element is contained within a parent layer that was scrolled
        // and this tap is being used to stop the scrolling (usually initiated by a fling - issue #42).
        scrollParent = targetElement.fastClickScrollParent;

        if (scrollParent && scrollParent.fastClickLastScrollTop !== scrollParent.scrollTop) {
          return true;
        }
      } // Prevent the actual click from going though - unless the target node is marked as requiring
      // real clicks or if it is in the whitelist in which case only non-programmatic clicks are permitted.


      if (!this.needsClick(targetElement)) {
        event.preventDefault();
        this.sendClick(targetElement, event);
      }

      return false;
    };
    /**
     * On touch cancel, stop tracking the click.
     *
     * @returns {void}
     */


    FastClick.prototype.onTouchCancel = function () {
      this.trackingClick = false;
      this.targetElement = null;
    };
    /**
     * Determine mouse events which should be permitted.
     *
     * @param {Event} event
     * @returns {boolean}
     */


    FastClick.prototype.onMouse = function (event) {
      // If a target element was never set (because a touch event was never fired) allow the event
      if (!this.targetElement) {
        return true;
      }

      if (event.forwardedTouchEvent) {
        return true;
      } // Programmatically generated events targeting a specific element should be permitted


      if (!event.cancelable) {
        return true;
      } // Derive and check the target element to see whether the mouse event needs to be permitted;
      // unless explicitly enabled, prevent non-touch click events from triggering actions,
      // to prevent ghost/doubleclicks.


      if (!this.needsClick(this.targetElement) || this.cancelNextClick) {
        // Prevent any user-added listeners declared on FastClick element from being fired.
        if (event.stopImmediatePropagation) {
          event.stopImmediatePropagation();
        } else {
          // Part of the hack for browsers that don't support Event#stopImmediatePropagation (e.g. Android 2)
          event.propagationStopped = true;
        } // Cancel the event


        event.stopPropagation();
        event.preventDefault();
        return false;
      } // If the mouse event is permitted, return true for the action to go through.


      return true;
    };
    /**
     * On actual clicks, determine whether this is a touch-generated click, a click action occurring
     * naturally after a delay after a touch (which needs to be cancelled to avoid duplication), or
     * an actual click which should be permitted.
     *
     * @param {Event} event
     * @returns {boolean}
     */


    FastClick.prototype.onClick = function (event) {
      var permitted; // It's possible for another FastClick-like library delivered with third-party code to fire a click event before FastClick does (issue #44). In that case, set the click-tracking flag back to false and return early. This will cause onTouchEnd to return early.

      if (this.trackingClick) {
        this.targetElement = null;
        this.trackingClick = false;
        return true;
      } // Very odd behaviour on iOS (issue #18): if a submit element is present inside a form and the user hits enter in the iOS simulator or clicks the Go button on the pop-up OS keyboard the a kind of 'fake' click event will be triggered with the submit-type input element as the target.


      if (event.target.type === 'submit' && event.detail === 0) {
        return true;
      }

      permitted = this.onMouse(event); // Only unset targetElement if the click is not permitted. This will ensure that the check for !targetElement in onMouse fails and the browser's click doesn't go through.

      if (!permitted) {
        this.targetElement = null;
      } // If clicks are permitted, return true for the action to go through.


      return permitted;
    };
    /**
     * Remove all FastClick's event listeners.
     *
     * @returns {void}
     */


    FastClick.prototype.destroy = function () {
      var layer = this.layer;

      if (deviceIsAndroid) {
        layer.removeEventListener('mouseover', this.onMouse, true);
        layer.removeEventListener('mousedown', this.onMouse, true);
        layer.removeEventListener('mouseup', this.onMouse, true);
      }

      layer.removeEventListener('click', this.onClick, true);
      layer.removeEventListener('touchstart', this.onTouchStart, false);
      layer.removeEventListener('touchmove', this.onTouchMove, false);
      layer.removeEventListener('touchend', this.onTouchEnd, false);
      layer.removeEventListener('touchcancel', this.onTouchCancel, false);
    };
    /**
     * Check whether FastClick is needed.
     *
     * @param {Element} layer The layer to listen on
     */


    FastClick.notNeeded = function (layer) {
      var metaViewport;
      var chromeVersion;
      var blackberryVersion;
      var firefoxVersion; // Devices that don't support touch don't need FastClick

      if (typeof window.ontouchstart === 'undefined') {
        return true;
      } // Chrome version - zero for other browsers


      chromeVersion = +(/Chrome\/([0-9]+)/.exec(navigator.userAgent) || [, 0])[1];

      if (chromeVersion) {
        if (deviceIsAndroid) {
          metaViewport = document.querySelector('meta[name=viewport]');

          if (metaViewport) {
            // Chrome on Android with user-scalable="no" doesn't need FastClick (issue #89)
            if (metaViewport.content.indexOf('user-scalable=no') !== -1) {
              return true;
            } // Chrome 32 and above with width=device-width or less don't need FastClick


            if (chromeVersion > 31 && document.documentElement.scrollWidth <= window.outerWidth) {
              return true;
            }
          } // Chrome desktop doesn't need FastClick (issue #15)

        } else {
          return true;
        }
      }

      if (deviceIsBlackBerry10) {
        blackberryVersion = navigator.userAgent.match(/Version\/([0-9]*)\.([0-9]*)/); // BlackBerry 10.3+ does not require Fastclick library.
        // https://github.com/ftlabs/fastclick/issues/251

        if (blackberryVersion[1] >= 10 && blackberryVersion[2] >= 3) {
          metaViewport = document.querySelector('meta[name=viewport]');

          if (metaViewport) {
            // user-scalable=no eliminates click delay.
            if (metaViewport.content.indexOf('user-scalable=no') !== -1) {
              return true;
            } // width=device-width (or less than device-width) eliminates click delay.


            if (document.documentElement.scrollWidth <= window.outerWidth) {
              return true;
            }
          }
        }
      } // IE10 with -ms-touch-action: none or manipulation, which disables double-tap-to-zoom (issue #97)


      if (layer.style.msTouchAction === 'none' || layer.style.touchAction === 'manipulation') {
        return true;
      } // Firefox version - zero for other browsers


      firefoxVersion = +(/Firefox\/([0-9]+)/.exec(navigator.userAgent) || [, 0])[1];

      if (firefoxVersion >= 27) {
        // Firefox 27+ does not have tap delay if the content is not zoomable - https://bugzilla.mozilla.org/show_bug.cgi?id=922896
        metaViewport = document.querySelector('meta[name=viewport]');

        if (metaViewport && (metaViewport.content.indexOf('user-scalable=no') !== -1 || document.documentElement.scrollWidth <= window.outerWidth)) {
          return true;
        }
      } // IE11: prefixed -ms-touch-action is no longer supported and it's recomended to use non-prefixed version
      // http://msdn.microsoft.com/en-us/library/windows/apps/Hh767313.aspx


      if (layer.style.touchAction === 'none' || layer.style.touchAction === 'manipulation') {
        return true;
      }

      return false;
    };
    /**
     * Factory method for creating a FastClick object
     *
     * @param {Element} layer The layer to listen on
     * @param {Object} [options={}] The options to override the defaults
     */


    FastClick.attach = function (layer, options) {
      return new FastClick(layer, options);
    };

    if (typeof define === 'function' && _typeof(define.amd) === 'object' && define.amd) {
      // AMD. Register as an anonymous module.
      define(function () {
        return FastClick;
      });
    } else if (typeof module !== 'undefined' && module.exports) {
      module.exports = FastClick.attach;
      module.exports.FastClick = FastClick;
    } else {
      window.FastClick = FastClick;
    }
  })();

  /*! howler.js v2.2.0 | (c) 2013-2020, James Simpson of GoldFire Studios | MIT License | howlerjs.com */
  !function () {

    var e = function e() {
      this.init();
    };

    e.prototype = {
      init: function init() {
        var e = this || n;
        return e._counter = 1e3, e._html5AudioPool = [], e.html5PoolSize = 10, e._codecs = {}, e._howls = [], e._muted = !1, e._volume = 1, e._canPlayEvent = "canplaythrough", e._navigator = "undefined" != typeof window && window.navigator ? window.navigator : null, e.masterGain = null, e.noAudio = !1, e.usingWebAudio = !0, e.autoSuspend = !0, e.ctx = null, e.autoUnlock = !0, e._setup(), e;
      },
      volume: function volume(e) {
        var o = this || n;

        if (e = parseFloat(e), o.ctx || _(), void 0 !== e && e >= 0 && e <= 1) {
          if (o._volume = e, o._muted) return o;
          o.usingWebAudio && o.masterGain.gain.setValueAtTime(e, n.ctx.currentTime);

          for (var t = 0; t < o._howls.length; t++) {
            if (!o._howls[t]._webAudio) for (var r = o._howls[t]._getSoundIds(), a = 0; a < r.length; a++) {
              var u = o._howls[t]._soundById(r[a]);

              u && u._node && (u._node.volume = u._volume * e);
            }
          }

          return o;
        }

        return o._volume;
      },
      mute: function mute(e) {
        var o = this || n;
        o.ctx || _(), o._muted = e, o.usingWebAudio && o.masterGain.gain.setValueAtTime(e ? 0 : o._volume, n.ctx.currentTime);

        for (var t = 0; t < o._howls.length; t++) {
          if (!o._howls[t]._webAudio) for (var r = o._howls[t]._getSoundIds(), a = 0; a < r.length; a++) {
            var u = o._howls[t]._soundById(r[a]);

            u && u._node && (u._node.muted = !!e || u._muted);
          }
        }

        return o;
      },
      stop: function stop() {
        for (var e = this || n, o = 0; o < e._howls.length; o++) {
          e._howls[o].stop();
        }

        return e;
      },
      unload: function unload() {
        for (var e = this || n, o = e._howls.length - 1; o >= 0; o--) {
          e._howls[o].unload();
        }

        return e.usingWebAudio && e.ctx && void 0 !== e.ctx.close && (e.ctx.close(), e.ctx = null, _()), e;
      },
      codecs: function codecs(e) {
        return (this || n)._codecs[e.replace(/^x-/, "")];
      },
      _setup: function _setup() {
        var e = this || n;
        if (e.state = e.ctx ? e.ctx.state || "suspended" : "suspended", e._autoSuspend(), !e.usingWebAudio) if ("undefined" != typeof Audio) try {
          var o = new Audio();
          void 0 === o.oncanplaythrough && (e._canPlayEvent = "canplay");
        } catch (n) {
          e.noAudio = !0;
        } else e.noAudio = !0;

        try {
          var o = new Audio();
          o.muted && (e.noAudio = !0);
        } catch (e) {}

        return e.noAudio || e._setupCodecs(), e;
      },
      _setupCodecs: function _setupCodecs() {
        var e = this || n,
            o = null;

        try {
          o = "undefined" != typeof Audio ? new Audio() : null;
        } catch (n) {
          return e;
        }

        if (!o || "function" != typeof o.canPlayType) return e;

        var t = o.canPlayType("audio/mpeg;").replace(/^no$/, ""),
            r = e._navigator && e._navigator.userAgent.match(/OPR\/([0-6].)/g),
            a = r && parseInt(r[0].split("/")[1], 10) < 33;

        return e._codecs = {
          mp3: !(a || !t && !o.canPlayType("audio/mp3;").replace(/^no$/, "")),
          mpeg: !!t,
          opus: !!o.canPlayType('audio/ogg; codecs="opus"').replace(/^no$/, ""),
          ogg: !!o.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, ""),
          oga: !!o.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, ""),
          wav: !!o.canPlayType('audio/wav; codecs="1"').replace(/^no$/, ""),
          aac: !!o.canPlayType("audio/aac;").replace(/^no$/, ""),
          caf: !!o.canPlayType("audio/x-caf;").replace(/^no$/, ""),
          m4a: !!(o.canPlayType("audio/x-m4a;") || o.canPlayType("audio/m4a;") || o.canPlayType("audio/aac;")).replace(/^no$/, ""),
          m4b: !!(o.canPlayType("audio/x-m4b;") || o.canPlayType("audio/m4b;") || o.canPlayType("audio/aac;")).replace(/^no$/, ""),
          mp4: !!(o.canPlayType("audio/x-mp4;") || o.canPlayType("audio/mp4;") || o.canPlayType("audio/aac;")).replace(/^no$/, ""),
          weba: !!o.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, ""),
          webm: !!o.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, ""),
          dolby: !!o.canPlayType('audio/mp4; codecs="ec-3"').replace(/^no$/, ""),
          flac: !!(o.canPlayType("audio/x-flac;") || o.canPlayType("audio/flac;")).replace(/^no$/, "")
        }, e;
      },
      _unlockAudio: function _unlockAudio() {
        var e = this || n;

        if (!e._audioUnlocked && e.ctx) {
          e._audioUnlocked = !1, e.autoUnlock = !1, e._mobileUnloaded || 44100 === e.ctx.sampleRate || (e._mobileUnloaded = !0, e.unload()), e._scratchBuffer = e.ctx.createBuffer(1, 1, 22050);

          var o = function o(n) {
            for (; e._html5AudioPool.length < e.html5PoolSize;) {
              try {
                var t = new Audio();
                t._unlocked = !0, e._releaseHtml5Audio(t);
              } catch (n) {
                e.noAudio = !0;
                break;
              }
            }

            for (var r = 0; r < e._howls.length; r++) {
              if (!e._howls[r]._webAudio) for (var a = e._howls[r]._getSoundIds(), u = 0; u < a.length; u++) {
                var i = e._howls[r]._soundById(a[u]);

                i && i._node && !i._node._unlocked && (i._node._unlocked = !0, i._node.load());
              }
            }

            e._autoResume();

            var d = e.ctx.createBufferSource();
            d.buffer = e._scratchBuffer, d.connect(e.ctx.destination), void 0 === d.start ? d.noteOn(0) : d.start(0), "function" == typeof e.ctx.resume && e.ctx.resume(), d.onended = function () {
              d.disconnect(0), e._audioUnlocked = !0, document.removeEventListener("touchstart", o, !0), document.removeEventListener("touchend", o, !0), document.removeEventListener("click", o, !0);

              for (var n = 0; n < e._howls.length; n++) {
                e._howls[n]._emit("unlock");
              }
            };
          };

          return document.addEventListener("touchstart", o, !0), document.addEventListener("touchend", o, !0), document.addEventListener("click", o, !0), e;
        }
      },
      _obtainHtml5Audio: function _obtainHtml5Audio() {
        var e = this || n;
        if (e._html5AudioPool.length) return e._html5AudioPool.pop();
        var o = new Audio().play();
        return o && "undefined" != typeof Promise && (o instanceof Promise || "function" == typeof o.then) && o["catch"](function () {
          console.warn("HTML5 Audio pool exhausted, returning potentially locked audio object.");
        }), new Audio();
      },
      _releaseHtml5Audio: function _releaseHtml5Audio(e) {
        var o = this || n;
        return e._unlocked && o._html5AudioPool.push(e), o;
      },
      _autoSuspend: function _autoSuspend() {
        var e = this;

        if (e.autoSuspend && e.ctx && void 0 !== e.ctx.suspend && n.usingWebAudio) {
          for (var o = 0; o < e._howls.length; o++) {
            if (e._howls[o]._webAudio) for (var t = 0; t < e._howls[o]._sounds.length; t++) {
              if (!e._howls[o]._sounds[t]._paused) return e;
            }
          }

          return e._suspendTimer && clearTimeout(e._suspendTimer), e._suspendTimer = setTimeout(function () {
            if (e.autoSuspend) {
              e._suspendTimer = null, e.state = "suspending";

              var n = function n() {
                e.state = "suspended", e._resumeAfterSuspend && (delete e._resumeAfterSuspend, e._autoResume());
              };

              e.ctx.suspend().then(n, n);
            }
          }, 3e4), e;
        }
      },
      _autoResume: function _autoResume() {
        var e = this;
        if (e.ctx && void 0 !== e.ctx.resume && n.usingWebAudio) return "running" === e.state && "interrupted" !== e.ctx.state && e._suspendTimer ? (clearTimeout(e._suspendTimer), e._suspendTimer = null) : "suspended" === e.state || "running" === e.state && "interrupted" === e.ctx.state ? (e.ctx.resume().then(function () {
          e.state = "running";

          for (var n = 0; n < e._howls.length; n++) {
            e._howls[n]._emit("resume");
          }
        }), e._suspendTimer && (clearTimeout(e._suspendTimer), e._suspendTimer = null)) : "suspending" === e.state && (e._resumeAfterSuspend = !0), e;
      }
    };

    var n = new e(),
        o = function o(e) {
      var n = this;
      if (!e.src || 0 === e.src.length) return void console.error("An array of source files must be passed with any new Howl.");
      n.init(e);
    };

    o.prototype = {
      init: function init(e) {
        var o = this;
        return n.ctx || _(), o._autoplay = e.autoplay || !1, o._format = "string" != typeof e.format ? e.format : [e.format], o._html5 = e.html5 || !1, o._muted = e.mute || !1, o._loop = e.loop || !1, o._pool = e.pool || 5, o._preload = "boolean" != typeof e.preload && "metadata" !== e.preload || e.preload, o._rate = e.rate || 1, o._sprite = e.sprite || {}, o._src = "string" != typeof e.src ? e.src : [e.src], o._volume = void 0 !== e.volume ? e.volume : 1, o._xhr = {
          method: e.xhr && e.xhr.method ? e.xhr.method : "GET",
          headers: e.xhr && e.xhr.headers ? e.xhr.headers : null,
          withCredentials: !(!e.xhr || !e.xhr.withCredentials) && e.xhr.withCredentials
        }, o._duration = 0, o._state = "unloaded", o._sounds = [], o._endTimers = {}, o._queue = [], o._playLock = !1, o._onend = e.onend ? [{
          fn: e.onend
        }] : [], o._onfade = e.onfade ? [{
          fn: e.onfade
        }] : [], o._onload = e.onload ? [{
          fn: e.onload
        }] : [], o._onloaderror = e.onloaderror ? [{
          fn: e.onloaderror
        }] : [], o._onplayerror = e.onplayerror ? [{
          fn: e.onplayerror
        }] : [], o._onpause = e.onpause ? [{
          fn: e.onpause
        }] : [], o._onplay = e.onplay ? [{
          fn: e.onplay
        }] : [], o._onstop = e.onstop ? [{
          fn: e.onstop
        }] : [], o._onmute = e.onmute ? [{
          fn: e.onmute
        }] : [], o._onvolume = e.onvolume ? [{
          fn: e.onvolume
        }] : [], o._onrate = e.onrate ? [{
          fn: e.onrate
        }] : [], o._onseek = e.onseek ? [{
          fn: e.onseek
        }] : [], o._onunlock = e.onunlock ? [{
          fn: e.onunlock
        }] : [], o._onresume = [], o._webAudio = n.usingWebAudio && !o._html5, void 0 !== n.ctx && n.ctx && n.autoUnlock && n._unlockAudio(), n._howls.push(o), o._autoplay && o._queue.push({
          event: "play",
          action: function action() {
            o.play();
          }
        }), o._preload && "none" !== o._preload && o.load(), o;
      },
      load: function load() {
        var e = this,
            o = null;
        if (n.noAudio) return void e._emit("loaderror", null, "No audio support.");
        "string" == typeof e._src && (e._src = [e._src]);

        for (var r = 0; r < e._src.length; r++) {
          var u, i;
          if (e._format && e._format[r]) u = e._format[r];else {
            if ("string" != typeof (i = e._src[r])) {
              e._emit("loaderror", null, "Non-string found in selected audio sources - ignoring.");

              continue;
            }

            u = /^data:audio\/([^;,]+);/i.exec(i), u || (u = /\.([^.]+)$/.exec(i.split("?", 1)[0])), u && (u = u[1].toLowerCase());
          }

          if (u || console.warn('No file extension was found. Consider using the "format" property or specify an extension.'), u && n.codecs(u)) {
            o = e._src[r];
            break;
          }
        }

        return o ? (e._src = o, e._state = "loading", "https:" === window.location.protocol && "http:" === o.slice(0, 5) && (e._html5 = !0, e._webAudio = !1), new t(e), e._webAudio && a(e), e) : void e._emit("loaderror", null, "No codec support for selected audio sources.");
      },
      play: function play(e, o) {
        var t = this,
            r = null;
        if ("number" == typeof e) r = e, e = null;else {
          if ("string" == typeof e && "loaded" === t._state && !t._sprite[e]) return null;

          if (void 0 === e && (e = "__default", !t._playLock)) {
            for (var a = 0, u = 0; u < t._sounds.length; u++) {
              t._sounds[u]._paused && !t._sounds[u]._ended && (a++, r = t._sounds[u]._id);
            }

            1 === a ? e = null : r = null;
          }
        }
        var i = r ? t._soundById(r) : t._inactiveSound();
        if (!i) return null;

        if (r && !e && (e = i._sprite || "__default"), "loaded" !== t._state) {
          i._sprite = e, i._ended = !1;
          var d = i._id;
          return t._queue.push({
            event: "play",
            action: function action() {
              t.play(d);
            }
          }), d;
        }

        if (r && !i._paused) return o || t._loadQueue("play"), i._id;
        t._webAudio && n._autoResume();

        var _ = Math.max(0, i._seek > 0 ? i._seek : t._sprite[e][0] / 1e3),
            s = Math.max(0, (t._sprite[e][0] + t._sprite[e][1]) / 1e3 - _),
            l = 1e3 * s / Math.abs(i._rate),
            c = t._sprite[e][0] / 1e3,
            f = (t._sprite[e][0] + t._sprite[e][1]) / 1e3;

        i._sprite = e, i._ended = !1;

        var p = function p() {
          i._paused = !1, i._seek = _, i._start = c, i._stop = f, i._loop = !(!i._loop && !t._sprite[e][2]);
        };

        if (_ >= f) return void t._ended(i);
        var m = i._node;

        if (t._webAudio) {
          var v = function v() {
            t._playLock = !1, p(), t._refreshBuffer(i);
            var e = i._muted || t._muted ? 0 : i._volume;
            m.gain.setValueAtTime(e, n.ctx.currentTime), i._playStart = n.ctx.currentTime, void 0 === m.bufferSource.start ? i._loop ? m.bufferSource.noteGrainOn(0, _, 86400) : m.bufferSource.noteGrainOn(0, _, s) : i._loop ? m.bufferSource.start(0, _, 86400) : m.bufferSource.start(0, _, s), l !== 1 / 0 && (t._endTimers[i._id] = setTimeout(t._ended.bind(t, i), l)), o || setTimeout(function () {
              t._emit("play", i._id), t._loadQueue();
            }, 0);
          };

          "running" === n.state && "interrupted" !== n.ctx.state ? v() : (t._playLock = !0, t.once("resume", v), t._clearTimer(i._id));
        } else {
          var h = function h() {
            m.currentTime = _, m.muted = i._muted || t._muted || n._muted || m.muted, m.volume = i._volume * n.volume(), m.playbackRate = i._rate;

            try {
              var r = m.play();
              if (r && "undefined" != typeof Promise && (r instanceof Promise || "function" == typeof r.then) ? (t._playLock = !0, p(), r.then(function () {
                t._playLock = !1, m._unlocked = !0, o || (t._emit("play", i._id), t._loadQueue());
              })["catch"](function () {
                t._playLock = !1, t._emit("playerror", i._id, "Playback was unable to start. This is most commonly an issue on mobile devices and Chrome where playback was not within a user interaction."), i._ended = !0, i._paused = !0;
              })) : o || (t._playLock = !1, p(), t._emit("play", i._id), t._loadQueue()), m.playbackRate = i._rate, m.paused) return void t._emit("playerror", i._id, "Playback was unable to start. This is most commonly an issue on mobile devices and Chrome where playback was not within a user interaction.");
              "__default" !== e || i._loop ? t._endTimers[i._id] = setTimeout(t._ended.bind(t, i), l) : (t._endTimers[i._id] = function () {
                t._ended(i), m.removeEventListener("ended", t._endTimers[i._id], !1);
              }, m.addEventListener("ended", t._endTimers[i._id], !1));
            } catch (e) {
              t._emit("playerror", i._id, e);
            }
          };

          "data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA" === m.src && (m.src = t._src, m.load());
          var y = window && window.ejecta || !m.readyState && n._navigator.isCocoonJS;
          if (m.readyState >= 3 || y) h();else {
            t._playLock = !0;

            var g = function g() {
              h(), m.removeEventListener(n._canPlayEvent, g, !1);
            };

            m.addEventListener(n._canPlayEvent, g, !1), t._clearTimer(i._id);
          }
        }

        return i._id;
      },
      pause: function pause(e) {
        var n = this;
        if ("loaded" !== n._state || n._playLock) return n._queue.push({
          event: "pause",
          action: function action() {
            n.pause(e);
          }
        }), n;

        for (var o = n._getSoundIds(e), t = 0; t < o.length; t++) {
          n._clearTimer(o[t]);

          var r = n._soundById(o[t]);

          if (r && !r._paused && (r._seek = n.seek(o[t]), r._rateSeek = 0, r._paused = !0, n._stopFade(o[t]), r._node)) if (n._webAudio) {
            if (!r._node.bufferSource) continue;
            void 0 === r._node.bufferSource.stop ? r._node.bufferSource.noteOff(0) : r._node.bufferSource.stop(0), n._cleanBuffer(r._node);
          } else isNaN(r._node.duration) && r._node.duration !== 1 / 0 || r._node.pause();
          arguments[1] || n._emit("pause", r ? r._id : null);
        }

        return n;
      },
      stop: function stop(e, n) {
        var o = this;
        if ("loaded" !== o._state || o._playLock) return o._queue.push({
          event: "stop",
          action: function action() {
            o.stop(e);
          }
        }), o;

        for (var t = o._getSoundIds(e), r = 0; r < t.length; r++) {
          o._clearTimer(t[r]);

          var a = o._soundById(t[r]);

          a && (a._seek = a._start || 0, a._rateSeek = 0, a._paused = !0, a._ended = !0, o._stopFade(t[r]), a._node && (o._webAudio ? a._node.bufferSource && (void 0 === a._node.bufferSource.stop ? a._node.bufferSource.noteOff(0) : a._node.bufferSource.stop(0), o._cleanBuffer(a._node)) : isNaN(a._node.duration) && a._node.duration !== 1 / 0 || (a._node.currentTime = a._start || 0, a._node.pause(), a._node.duration === 1 / 0 && o._clearSound(a._node))), n || o._emit("stop", a._id));
        }

        return o;
      },
      mute: function mute(e, o) {
        var t = this;
        if ("loaded" !== t._state || t._playLock) return t._queue.push({
          event: "mute",
          action: function action() {
            t.mute(e, o);
          }
        }), t;

        if (void 0 === o) {
          if ("boolean" != typeof e) return t._muted;
          t._muted = e;
        }

        for (var r = t._getSoundIds(o), a = 0; a < r.length; a++) {
          var u = t._soundById(r[a]);

          u && (u._muted = e, u._interval && t._stopFade(u._id), t._webAudio && u._node ? u._node.gain.setValueAtTime(e ? 0 : u._volume, n.ctx.currentTime) : u._node && (u._node.muted = !!n._muted || e), t._emit("mute", u._id));
        }

        return t;
      },
      volume: function volume() {
        var e,
            o,
            t = this,
            r = arguments;
        if (0 === r.length) return t._volume;

        if (1 === r.length || 2 === r.length && void 0 === r[1]) {
          t._getSoundIds().indexOf(r[0]) >= 0 ? o = parseInt(r[0], 10) : e = parseFloat(r[0]);
        } else r.length >= 2 && (e = parseFloat(r[0]), o = parseInt(r[1], 10));

        var a;
        if (!(void 0 !== e && e >= 0 && e <= 1)) return a = o ? t._soundById(o) : t._sounds[0], a ? a._volume : 0;
        if ("loaded" !== t._state || t._playLock) return t._queue.push({
          event: "volume",
          action: function action() {
            t.volume.apply(t, r);
          }
        }), t;
        void 0 === o && (t._volume = e), o = t._getSoundIds(o);

        for (var u = 0; u < o.length; u++) {
          (a = t._soundById(o[u])) && (a._volume = e, r[2] || t._stopFade(o[u]), t._webAudio && a._node && !a._muted ? a._node.gain.setValueAtTime(e, n.ctx.currentTime) : a._node && !a._muted && (a._node.volume = e * n.volume()), t._emit("volume", a._id));
        }

        return t;
      },
      fade: function fade(e, o, t, r) {
        var a = this;
        if ("loaded" !== a._state || a._playLock) return a._queue.push({
          event: "fade",
          action: function action() {
            a.fade(e, o, t, r);
          }
        }), a;
        e = Math.min(Math.max(0, parseFloat(e)), 1), o = Math.min(Math.max(0, parseFloat(o)), 1), t = parseFloat(t), a.volume(e, r);

        for (var u = a._getSoundIds(r), i = 0; i < u.length; i++) {
          var d = a._soundById(u[i]);

          if (d) {
            if (r || a._stopFade(u[i]), a._webAudio && !d._muted) {
              var _ = n.ctx.currentTime,
                  s = _ + t / 1e3;
              d._volume = e, d._node.gain.setValueAtTime(e, _), d._node.gain.linearRampToValueAtTime(o, s);
            }

            a._startFadeInterval(d, e, o, t, u[i], void 0 === r);
          }
        }

        return a;
      },
      _startFadeInterval: function _startFadeInterval(e, n, o, t, r, a) {
        var u = this,
            i = n,
            d = o - n,
            _ = Math.abs(d / .01),
            s = Math.max(4, _ > 0 ? t / _ : t),
            l = Date.now();

        e._fadeTo = o, e._interval = setInterval(function () {
          var r = (Date.now() - l) / t;
          l = Date.now(), i += d * r, i = d < 0 ? Math.max(o, i) : Math.min(o, i), i = Math.round(100 * i) / 100, u._webAudio ? e._volume = i : u.volume(i, e._id, !0), a && (u._volume = i), (o < n && i <= o || o > n && i >= o) && (clearInterval(e._interval), e._interval = null, e._fadeTo = null, u.volume(o, e._id), u._emit("fade", e._id));
        }, s);
      },
      _stopFade: function _stopFade(e) {
        var o = this,
            t = o._soundById(e);

        return t && t._interval && (o._webAudio && t._node.gain.cancelScheduledValues(n.ctx.currentTime), clearInterval(t._interval), t._interval = null, o.volume(t._fadeTo, e), t._fadeTo = null, o._emit("fade", e)), o;
      },
      loop: function loop() {
        var e,
            n,
            o,
            t = this,
            r = arguments;
        if (0 === r.length) return t._loop;

        if (1 === r.length) {
          if ("boolean" != typeof r[0]) return !!(o = t._soundById(parseInt(r[0], 10))) && o._loop;
          e = r[0], t._loop = e;
        } else 2 === r.length && (e = r[0], n = parseInt(r[1], 10));

        for (var a = t._getSoundIds(n), u = 0; u < a.length; u++) {
          (o = t._soundById(a[u])) && (o._loop = e, t._webAudio && o._node && o._node.bufferSource && (o._node.bufferSource.loop = e, e && (o._node.bufferSource.loopStart = o._start || 0, o._node.bufferSource.loopEnd = o._stop)));
        }

        return t;
      },
      rate: function rate() {
        var e,
            o,
            t = this,
            r = arguments;
        if (0 === r.length) o = t._sounds[0]._id;else if (1 === r.length) {
          var a = t._getSoundIds(),
              u = a.indexOf(r[0]);

          u >= 0 ? o = parseInt(r[0], 10) : e = parseFloat(r[0]);
        } else 2 === r.length && (e = parseFloat(r[0]), o = parseInt(r[1], 10));
        var i;
        if ("number" != typeof e) return i = t._soundById(o), i ? i._rate : t._rate;
        if ("loaded" !== t._state || t._playLock) return t._queue.push({
          event: "rate",
          action: function action() {
            t.rate.apply(t, r);
          }
        }), t;
        void 0 === o && (t._rate = e), o = t._getSoundIds(o);

        for (var d = 0; d < o.length; d++) {
          if (i = t._soundById(o[d])) {
            t.playing(o[d]) && (i._rateSeek = t.seek(o[d]), i._playStart = t._webAudio ? n.ctx.currentTime : i._playStart), i._rate = e, t._webAudio && i._node && i._node.bufferSource ? i._node.bufferSource.playbackRate.setValueAtTime(e, n.ctx.currentTime) : i._node && (i._node.playbackRate = e);

            var _ = t.seek(o[d]),
                s = (t._sprite[i._sprite][0] + t._sprite[i._sprite][1]) / 1e3 - _,
                l = 1e3 * s / Math.abs(i._rate);

            !t._endTimers[o[d]] && i._paused || (t._clearTimer(o[d]), t._endTimers[o[d]] = setTimeout(t._ended.bind(t, i), l)), t._emit("rate", i._id);
          }
        }

        return t;
      },
      seek: function seek() {
        var e,
            o,
            t = this,
            r = arguments;
        if (0 === r.length) o = t._sounds[0]._id;else if (1 === r.length) {
          var a = t._getSoundIds(),
              u = a.indexOf(r[0]);

          u >= 0 ? o = parseInt(r[0], 10) : t._sounds.length && (o = t._sounds[0]._id, e = parseFloat(r[0]));
        } else 2 === r.length && (e = parseFloat(r[0]), o = parseInt(r[1], 10));
        if (void 0 === o) return t;
        if ("loaded" !== t._state || t._playLock) return t._queue.push({
          event: "seek",
          action: function action() {
            t.seek.apply(t, r);
          }
        }), t;

        var i = t._soundById(o);

        if (i) {
          if (!("number" == typeof e && e >= 0)) {
            if (t._webAudio) {
              var d = t.playing(o) ? n.ctx.currentTime - i._playStart : 0,
                  _ = i._rateSeek ? i._rateSeek - i._seek : 0;

              return i._seek + (_ + d * Math.abs(i._rate));
            }

            return i._node.currentTime;
          }

          var s = t.playing(o);
          s && t.pause(o, !0), i._seek = e, i._ended = !1, t._clearTimer(o), t._webAudio || !i._node || isNaN(i._node.duration) || (i._node.currentTime = e);

          var l = function l() {
            t._emit("seek", o), s && t.play(o, !0);
          };

          if (s && !t._webAudio) {
            var c = function c() {
              t._playLock ? setTimeout(c, 0) : l();
            };

            setTimeout(c, 0);
          } else l();
        }

        return t;
      },
      playing: function playing(e) {
        var n = this;

        if ("number" == typeof e) {
          var o = n._soundById(e);

          return !!o && !o._paused;
        }

        for (var t = 0; t < n._sounds.length; t++) {
          if (!n._sounds[t]._paused) return !0;
        }

        return !1;
      },
      duration: function duration(e) {
        var n = this,
            o = n._duration,
            t = n._soundById(e);

        return t && (o = n._sprite[t._sprite][1] / 1e3), o;
      },
      state: function state() {
        return this._state;
      },
      unload: function unload() {
        for (var e = this, o = e._sounds, t = 0; t < o.length; t++) {
          o[t]._paused || e.stop(o[t]._id), e._webAudio || (e._clearSound(o[t]._node), o[t]._node.removeEventListener("error", o[t]._errorFn, !1), o[t]._node.removeEventListener(n._canPlayEvent, o[t]._loadFn, !1), n._releaseHtml5Audio(o[t]._node)), delete o[t]._node, e._clearTimer(o[t]._id);
        }

        var a = n._howls.indexOf(e);

        a >= 0 && n._howls.splice(a, 1);
        var u = !0;

        for (t = 0; t < n._howls.length; t++) {
          if (n._howls[t]._src === e._src || e._src.indexOf(n._howls[t]._src) >= 0) {
            u = !1;
            break;
          }
        }

        return r && u && delete r[e._src], n.noAudio = !1, e._state = "unloaded", e._sounds = [], e = null, null;
      },
      on: function on(e, n, o, t) {
        var r = this,
            a = r["_on" + e];
        return "function" == typeof n && a.push(t ? {
          id: o,
          fn: n,
          once: t
        } : {
          id: o,
          fn: n
        }), r;
      },
      off: function off(e, n, o) {
        var t = this,
            r = t["_on" + e],
            a = 0;
        if ("number" == typeof n && (o = n, n = null), n || o) for (a = 0; a < r.length; a++) {
          var u = o === r[a].id;

          if (n === r[a].fn && u || !n && u) {
            r.splice(a, 1);
            break;
          }
        } else if (e) t["_on" + e] = [];else {
          var i = Object.keys(t);

          for (a = 0; a < i.length; a++) {
            0 === i[a].indexOf("_on") && Array.isArray(t[i[a]]) && (t[i[a]] = []);
          }
        }
        return t;
      },
      once: function once(e, n, o) {
        var t = this;
        return t.on(e, n, o, 1), t;
      },
      _emit: function _emit(e, n, o) {
        for (var t = this, r = t["_on" + e], a = r.length - 1; a >= 0; a--) {
          r[a].id && r[a].id !== n && "load" !== e || (setTimeout(function (e) {
            e.call(this, n, o);
          }.bind(t, r[a].fn), 0), r[a].once && t.off(e, r[a].fn, r[a].id));
        }

        return t._loadQueue(e), t;
      },
      _loadQueue: function _loadQueue(e) {
        var n = this;

        if (n._queue.length > 0) {
          var o = n._queue[0];
          o.event === e && (n._queue.shift(), n._loadQueue()), e || o.action();
        }

        return n;
      },
      _ended: function _ended(e) {
        var o = this,
            t = e._sprite;
        if (!o._webAudio && e._node && !e._node.paused && !e._node.ended && e._node.currentTime < e._stop) return setTimeout(o._ended.bind(o, e), 100), o;
        var r = !(!e._loop && !o._sprite[t][2]);

        if (o._emit("end", e._id), !o._webAudio && r && o.stop(e._id, !0).play(e._id), o._webAudio && r) {
          o._emit("play", e._id), e._seek = e._start || 0, e._rateSeek = 0, e._playStart = n.ctx.currentTime;
          var a = 1e3 * (e._stop - e._start) / Math.abs(e._rate);
          o._endTimers[e._id] = setTimeout(o._ended.bind(o, e), a);
        }

        return o._webAudio && !r && (e._paused = !0, e._ended = !0, e._seek = e._start || 0, e._rateSeek = 0, o._clearTimer(e._id), o._cleanBuffer(e._node), n._autoSuspend()), o._webAudio || r || o.stop(e._id, !0), o;
      },
      _clearTimer: function _clearTimer(e) {
        var n = this;

        if (n._endTimers[e]) {
          if ("function" != typeof n._endTimers[e]) clearTimeout(n._endTimers[e]);else {
            var o = n._soundById(e);

            o && o._node && o._node.removeEventListener("ended", n._endTimers[e], !1);
          }
          delete n._endTimers[e];
        }

        return n;
      },
      _soundById: function _soundById(e) {
        for (var n = this, o = 0; o < n._sounds.length; o++) {
          if (e === n._sounds[o]._id) return n._sounds[o];
        }

        return null;
      },
      _inactiveSound: function _inactiveSound() {
        var e = this;

        e._drain();

        for (var n = 0; n < e._sounds.length; n++) {
          if (e._sounds[n]._ended) return e._sounds[n].reset();
        }

        return new t(e);
      },
      _drain: function _drain() {
        var e = this,
            n = e._pool,
            o = 0,
            t = 0;

        if (!(e._sounds.length < n)) {
          for (t = 0; t < e._sounds.length; t++) {
            e._sounds[t]._ended && o++;
          }

          for (t = e._sounds.length - 1; t >= 0; t--) {
            if (o <= n) return;
            e._sounds[t]._ended && (e._webAudio && e._sounds[t]._node && e._sounds[t]._node.disconnect(0), e._sounds.splice(t, 1), o--);
          }
        }
      },
      _getSoundIds: function _getSoundIds(e) {
        var n = this;

        if (void 0 === e) {
          for (var o = [], t = 0; t < n._sounds.length; t++) {
            o.push(n._sounds[t]._id);
          }

          return o;
        }

        return [e];
      },
      _refreshBuffer: function _refreshBuffer(e) {
        var o = this;
        return e._node.bufferSource = n.ctx.createBufferSource(), e._node.bufferSource.buffer = r[o._src], e._panner ? e._node.bufferSource.connect(e._panner) : e._node.bufferSource.connect(e._node), e._node.bufferSource.loop = e._loop, e._loop && (e._node.bufferSource.loopStart = e._start || 0, e._node.bufferSource.loopEnd = e._stop || 0), e._node.bufferSource.playbackRate.setValueAtTime(e._rate, n.ctx.currentTime), o;
      },
      _cleanBuffer: function _cleanBuffer(e) {
        var o = this,
            t = n._navigator && n._navigator.vendor.indexOf("Apple") >= 0;
        if (n._scratchBuffer && e.bufferSource && (e.bufferSource.onended = null, e.bufferSource.disconnect(0), t)) try {
          e.bufferSource.buffer = n._scratchBuffer;
        } catch (e) {}
        return e.bufferSource = null, o;
      },
      _clearSound: function _clearSound(e) {
        /MSIE |Trident\//.test(n._navigator && n._navigator.userAgent) || (e.src = "data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA");
      }
    };

    var t = function t(e) {
      this._parent = e, this.init();
    };

    t.prototype = {
      init: function init() {
        var e = this,
            o = e._parent;
        return e._muted = o._muted, e._loop = o._loop, e._volume = o._volume, e._rate = o._rate, e._seek = 0, e._paused = !0, e._ended = !0, e._sprite = "__default", e._id = ++n._counter, o._sounds.push(e), e.create(), e;
      },
      create: function create() {
        var e = this,
            o = e._parent,
            t = n._muted || e._muted || e._parent._muted ? 0 : e._volume;
        return o._webAudio ? (e._node = void 0 === n.ctx.createGain ? n.ctx.createGainNode() : n.ctx.createGain(), e._node.gain.setValueAtTime(t, n.ctx.currentTime), e._node.paused = !0, e._node.connect(n.masterGain)) : n.noAudio || (e._node = n._obtainHtml5Audio(), e._errorFn = e._errorListener.bind(e), e._node.addEventListener("error", e._errorFn, !1), e._loadFn = e._loadListener.bind(e), e._node.addEventListener(n._canPlayEvent, e._loadFn, !1), e._node.src = o._src, e._node.preload = !0 === o._preload ? "auto" : o._preload, e._node.volume = t * n.volume(), e._node.load()), e;
      },
      reset: function reset() {
        var e = this,
            o = e._parent;
        return e._muted = o._muted, e._loop = o._loop, e._volume = o._volume, e._rate = o._rate, e._seek = 0, e._rateSeek = 0, e._paused = !0, e._ended = !0, e._sprite = "__default", e._id = ++n._counter, e;
      },
      _errorListener: function _errorListener() {
        var e = this;
        e._parent._emit("loaderror", e._id, e._node.error ? e._node.error.code : 0), e._node.removeEventListener("error", e._errorFn, !1);
      },
      _loadListener: function _loadListener() {
        var e = this,
            o = e._parent;
        o._duration = Math.ceil(10 * e._node.duration) / 10, 0 === Object.keys(o._sprite).length && (o._sprite = {
          __default: [0, 1e3 * o._duration]
        }), "loaded" !== o._state && (o._state = "loaded", o._emit("load"), o._loadQueue()), e._node.removeEventListener(n._canPlayEvent, e._loadFn, !1);
      }
    };

    var r = {},
        a = function a(e) {
      var n = e._src;
      if (r[n]) return e._duration = r[n].duration, void d(e);

      if (/^data:[^;]+;base64,/.test(n)) {
        for (var o = atob(n.split(",")[1]), t = new Uint8Array(o.length), a = 0; a < o.length; ++a) {
          t[a] = o.charCodeAt(a);
        }

        i(t.buffer, e);
      } else {
        var _ = new XMLHttpRequest();

        _.open(e._xhr.method, n, !0), _.withCredentials = e._xhr.withCredentials, _.responseType = "arraybuffer", e._xhr.headers && Object.keys(e._xhr.headers).forEach(function (n) {
          _.setRequestHeader(n, e._xhr.headers[n]);
        }), _.onload = function () {
          var n = (_.status + "")[0];
          if ("0" !== n && "2" !== n && "3" !== n) return void e._emit("loaderror", null, "Failed loading audio file with status: " + _.status + ".");
          i(_.response, e);
        }, _.onerror = function () {
          e._webAudio && (e._html5 = !0, e._webAudio = !1, e._sounds = [], delete r[n], e.load());
        }, u(_);
      }
    },
        u = function u(e) {
      try {
        e.send();
      } catch (n) {
        e.onerror();
      }
    },
        i = function i(e, o) {
      var t = function t() {
        o._emit("loaderror", null, "Decoding audio data failed.");
      },
          a = function a(e) {
        e && o._sounds.length > 0 ? (r[o._src] = e, d(o, e)) : t();
      };

      "undefined" != typeof Promise && 1 === n.ctx.decodeAudioData.length ? n.ctx.decodeAudioData(e).then(a)["catch"](t) : n.ctx.decodeAudioData(e, a, t);
    },
        d = function d(e, n) {
      n && !e._duration && (e._duration = n.duration), 0 === Object.keys(e._sprite).length && (e._sprite = {
        __default: [0, 1e3 * e._duration]
      }), "loaded" !== e._state && (e._state = "loaded", e._emit("load"), e._loadQueue());
    },
        _ = function _() {
      if (n.usingWebAudio) {
        try {
          "undefined" != typeof AudioContext ? n.ctx = new AudioContext() : "undefined" != typeof webkitAudioContext ? n.ctx = new webkitAudioContext() : n.usingWebAudio = !1;
        } catch (e) {
          n.usingWebAudio = !1;
        }

        n.ctx || (n.usingWebAudio = !1);

        var e = /iP(hone|od|ad)/.test(n._navigator && n._navigator.platform),
            o = n._navigator && n._navigator.appVersion.match(/OS (\d+)_(\d+)_?(\d+)?/),
            t = o ? parseInt(o[1], 10) : null;

        if (e && t && t < 9) {
          var r = /safari/.test(n._navigator && n._navigator.userAgent.toLowerCase());
          n._navigator && !r && (n.usingWebAudio = !1);
        }

        n.usingWebAudio && (n.masterGain = void 0 === n.ctx.createGain ? n.ctx.createGainNode() : n.ctx.createGain(), n.masterGain.gain.setValueAtTime(n._muted ? 0 : n._volume, n.ctx.currentTime), n.masterGain.connect(n.ctx.destination)), n._setup();
      }
    };

    "function" == typeof define && define.amd && define([], function () {
      return {
        Howler: n,
        Howl: o
      };
    }), "undefined" != typeof exports && (exports.Howler = n, exports.Howl = o), "undefined" != typeof global ? (global.HowlerGlobal = e, global.Howler = n, global.Howl = o, global.Sound = t) : "undefined" != typeof window && (window.HowlerGlobal = e, window.Howler = n, window.Howl = o, window.Sound = t);
  }();
  /*! Spatial Plugin */

  !function () {

    HowlerGlobal.prototype._pos = [0, 0, 0], HowlerGlobal.prototype._orientation = [0, 0, -1, 0, 1, 0], HowlerGlobal.prototype.stereo = function (e) {
      var n = this;
      if (!n.ctx || !n.ctx.listener) return n;

      for (var t = n._howls.length - 1; t >= 0; t--) {
        n._howls[t].stereo(e);
      }

      return n;
    }, HowlerGlobal.prototype.pos = function (e, n, t) {
      var r = this;
      return r.ctx && r.ctx.listener ? (n = "number" != typeof n ? r._pos[1] : n, t = "number" != typeof t ? r._pos[2] : t, "number" != typeof e ? r._pos : (r._pos = [e, n, t], void 0 !== r.ctx.listener.positionX ? (r.ctx.listener.positionX.setTargetAtTime(r._pos[0], Howler.ctx.currentTime, .1), r.ctx.listener.positionY.setTargetAtTime(r._pos[1], Howler.ctx.currentTime, .1), r.ctx.listener.positionZ.setTargetAtTime(r._pos[2], Howler.ctx.currentTime, .1)) : r.ctx.listener.setPosition(r._pos[0], r._pos[1], r._pos[2]), r)) : r;
    }, HowlerGlobal.prototype.orientation = function (e, n, t, r, o, i) {
      var a = this;
      if (!a.ctx || !a.ctx.listener) return a;
      var s = a._orientation;
      return n = "number" != typeof n ? s[1] : n, t = "number" != typeof t ? s[2] : t, r = "number" != typeof r ? s[3] : r, o = "number" != typeof o ? s[4] : o, i = "number" != typeof i ? s[5] : i, "number" != typeof e ? s : (a._orientation = [e, n, t, r, o, i], void 0 !== a.ctx.listener.forwardX ? (a.ctx.listener.forwardX.setTargetAtTime(e, Howler.ctx.currentTime, .1), a.ctx.listener.forwardY.setTargetAtTime(n, Howler.ctx.currentTime, .1), a.ctx.listener.forwardZ.setTargetAtTime(t, Howler.ctx.currentTime, .1), a.ctx.listener.upX.setTargetAtTime(r, Howler.ctx.currentTime, .1), a.ctx.listener.upY.setTargetAtTime(o, Howler.ctx.currentTime, .1), a.ctx.listener.upZ.setTargetAtTime(i, Howler.ctx.currentTime, .1)) : a.ctx.listener.setOrientation(e, n, t, r, o, i), a);
    }, Howl.prototype.init = function (e) {
      return function (n) {
        var t = this;
        return t._orientation = n.orientation || [1, 0, 0], t._stereo = n.stereo || null, t._pos = n.pos || null, t._pannerAttr = {
          coneInnerAngle: void 0 !== n.coneInnerAngle ? n.coneInnerAngle : 360,
          coneOuterAngle: void 0 !== n.coneOuterAngle ? n.coneOuterAngle : 360,
          coneOuterGain: void 0 !== n.coneOuterGain ? n.coneOuterGain : 0,
          distanceModel: void 0 !== n.distanceModel ? n.distanceModel : "inverse",
          maxDistance: void 0 !== n.maxDistance ? n.maxDistance : 1e4,
          panningModel: void 0 !== n.panningModel ? n.panningModel : "HRTF",
          refDistance: void 0 !== n.refDistance ? n.refDistance : 1,
          rolloffFactor: void 0 !== n.rolloffFactor ? n.rolloffFactor : 1
        }, t._onstereo = n.onstereo ? [{
          fn: n.onstereo
        }] : [], t._onpos = n.onpos ? [{
          fn: n.onpos
        }] : [], t._onorientation = n.onorientation ? [{
          fn: n.onorientation
        }] : [], e.call(this, n);
      };
    }(Howl.prototype.init), Howl.prototype.stereo = function (n, t) {
      var r = this;
      if (!r._webAudio) return r;
      if ("loaded" !== r._state) return r._queue.push({
        event: "stereo",
        action: function action() {
          r.stereo(n, t);
        }
      }), r;
      var o = void 0 === Howler.ctx.createStereoPanner ? "spatial" : "stereo";

      if (void 0 === t) {
        if ("number" != typeof n) return r._stereo;
        r._stereo = n, r._pos = [n, 0, 0];
      }

      for (var i = r._getSoundIds(t), a = 0; a < i.length; a++) {
        var s = r._soundById(i[a]);

        if (s) {
          if ("number" != typeof n) return s._stereo;
          s._stereo = n, s._pos = [n, 0, 0], s._node && (s._pannerAttr.panningModel = "equalpower", s._panner && s._panner.pan || e(s, o), "spatial" === o ? void 0 !== s._panner.positionX ? (s._panner.positionX.setValueAtTime(n, Howler.ctx.currentTime), s._panner.positionY.setValueAtTime(0, Howler.ctx.currentTime), s._panner.positionZ.setValueAtTime(0, Howler.ctx.currentTime)) : s._panner.setPosition(n, 0, 0) : s._panner.pan.setValueAtTime(n, Howler.ctx.currentTime)), r._emit("stereo", s._id);
        }
      }

      return r;
    }, Howl.prototype.pos = function (n, t, r, o) {
      var i = this;
      if (!i._webAudio) return i;
      if ("loaded" !== i._state) return i._queue.push({
        event: "pos",
        action: function action() {
          i.pos(n, t, r, o);
        }
      }), i;

      if (t = "number" != typeof t ? 0 : t, r = "number" != typeof r ? -.5 : r, void 0 === o) {
        if ("number" != typeof n) return i._pos;
        i._pos = [n, t, r];
      }

      for (var a = i._getSoundIds(o), s = 0; s < a.length; s++) {
        var p = i._soundById(a[s]);

        if (p) {
          if ("number" != typeof n) return p._pos;
          p._pos = [n, t, r], p._node && (p._panner && !p._panner.pan || e(p, "spatial"), void 0 !== p._panner.positionX ? (p._panner.positionX.setValueAtTime(n, Howler.ctx.currentTime), p._panner.positionY.setValueAtTime(t, Howler.ctx.currentTime), p._panner.positionZ.setValueAtTime(r, Howler.ctx.currentTime)) : p._panner.setPosition(n, t, r)), i._emit("pos", p._id);
        }
      }

      return i;
    }, Howl.prototype.orientation = function (n, t, r, o) {
      var i = this;
      if (!i._webAudio) return i;
      if ("loaded" !== i._state) return i._queue.push({
        event: "orientation",
        action: function action() {
          i.orientation(n, t, r, o);
        }
      }), i;

      if (t = "number" != typeof t ? i._orientation[1] : t, r = "number" != typeof r ? i._orientation[2] : r, void 0 === o) {
        if ("number" != typeof n) return i._orientation;
        i._orientation = [n, t, r];
      }

      for (var a = i._getSoundIds(o), s = 0; s < a.length; s++) {
        var p = i._soundById(a[s]);

        if (p) {
          if ("number" != typeof n) return p._orientation;
          p._orientation = [n, t, r], p._node && (p._panner || (p._pos || (p._pos = i._pos || [0, 0, -.5]), e(p, "spatial")), void 0 !== p._panner.orientationX ? (p._panner.orientationX.setValueAtTime(n, Howler.ctx.currentTime), p._panner.orientationY.setValueAtTime(t, Howler.ctx.currentTime), p._panner.orientationZ.setValueAtTime(r, Howler.ctx.currentTime)) : p._panner.setOrientation(n, t, r)), i._emit("orientation", p._id);
        }
      }

      return i;
    }, Howl.prototype.pannerAttr = function () {
      var n,
          t,
          r,
          o = this,
          i = arguments;
      if (!o._webAudio) return o;
      if (0 === i.length) return o._pannerAttr;

      if (1 === i.length) {
        if ("object" != _typeof(i[0])) return r = o._soundById(parseInt(i[0], 10)), r ? r._pannerAttr : o._pannerAttr;
        n = i[0], void 0 === t && (n.pannerAttr || (n.pannerAttr = {
          coneInnerAngle: n.coneInnerAngle,
          coneOuterAngle: n.coneOuterAngle,
          coneOuterGain: n.coneOuterGain,
          distanceModel: n.distanceModel,
          maxDistance: n.maxDistance,
          refDistance: n.refDistance,
          rolloffFactor: n.rolloffFactor,
          panningModel: n.panningModel
        }), o._pannerAttr = {
          coneInnerAngle: void 0 !== n.pannerAttr.coneInnerAngle ? n.pannerAttr.coneInnerAngle : o._coneInnerAngle,
          coneOuterAngle: void 0 !== n.pannerAttr.coneOuterAngle ? n.pannerAttr.coneOuterAngle : o._coneOuterAngle,
          coneOuterGain: void 0 !== n.pannerAttr.coneOuterGain ? n.pannerAttr.coneOuterGain : o._coneOuterGain,
          distanceModel: void 0 !== n.pannerAttr.distanceModel ? n.pannerAttr.distanceModel : o._distanceModel,
          maxDistance: void 0 !== n.pannerAttr.maxDistance ? n.pannerAttr.maxDistance : o._maxDistance,
          refDistance: void 0 !== n.pannerAttr.refDistance ? n.pannerAttr.refDistance : o._refDistance,
          rolloffFactor: void 0 !== n.pannerAttr.rolloffFactor ? n.pannerAttr.rolloffFactor : o._rolloffFactor,
          panningModel: void 0 !== n.pannerAttr.panningModel ? n.pannerAttr.panningModel : o._panningModel
        });
      } else 2 === i.length && (n = i[0], t = parseInt(i[1], 10));

      for (var a = o._getSoundIds(t), s = 0; s < a.length; s++) {
        if (r = o._soundById(a[s])) {
          var p = r._pannerAttr;
          p = {
            coneInnerAngle: void 0 !== n.coneInnerAngle ? n.coneInnerAngle : p.coneInnerAngle,
            coneOuterAngle: void 0 !== n.coneOuterAngle ? n.coneOuterAngle : p.coneOuterAngle,
            coneOuterGain: void 0 !== n.coneOuterGain ? n.coneOuterGain : p.coneOuterGain,
            distanceModel: void 0 !== n.distanceModel ? n.distanceModel : p.distanceModel,
            maxDistance: void 0 !== n.maxDistance ? n.maxDistance : p.maxDistance,
            refDistance: void 0 !== n.refDistance ? n.refDistance : p.refDistance,
            rolloffFactor: void 0 !== n.rolloffFactor ? n.rolloffFactor : p.rolloffFactor,
            panningModel: void 0 !== n.panningModel ? n.panningModel : p.panningModel
          };
          var c = r._panner;
          c ? (c.coneInnerAngle = p.coneInnerAngle, c.coneOuterAngle = p.coneOuterAngle, c.coneOuterGain = p.coneOuterGain, c.distanceModel = p.distanceModel, c.maxDistance = p.maxDistance, c.refDistance = p.refDistance, c.rolloffFactor = p.rolloffFactor, c.panningModel = p.panningModel) : (r._pos || (r._pos = o._pos || [0, 0, -.5]), e(r, "spatial"));
        }
      }

      return o;
    }, Sound.prototype.init = function (e) {
      return function () {
        var n = this,
            t = n._parent;
        n._orientation = t._orientation, n._stereo = t._stereo, n._pos = t._pos, n._pannerAttr = t._pannerAttr, e.call(this), n._stereo ? t.stereo(n._stereo) : n._pos && t.pos(n._pos[0], n._pos[1], n._pos[2], n._id);
      };
    }(Sound.prototype.init), Sound.prototype.reset = function (e) {
      return function () {
        var n = this,
            t = n._parent;
        return n._orientation = t._orientation, n._stereo = t._stereo, n._pos = t._pos, n._pannerAttr = t._pannerAttr, n._stereo ? t.stereo(n._stereo) : n._pos ? t.pos(n._pos[0], n._pos[1], n._pos[2], n._id) : n._panner && (n._panner.disconnect(0), n._panner = void 0, t._refreshBuffer(n)), e.call(this);
      };
    }(Sound.prototype.reset);

    var e = function e(_e, n) {
      n = n || "spatial", "spatial" === n ? (_e._panner = Howler.ctx.createPanner(), _e._panner.coneInnerAngle = _e._pannerAttr.coneInnerAngle, _e._panner.coneOuterAngle = _e._pannerAttr.coneOuterAngle, _e._panner.coneOuterGain = _e._pannerAttr.coneOuterGain, _e._panner.distanceModel = _e._pannerAttr.distanceModel, _e._panner.maxDistance = _e._pannerAttr.maxDistance, _e._panner.refDistance = _e._pannerAttr.refDistance, _e._panner.rolloffFactor = _e._pannerAttr.rolloffFactor, _e._panner.panningModel = _e._pannerAttr.panningModel, void 0 !== _e._panner.positionX ? (_e._panner.positionX.setValueAtTime(_e._pos[0], Howler.ctx.currentTime), _e._panner.positionY.setValueAtTime(_e._pos[1], Howler.ctx.currentTime), _e._panner.positionZ.setValueAtTime(_e._pos[2], Howler.ctx.currentTime)) : _e._panner.setPosition(_e._pos[0], _e._pos[1], _e._pos[2]), void 0 !== _e._panner.orientationX ? (_e._panner.orientationX.setValueAtTime(_e._orientation[0], Howler.ctx.currentTime), _e._panner.orientationY.setValueAtTime(_e._orientation[1], Howler.ctx.currentTime), _e._panner.orientationZ.setValueAtTime(_e._orientation[2], Howler.ctx.currentTime)) : _e._panner.setOrientation(_e._orientation[0], _e._orientation[1], _e._orientation[2])) : (_e._panner = Howler.ctx.createStereoPanner(), _e._panner.pan.setValueAtTime(_e._stereo, Howler.ctx.currentTime)), _e._panner.connect(_e._node), _e._paused || _e._parent.pause(_e._id, !0).play(_e._id, !0);
    };
  }();

  /**
  * matter-js 0.14.2 by @liabru 2018-06-11
  * http://brm.io/matter-js/
  * License MIT
  */
  !function (e) {
    if ("object" == (typeof exports === "undefined" ? "undefined" : _typeof(exports)) && "undefined" != typeof module) module.exports = e();else if ("function" == typeof define && define.amd) define([], e);else {
      var t;
      t = "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : this, t.Matter = e();
    }
  }(function () {
    return function () {
      function e(t, n, o) {
        function i(s, a) {
          if (!n[s]) {
            if (!t[s]) {
              var l = "function" == typeof require && require;
              if (!a && l) return l(s, !0);
              if (r) return r(s, !0);
              var c = new Error("Cannot find module '" + s + "'");
              throw c.code = "MODULE_NOT_FOUND", c;
            }

            var d = n[s] = {
              exports: {}
            };
            t[s][0].call(d.exports, function (e) {
              return i(t[s][1][e] || e);
            }, d, d.exports, e, t, n, o);
          }

          return n[s].exports;
        }

        for (var r = "function" == typeof require && require, s = 0; s < o.length; s++) {
          i(o[s]);
        }

        return i;
      }

      return e;
    }()({
      1: [function (e, t, n) {
        var o = {};
        t.exports = o;
        var i = e("../geometry/Vertices"),
            r = e("../geometry/Vector"),
            s = e("../core/Sleeping"),
            a = (e("../render/Render"), e("../core/Common")),
            l = e("../geometry/Bounds"),
            c = e("../geometry/Axes");
        !function () {
          o._inertiaScale = 4, o._nextCollidingGroupId = 1, o._nextNonCollidingGroupId = -1, o._nextCategory = 1, o.create = function (t) {
            var n = {
              id: a.nextId(),
              type: "body",
              label: "Body",
              parts: [],
              plugin: {},
              angle: 0,
              vertices: i.fromPath("L 0 0 L 40 0 L 40 40 L 0 40"),
              position: {
                x: 0,
                y: 0
              },
              force: {
                x: 0,
                y: 0
              },
              torque: 0,
              positionImpulse: {
                x: 0,
                y: 0
              },
              constraintImpulse: {
                x: 0,
                y: 0,
                angle: 0
              },
              totalContacts: 0,
              speed: 0,
              angularSpeed: 0,
              velocity: {
                x: 0,
                y: 0
              },
              angularVelocity: 0,
              isSensor: !1,
              isStatic: !1,
              isSleeping: !1,
              motion: 0,
              sleepThreshold: 60,
              density: .001,
              restitution: 0,
              friction: .1,
              frictionStatic: .5,
              frictionAir: .01,
              collisionFilter: {
                category: 1,
                mask: 4294967295,
                group: 0
              },
              slop: .05,
              timeScale: 1,
              render: {
                visible: !0,
                opacity: 1,
                sprite: {
                  xScale: 1,
                  yScale: 1,
                  xOffset: 0,
                  yOffset: 0
                },
                lineWidth: 0
              }
            },
                o = a.extend(n, t);
            return e(o, t), o;
          }, o.nextGroup = function (e) {
            return e ? o._nextNonCollidingGroupId-- : o._nextCollidingGroupId++;
          }, o.nextCategory = function () {
            return o._nextCategory = o._nextCategory << 1, o._nextCategory;
          };

          var e = function e(_e, t) {
            t = t || {}, o.set(_e, {
              bounds: _e.bounds || l.create(_e.vertices),
              positionPrev: _e.positionPrev || r.clone(_e.position),
              anglePrev: _e.anglePrev || _e.angle,
              vertices: _e.vertices,
              parts: _e.parts || [_e],
              isStatic: _e.isStatic,
              isSleeping: _e.isSleeping,
              parent: _e.parent || _e
            }), i.rotate(_e.vertices, _e.angle, _e.position), c.rotate(_e.axes, _e.angle), l.update(_e.bounds, _e.vertices, _e.velocity), o.set(_e, {
              axes: t.axes || _e.axes,
              area: t.area || _e.area,
              mass: t.mass || _e.mass,
              inertia: t.inertia || _e.inertia
            });
            var n = _e.isStatic ? "#2e2b44" : a.choose(["#006BA6", "#0496FF", "#FFBC42", "#D81159", "#8F2D56"]);
            _e.render.fillStyle = _e.render.fillStyle || n, _e.render.strokeStyle = _e.render.strokeStyle || "#000", _e.render.sprite.xOffset += -(_e.bounds.min.x - _e.position.x) / (_e.bounds.max.x - _e.bounds.min.x), _e.render.sprite.yOffset += -(_e.bounds.min.y - _e.position.y) / (_e.bounds.max.y - _e.bounds.min.y);
          };

          o.set = function (e, t, n) {
            var i;
            "string" == typeof t && (i = t, t = {}, t[i] = n);

            for (i in t) {
              if (n = t[i], t.hasOwnProperty(i)) switch (i) {
                case "isStatic":
                  o.setStatic(e, n);
                  break;

                case "isSleeping":
                  s.set(e, n);
                  break;

                case "mass":
                  o.setMass(e, n);
                  break;

                case "density":
                  o.setDensity(e, n);
                  break;

                case "inertia":
                  o.setInertia(e, n);
                  break;

                case "vertices":
                  o.setVertices(e, n);
                  break;

                case "position":
                  o.setPosition(e, n);
                  break;

                case "angle":
                  o.setAngle(e, n);
                  break;

                case "velocity":
                  o.setVelocity(e, n);
                  break;

                case "angularVelocity":
                  o.setAngularVelocity(e, n);
                  break;

                case "parts":
                  o.setParts(e, n);
                  break;

                default:
                  e[i] = n;
              }
            }
          }, o.setStatic = function (e, t) {
            for (var n = 0; n < e.parts.length; n++) {
              var o = e.parts[n];
              o.isStatic = t, t ? (o._original = {
                restitution: o.restitution,
                friction: o.friction,
                mass: o.mass,
                inertia: o.inertia,
                density: o.density,
                inverseMass: o.inverseMass,
                inverseInertia: o.inverseInertia
              }, o.restitution = 0, o.friction = 1, o.mass = o.inertia = o.density = 1 / 0, o.inverseMass = o.inverseInertia = 0, o.positionPrev.x = o.position.x, o.positionPrev.y = o.position.y, o.anglePrev = o.angle, o.angularVelocity = 0, o.speed = 0, o.angularSpeed = 0, o.motion = 0) : o._original && (o.restitution = o._original.restitution, o.friction = o._original.friction, o.mass = o._original.mass, o.inertia = o._original.inertia, o.density = o._original.density, o.inverseMass = o._original.inverseMass, o.inverseInertia = o._original.inverseInertia, delete o._original);
            }
          }, o.setMass = function (e, t) {
            var n = e.inertia / (e.mass / 6);
            e.inertia = n * (t / 6), e.inverseInertia = 1 / e.inertia, e.mass = t, e.inverseMass = 1 / e.mass, e.density = e.mass / e.area;
          }, o.setDensity = function (e, t) {
            o.setMass(e, t * e.area), e.density = t;
          }, o.setInertia = function (e, t) {
            e.inertia = t, e.inverseInertia = 1 / e.inertia;
          }, o.setVertices = function (e, t) {
            t[0].body === e ? e.vertices = t : e.vertices = i.create(t, e), e.axes = c.fromVertices(e.vertices), e.area = i.area(e.vertices), o.setMass(e, e.density * e.area);
            var n = i.centre(e.vertices);
            i.translate(e.vertices, n, -1), o.setInertia(e, o._inertiaScale * i.inertia(e.vertices, e.mass)), i.translate(e.vertices, e.position), l.update(e.bounds, e.vertices, e.velocity);
          }, o.setParts = function (e, t, n) {
            var r;

            for (t = t.slice(0), e.parts.length = 0, e.parts.push(e), e.parent = e, r = 0; r < t.length; r++) {
              var s = t[r];
              s !== e && (s.parent = e, e.parts.push(s));
            }

            if (1 !== e.parts.length) {
              if (n = void 0 === n || n) {
                var a = [];

                for (r = 0; r < t.length; r++) {
                  a = a.concat(t[r].vertices);
                }

                i.clockwiseSort(a);
                var l = i.hull(a),
                    c = i.centre(l);
                o.setVertices(e, l), i.translate(e.vertices, c);
              }

              var d = o._totalProperties(e);

              e.area = d.area, e.parent = e, e.position.x = d.centre.x, e.position.y = d.centre.y, e.positionPrev.x = d.centre.x, e.positionPrev.y = d.centre.y, o.setMass(e, d.mass), o.setInertia(e, d.inertia), o.setPosition(e, d.centre);
            }
          }, o.setPosition = function (e, t) {
            var n = r.sub(t, e.position);
            e.positionPrev.x += n.x, e.positionPrev.y += n.y;

            for (var o = 0; o < e.parts.length; o++) {
              var s = e.parts[o];
              s.position.x += n.x, s.position.y += n.y, i.translate(s.vertices, n), l.update(s.bounds, s.vertices, e.velocity);
            }
          }, o.setAngle = function (e, t) {
            var n = t - e.angle;
            e.anglePrev += n;

            for (var o = 0; o < e.parts.length; o++) {
              var s = e.parts[o];
              s.angle += n, i.rotate(s.vertices, n, e.position), c.rotate(s.axes, n), l.update(s.bounds, s.vertices, e.velocity), o > 0 && r.rotateAbout(s.position, n, e.position, s.position);
            }
          }, o.setVelocity = function (e, t) {
            e.positionPrev.x = e.position.x - t.x, e.positionPrev.y = e.position.y - t.y, e.velocity.x = t.x, e.velocity.y = t.y, e.speed = r.magnitude(e.velocity);
          }, o.setAngularVelocity = function (e, t) {
            e.anglePrev = e.angle - t, e.angularVelocity = t, e.angularSpeed = Math.abs(e.angularVelocity);
          }, o.translate = function (e, t) {
            o.setPosition(e, r.add(e.position, t));
          }, o.rotate = function (e, t, n) {
            if (n) {
              var i = Math.cos(t),
                  r = Math.sin(t),
                  s = e.position.x - n.x,
                  a = e.position.y - n.y;
              o.setPosition(e, {
                x: n.x + (s * i - a * r),
                y: n.y + (s * r + a * i)
              }), o.setAngle(e, e.angle + t);
            } else o.setAngle(e, e.angle + t);
          }, o.scale = function (e, t, n, r) {
            var s = 0,
                a = 0;
            r = r || e.position;

            for (var d = 0; d < e.parts.length; d++) {
              var u = e.parts[d];
              i.scale(u.vertices, t, n, r), u.axes = c.fromVertices(u.vertices), u.area = i.area(u.vertices), o.setMass(u, e.density * u.area), i.translate(u.vertices, {
                x: -u.position.x,
                y: -u.position.y
              }), o.setInertia(u, o._inertiaScale * i.inertia(u.vertices, u.mass)), i.translate(u.vertices, {
                x: u.position.x,
                y: u.position.y
              }), d > 0 && (s += u.area, a += u.inertia), u.position.x = r.x + (u.position.x - r.x) * t, u.position.y = r.y + (u.position.y - r.y) * n, l.update(u.bounds, u.vertices, e.velocity);
            }

            e.parts.length > 1 && (e.area = s, e.isStatic || (o.setMass(e, e.density * s), o.setInertia(e, a))), e.circleRadius && (t === n ? e.circleRadius *= t : e.circleRadius = null);
          }, o.update = function (e, t, n, o) {
            var s = Math.pow(t * n * e.timeScale, 2),
                a = 1 - e.frictionAir * n * e.timeScale,
                d = e.position.x - e.positionPrev.x,
                u = e.position.y - e.positionPrev.y;
            e.velocity.x = d * a * o + e.force.x / e.mass * s, e.velocity.y = u * a * o + e.force.y / e.mass * s, e.positionPrev.x = e.position.x, e.positionPrev.y = e.position.y, e.position.x += e.velocity.x, e.position.y += e.velocity.y, e.angularVelocity = (e.angle - e.anglePrev) * a * o + e.torque / e.inertia * s, e.anglePrev = e.angle, e.angle += e.angularVelocity, e.speed = r.magnitude(e.velocity), e.angularSpeed = Math.abs(e.angularVelocity);

            for (var p = 0; p < e.parts.length; p++) {
              var f = e.parts[p];
              i.translate(f.vertices, e.velocity), p > 0 && (f.position.x += e.velocity.x, f.position.y += e.velocity.y), 0 !== e.angularVelocity && (i.rotate(f.vertices, e.angularVelocity, e.position), c.rotate(f.axes, e.angularVelocity), p > 0 && r.rotateAbout(f.position, e.angularVelocity, e.position, f.position)), l.update(f.bounds, f.vertices, e.velocity);
            }
          }, o.applyForce = function (e, t, n) {
            e.force.x += n.x, e.force.y += n.y;
            var o = {
              x: t.x - e.position.x,
              y: t.y - e.position.y
            };
            e.torque += o.x * n.y - o.y * n.x;
          }, o._totalProperties = function (e) {
            for (var t = {
              mass: 0,
              area: 0,
              inertia: 0,
              centre: {
                x: 0,
                y: 0
              }
            }, n = 1 === e.parts.length ? 0 : 1; n < e.parts.length; n++) {
              var o = e.parts[n],
                  i = o.mass !== 1 / 0 ? o.mass : 1;
              t.mass += i, t.area += o.area, t.inertia += o.inertia, t.centre = r.add(t.centre, r.mult(o.position, i));
            }

            return t.centre = r.div(t.centre, t.mass), t;
          };
        }();
      }, {
        "../core/Common": 14,
        "../core/Sleeping": 22,
        "../geometry/Axes": 25,
        "../geometry/Bounds": 26,
        "../geometry/Vector": 28,
        "../geometry/Vertices": 29,
        "../render/Render": 31
      }],
      2: [function (e, t, n) {
        var o = {};
        t.exports = o;
        var i = e("../core/Events"),
            r = e("../core/Common"),
            s = e("../geometry/Bounds"),
            a = e("./Body");
        !function () {
          o.create = function (e) {
            return r.extend({
              id: r.nextId(),
              type: "composite",
              parent: null,
              isModified: !1,
              bodies: [],
              constraints: [],
              composites: [],
              label: "Composite",
              plugin: {}
            }, e);
          }, o.setModified = function (e, t, n, i) {
            if (e.isModified = t, n && e.parent && o.setModified(e.parent, t, n, i), i) for (var r = 0; r < e.composites.length; r++) {
              var s = e.composites[r];
              o.setModified(s, t, n, i);
            }
          }, o.add = function (e, t) {
            var n = [].concat(t);
            i.trigger(e, "beforeAdd", {
              object: t
            });

            for (var s = 0; s < n.length; s++) {
              var a = n[s];

              switch (a.type) {
                case "body":
                  if (a.parent !== a) {
                    r.warn("Composite.add: skipped adding a compound body part (you must add its parent instead)");
                    break;
                  }

                  o.addBody(e, a);
                  break;

                case "constraint":
                  o.addConstraint(e, a);
                  break;

                case "composite":
                  o.addComposite(e, a);
                  break;

                case "mouseConstraint":
                  o.addConstraint(e, a.constraint);
              }
            }

            return i.trigger(e, "afterAdd", {
              object: t
            }), e;
          }, o.remove = function (e, t, n) {
            var r = [].concat(t);
            i.trigger(e, "beforeRemove", {
              object: t
            });

            for (var s = 0; s < r.length; s++) {
              var a = r[s];

              switch (a.type) {
                case "body":
                  o.removeBody(e, a, n);
                  break;

                case "constraint":
                  o.removeConstraint(e, a, n);
                  break;

                case "composite":
                  o.removeComposite(e, a, n);
                  break;

                case "mouseConstraint":
                  o.removeConstraint(e, a.constraint);
              }
            }

            return i.trigger(e, "afterRemove", {
              object: t
            }), e;
          }, o.addComposite = function (e, t) {
            return e.composites.push(t), t.parent = e, o.setModified(e, !0, !0, !1), e;
          }, o.removeComposite = function (e, t, n) {
            var i = r.indexOf(e.composites, t);
            if (-1 !== i && (o.removeCompositeAt(e, i), o.setModified(e, !0, !0, !1)), n) for (var s = 0; s < e.composites.length; s++) {
              o.removeComposite(e.composites[s], t, !0);
            }
            return e;
          }, o.removeCompositeAt = function (e, t) {
            return e.composites.splice(t, 1), o.setModified(e, !0, !0, !1), e;
          }, o.addBody = function (e, t) {
            return e.bodies.push(t), o.setModified(e, !0, !0, !1), e;
          }, o.removeBody = function (e, t, n) {
            var i = r.indexOf(e.bodies, t);
            if (-1 !== i && (o.removeBodyAt(e, i), o.setModified(e, !0, !0, !1)), n) for (var s = 0; s < e.composites.length; s++) {
              o.removeBody(e.composites[s], t, !0);
            }
            return e;
          }, o.removeBodyAt = function (e, t) {
            return e.bodies.splice(t, 1), o.setModified(e, !0, !0, !1), e;
          }, o.addConstraint = function (e, t) {
            return e.constraints.push(t), o.setModified(e, !0, !0, !1), e;
          }, o.removeConstraint = function (e, t, n) {
            var i = r.indexOf(e.constraints, t);
            if (-1 !== i && o.removeConstraintAt(e, i), n) for (var s = 0; s < e.composites.length; s++) {
              o.removeConstraint(e.composites[s], t, !0);
            }
            return e;
          }, o.removeConstraintAt = function (e, t) {
            return e.constraints.splice(t, 1), o.setModified(e, !0, !0, !1), e;
          }, o.clear = function (e, t, n) {
            if (n) for (var i = 0; i < e.composites.length; i++) {
              o.clear(e.composites[i], t, !0);
            }
            return t ? e.bodies = e.bodies.filter(function (e) {
              return e.isStatic;
            }) : e.bodies.length = 0, e.constraints.length = 0, e.composites.length = 0, o.setModified(e, !0, !0, !1), e;
          }, o.allBodies = function (e) {
            for (var t = [].concat(e.bodies), n = 0; n < e.composites.length; n++) {
              t = t.concat(o.allBodies(e.composites[n]));
            }

            return t;
          }, o.allConstraints = function (e) {
            for (var t = [].concat(e.constraints), n = 0; n < e.composites.length; n++) {
              t = t.concat(o.allConstraints(e.composites[n]));
            }

            return t;
          }, o.allComposites = function (e) {
            for (var t = [].concat(e.composites), n = 0; n < e.composites.length; n++) {
              t = t.concat(o.allComposites(e.composites[n]));
            }

            return t;
          }, o.get = function (e, t, n) {
            var i, r;

            switch (n) {
              case "body":
                i = o.allBodies(e);
                break;

              case "constraint":
                i = o.allConstraints(e);
                break;

              case "composite":
                i = o.allComposites(e).concat(e);
            }

            return i ? (r = i.filter(function (e) {
              return e.id.toString() === t.toString();
            }), 0 === r.length ? null : r[0]) : null;
          }, o.move = function (e, t, n) {
            return o.remove(e, t), o.add(n, t), e;
          }, o.rebase = function (e) {
            for (var t = o.allBodies(e).concat(o.allConstraints(e)).concat(o.allComposites(e)), n = 0; n < t.length; n++) {
              t[n].id = r.nextId();
            }

            return o.setModified(e, !0, !0, !1), e;
          }, o.translate = function (e, t, n) {
            for (var i = n ? o.allBodies(e) : e.bodies, r = 0; r < i.length; r++) {
              a.translate(i[r], t);
            }

            return o.setModified(e, !0, !0, !1), e;
          }, o.rotate = function (e, t, n, i) {
            for (var r = Math.cos(t), s = Math.sin(t), l = i ? o.allBodies(e) : e.bodies, c = 0; c < l.length; c++) {
              var d = l[c],
                  u = d.position.x - n.x,
                  p = d.position.y - n.y;
              a.setPosition(d, {
                x: n.x + (u * r - p * s),
                y: n.y + (u * s + p * r)
              }), a.rotate(d, t);
            }

            return o.setModified(e, !0, !0, !1), e;
          }, o.scale = function (e, t, n, i, r) {
            for (var s = r ? o.allBodies(e) : e.bodies, l = 0; l < s.length; l++) {
              var c = s[l],
                  d = c.position.x - i.x,
                  u = c.position.y - i.y;
              a.setPosition(c, {
                x: i.x + d * t,
                y: i.y + u * n
              }), a.scale(c, t, n);
            }

            return o.setModified(e, !0, !0, !1), e;
          }, o.bounds = function (e) {
            for (var t = o.allBodies(e), n = [], i = 0; i < t.length; i += 1) {
              var r = t[i];
              n.push(r.bounds.min, r.bounds.max);
            }

            return s.create(n);
          };
        }();
      }, {
        "../core/Common": 14,
        "../core/Events": 16,
        "../geometry/Bounds": 26,
        "./Body": 1
      }],
      3: [function (e, t, n) {
        var o = {};
        t.exports = o;
        var i = e("./Composite"),
            r = (e("../constraint/Constraint"), e("../core/Common"));
        !function () {
          o.create = function (e) {
            var t = i.create(),
                n = {
              label: "World",
              gravity: {
                x: 0,
                y: 1,
                scale: .001
              },
              bounds: {
                min: {
                  x: -1 / 0,
                  y: -1 / 0
                },
                max: {
                  x: 1 / 0,
                  y: 1 / 0
                }
              }
            };
            return r.extend(t, n, e);
          };
        }();
      }, {
        "../constraint/Constraint": 12,
        "../core/Common": 14,
        "./Composite": 2
      }],
      4: [function (e, t, n) {
        var o = {};
        t.exports = o, function () {
          o.create = function (e) {
            return {
              id: o.id(e),
              vertex: e,
              normalImpulse: 0,
              tangentImpulse: 0
            };
          }, o.id = function (e) {
            return e.body.id + "_" + e.index;
          };
        }();
      }, {}],
      5: [function (e, t, n) {
        var o = {};
        t.exports = o;
        var i = e("./SAT"),
            r = e("./Pair"),
            s = e("../geometry/Bounds");
        !function () {
          o.collisions = function (e, t) {
            for (var n = [], a = t.pairs.table, l = 0; l < e.length; l++) {
              var c = e[l][0],
                  d = e[l][1];
              if ((!c.isStatic && !c.isSleeping || !d.isStatic && !d.isSleeping) && o.canCollide(c.collisionFilter, d.collisionFilter) && s.overlaps(c.bounds, d.bounds)) for (var u = c.parts.length > 1 ? 1 : 0; u < c.parts.length; u++) {
                for (var p = c.parts[u], f = d.parts.length > 1 ? 1 : 0; f < d.parts.length; f++) {
                  var m = d.parts[f];

                  if (p === c && m === d || s.overlaps(p.bounds, m.bounds)) {
                    var v,
                        y = r.id(p, m),
                        g = a[y];
                    v = g && g.isActive ? g.collision : null;
                    var x = i.collides(p, m, v);
                    x.collided && n.push(x);
                  }
                }
              }
            }

            return n;
          }, o.canCollide = function (e, t) {
            return e.group === t.group && 0 !== e.group ? e.group > 0 : 0 != (e.mask & t.category) && 0 != (t.mask & e.category);
          };
        }();
      }, {
        "../geometry/Bounds": 26,
        "./Pair": 7,
        "./SAT": 11
      }],
      6: [function (e, t, n) {
        var o = {};
        t.exports = o;
        var i = e("./Pair"),
            r = e("./Detector"),
            s = e("../core/Common");
        !function () {
          o.create = function (e) {
            var t = {
              controller: o,
              detector: r.collisions,
              buckets: {},
              pairs: {},
              pairsList: [],
              bucketWidth: 48,
              bucketHeight: 48
            };
            return s.extend(t, e);
          }, o.update = function (e, t, n, i) {
            var r,
                s,
                a,
                l,
                c,
                d = n.world,
                u = e.buckets,
                p = !1;

            for (r = 0; r < t.length; r++) {
              var f = t[r];

              if ((!f.isSleeping || i) && !(f.bounds.max.x < d.bounds.min.x || f.bounds.min.x > d.bounds.max.x || f.bounds.max.y < d.bounds.min.y || f.bounds.min.y > d.bounds.max.y)) {
                var m = o._getRegion(e, f);

                if (!f.region || m.id !== f.region.id || i) {
                  f.region && !i || (f.region = m);

                  var v = o._regionUnion(m, f.region);

                  for (s = v.startCol; s <= v.endCol; s++) {
                    for (a = v.startRow; a <= v.endRow; a++) {
                      c = o._getBucketId(s, a), l = u[c];
                      var y = s >= m.startCol && s <= m.endCol && a >= m.startRow && a <= m.endRow,
                          g = s >= f.region.startCol && s <= f.region.endCol && a >= f.region.startRow && a <= f.region.endRow;
                      !y && g && g && l && o._bucketRemoveBody(e, l, f), (f.region === m || y && !g || i) && (l || (l = o._createBucket(u, c)), o._bucketAddBody(e, l, f));
                    }
                  }

                  f.region = m, p = !0;
                }
              }
            }

            p && (e.pairsList = o._createActivePairsList(e));
          }, o.clear = function (e) {
            e.buckets = {}, e.pairs = {}, e.pairsList = [];
          }, o._regionUnion = function (e, t) {
            var n = Math.min(e.startCol, t.startCol),
                i = Math.max(e.endCol, t.endCol),
                r = Math.min(e.startRow, t.startRow),
                s = Math.max(e.endRow, t.endRow);
            return o._createRegion(n, i, r, s);
          }, o._getRegion = function (e, t) {
            var n = t.bounds,
                i = Math.floor(n.min.x / e.bucketWidth),
                r = Math.floor(n.max.x / e.bucketWidth),
                s = Math.floor(n.min.y / e.bucketHeight),
                a = Math.floor(n.max.y / e.bucketHeight);
            return o._createRegion(i, r, s, a);
          }, o._createRegion = function (e, t, n, o) {
            return {
              id: e + "," + t + "," + n + "," + o,
              startCol: e,
              endCol: t,
              startRow: n,
              endRow: o
            };
          }, o._getBucketId = function (e, t) {
            return "C" + e + "R" + t;
          }, o._createBucket = function (e, t) {
            return e[t] = [];
          }, o._bucketAddBody = function (e, t, n) {
            for (var o = 0; o < t.length; o++) {
              var r = t[o];

              if (!(n.id === r.id || n.isStatic && r.isStatic)) {
                var s = i.id(n, r),
                    a = e.pairs[s];
                a ? a[2] += 1 : e.pairs[s] = [n, r, 1];
              }
            }

            t.push(n);
          }, o._bucketRemoveBody = function (e, t, n) {
            t.splice(s.indexOf(t, n), 1);

            for (var o = 0; o < t.length; o++) {
              var r = t[o],
                  a = i.id(n, r),
                  l = e.pairs[a];
              l && (l[2] -= 1);
            }
          }, o._createActivePairsList = function (e) {
            var t,
                n,
                o = [];
            t = s.keys(e.pairs);

            for (var i = 0; i < t.length; i++) {
              n = e.pairs[t[i]], n[2] > 0 ? o.push(n) : delete e.pairs[t[i]];
            }

            return o;
          };
        }();
      }, {
        "../core/Common": 14,
        "./Detector": 5,
        "./Pair": 7
      }],
      7: [function (e, t, n) {
        var o = {};
        t.exports = o;
        var i = e("./Contact");
        !function () {
          o.create = function (e, t) {
            var n = e.bodyA,
                i = e.bodyB,
                r = e.parentA,
                s = e.parentB,
                a = {
              id: o.id(n, i),
              bodyA: n,
              bodyB: i,
              contacts: {},
              activeContacts: [],
              separation: 0,
              isActive: !0,
              isSensor: n.isSensor || i.isSensor,
              timeCreated: t,
              timeUpdated: t,
              inverseMass: r.inverseMass + s.inverseMass,
              friction: Math.min(r.friction, s.friction),
              frictionStatic: Math.max(r.frictionStatic, s.frictionStatic),
              restitution: Math.max(r.restitution, s.restitution),
              slop: Math.max(r.slop, s.slop)
            };
            return o.update(a, e, t), a;
          }, o.update = function (e, t, n) {
            var r = e.contacts,
                s = t.supports,
                a = e.activeContacts,
                l = t.parentA,
                c = t.parentB;

            if (e.collision = t, e.inverseMass = l.inverseMass + c.inverseMass, e.friction = Math.min(l.friction, c.friction), e.frictionStatic = Math.max(l.frictionStatic, c.frictionStatic), e.restitution = Math.max(l.restitution, c.restitution), e.slop = Math.max(l.slop, c.slop), a.length = 0, t.collided) {
              for (var d = 0; d < s.length; d++) {
                var u = s[d],
                    p = i.id(u),
                    f = r[p];
                f ? a.push(f) : a.push(r[p] = i.create(u));
              }

              e.separation = t.depth, o.setActive(e, !0, n);
            } else !0 === e.isActive && o.setActive(e, !1, n);
          }, o.setActive = function (e, t, n) {
            t ? (e.isActive = !0, e.timeUpdated = n) : (e.isActive = !1, e.activeContacts.length = 0);
          }, o.id = function (e, t) {
            return e.id < t.id ? "A" + e.id + "B" + t.id : "A" + t.id + "B" + e.id;
          };
        }();
      }, {
        "./Contact": 4
      }],
      8: [function (e, t, n) {
        var o = {};
        t.exports = o;
        var i = e("./Pair"),
            r = e("../core/Common");
        !function () {
          o._pairMaxIdleLife = 1e3, o.create = function (e) {
            return r.extend({
              table: {},
              list: [],
              collisionStart: [],
              collisionActive: [],
              collisionEnd: []
            }, e);
          }, o.update = function (e, t, n) {
            var o,
                s,
                a,
                l,
                c = e.list,
                d = e.table,
                u = e.collisionStart,
                p = e.collisionEnd,
                f = e.collisionActive,
                m = [];

            for (u.length = 0, p.length = 0, f.length = 0, l = 0; l < t.length; l++) {
              o = t[l], o.collided && (s = i.id(o.bodyA, o.bodyB), m.push(s), a = d[s], a ? (a.isActive ? f.push(a) : u.push(a), i.update(a, o, n)) : (a = i.create(o, n), d[s] = a, u.push(a), c.push(a)));
            }

            for (l = 0; l < c.length; l++) {
              a = c[l], a.isActive && -1 === r.indexOf(m, a.id) && (i.setActive(a, !1, n), p.push(a));
            }
          }, o.removeOld = function (e, t) {
            var n,
                i,
                r,
                s,
                a = e.list,
                l = e.table,
                c = [];

            for (s = 0; s < a.length; s++) {
              n = a[s], i = n.collision, i.bodyA.isSleeping || i.bodyB.isSleeping ? n.timeUpdated = t : t - n.timeUpdated > o._pairMaxIdleLife && c.push(s);
            }

            for (s = 0; s < c.length; s++) {
              r = c[s] - s, n = a[r], delete l[n.id], a.splice(r, 1);
            }
          }, o.clear = function (e) {
            return e.table = {}, e.list.length = 0, e.collisionStart.length = 0, e.collisionActive.length = 0, e.collisionEnd.length = 0, e;
          };
        }();
      }, {
        "../core/Common": 14,
        "./Pair": 7
      }],
      9: [function (e, t, n) {
        var o = {};
        t.exports = o;
        var i = e("../geometry/Vector"),
            r = e("./SAT"),
            s = e("../geometry/Bounds"),
            a = e("../factory/Bodies"),
            l = e("../geometry/Vertices");
        !function () {
          o.collides = function (e, t) {
            for (var n = [], o = 0; o < t.length; o++) {
              var i = t[o];
              if (s.overlaps(i.bounds, e.bounds)) for (var a = 1 === i.parts.length ? 0 : 1; a < i.parts.length; a++) {
                var l = i.parts[a];

                if (s.overlaps(l.bounds, e.bounds)) {
                  var c = r.collides(l, e);

                  if (c.collided) {
                    n.push(c);
                    break;
                  }
                }
              }
            }

            return n;
          }, o.ray = function (e, t, n, r) {
            r = r || 1e-100;

            for (var s = i.angle(t, n), l = i.magnitude(i.sub(t, n)), c = .5 * (n.x + t.x), d = .5 * (n.y + t.y), u = a.rectangle(c, d, l, r, {
              angle: s
            }), p = o.collides(u, e), f = 0; f < p.length; f += 1) {
              var m = p[f];
              m.body = m.bodyB = m.bodyA;
            }

            return p;
          }, o.region = function (e, t, n) {
            for (var o = [], i = 0; i < e.length; i++) {
              var r = e[i],
                  a = s.overlaps(r.bounds, t);
              (a && !n || !a && n) && o.push(r);
            }

            return o;
          }, o.point = function (e, t) {
            for (var n = [], o = 0; o < e.length; o++) {
              var i = e[o];
              if (s.contains(i.bounds, t)) for (var r = 1 === i.parts.length ? 0 : 1; r < i.parts.length; r++) {
                var a = i.parts[r];

                if (s.contains(a.bounds, t) && l.contains(a.vertices, t)) {
                  n.push(i);
                  break;
                }
              }
            }

            return n;
          };
        }();
      }, {
        "../factory/Bodies": 23,
        "../geometry/Bounds": 26,
        "../geometry/Vector": 28,
        "../geometry/Vertices": 29,
        "./SAT": 11
      }],
      10: [function (e, t, n) {
        var o = {};
        t.exports = o;
        var i = e("../geometry/Vertices"),
            r = e("../geometry/Vector"),
            s = e("../core/Common"),
            a = e("../geometry/Bounds");
        !function () {
          o._restingThresh = 4, o._restingThreshTangent = 6, o._positionDampen = .9, o._positionWarming = .8, o._frictionNormalMultiplier = 5, o.preSolvePosition = function (e) {
            var t, n, o;

            for (t = 0; t < e.length; t++) {
              n = e[t], n.isActive && (o = n.activeContacts.length, n.collision.parentA.totalContacts += o, n.collision.parentB.totalContacts += o);
            }
          }, o.solvePosition = function (e, t) {
            var n,
                i,
                s,
                a,
                l,
                c,
                d,
                u,
                p,
                f = r._temp[0],
                m = r._temp[1],
                v = r._temp[2],
                y = r._temp[3];

            for (n = 0; n < e.length; n++) {
              i = e[n], i.isActive && !i.isSensor && (s = i.collision, a = s.parentA, l = s.parentB, c = s.normal, d = r.sub(r.add(l.positionImpulse, l.position, f), r.add(a.positionImpulse, r.sub(l.position, s.penetration, m), v), y), i.separation = r.dot(c, d));
            }

            for (n = 0; n < e.length; n++) {
              i = e[n], i.isActive && !i.isSensor && (s = i.collision, a = s.parentA, l = s.parentB, c = s.normal, p = (i.separation - i.slop) * t, (a.isStatic || l.isStatic) && (p *= 2), a.isStatic || a.isSleeping || (u = o._positionDampen / a.totalContacts, a.positionImpulse.x += c.x * p * u, a.positionImpulse.y += c.y * p * u), l.isStatic || l.isSleeping || (u = o._positionDampen / l.totalContacts, l.positionImpulse.x -= c.x * p * u, l.positionImpulse.y -= c.y * p * u));
            }
          }, o.postSolvePosition = function (e) {
            for (var t = 0; t < e.length; t++) {
              var n = e[t];

              if (n.totalContacts = 0, 0 !== n.positionImpulse.x || 0 !== n.positionImpulse.y) {
                for (var s = 0; s < n.parts.length; s++) {
                  var l = n.parts[s];
                  i.translate(l.vertices, n.positionImpulse), a.update(l.bounds, l.vertices, n.velocity), l.position.x += n.positionImpulse.x, l.position.y += n.positionImpulse.y;
                }

                n.positionPrev.x += n.positionImpulse.x, n.positionPrev.y += n.positionImpulse.y, r.dot(n.positionImpulse, n.velocity) < 0 ? (n.positionImpulse.x = 0, n.positionImpulse.y = 0) : (n.positionImpulse.x *= o._positionWarming, n.positionImpulse.y *= o._positionWarming);
              }
            }
          }, o.preSolveVelocity = function (e) {
            var t,
                n,
                o,
                i,
                s,
                a,
                l,
                c,
                d,
                u,
                p,
                f,
                m,
                v,
                y = r._temp[0],
                g = r._temp[1];

            for (t = 0; t < e.length; t++) {
              if (o = e[t], o.isActive && !o.isSensor) for (i = o.activeContacts, s = o.collision, a = s.parentA, l = s.parentB, c = s.normal, d = s.tangent, n = 0; n < i.length; n++) {
                u = i[n], p = u.vertex, f = u.normalImpulse, m = u.tangentImpulse, 0 === f && 0 === m || (y.x = c.x * f + d.x * m, y.y = c.y * f + d.y * m, a.isStatic || a.isSleeping || (v = r.sub(p, a.position, g), a.positionPrev.x += y.x * a.inverseMass, a.positionPrev.y += y.y * a.inverseMass, a.anglePrev += r.cross(v, y) * a.inverseInertia), l.isStatic || l.isSleeping || (v = r.sub(p, l.position, g), l.positionPrev.x -= y.x * l.inverseMass, l.positionPrev.y -= y.y * l.inverseMass, l.anglePrev -= r.cross(v, y) * l.inverseInertia));
              }
            }
          }, o.solveVelocity = function (e, t) {
            for (var n = t * t, i = r._temp[0], a = r._temp[1], l = r._temp[2], c = r._temp[3], d = r._temp[4], u = r._temp[5], p = 0; p < e.length; p++) {
              var f = e[p];

              if (f.isActive && !f.isSensor) {
                var m = f.collision,
                    v = m.parentA,
                    y = m.parentB,
                    g = m.normal,
                    x = m.tangent,
                    h = f.activeContacts,
                    b = 1 / h.length;
                v.velocity.x = v.position.x - v.positionPrev.x, v.velocity.y = v.position.y - v.positionPrev.y, y.velocity.x = y.position.x - y.positionPrev.x, y.velocity.y = y.position.y - y.positionPrev.y, v.angularVelocity = v.angle - v.anglePrev, y.angularVelocity = y.angle - y.anglePrev;

                for (var w = 0; w < h.length; w++) {
                  var S = h[w],
                      C = S.vertex,
                      A = r.sub(C, v.position, a),
                      P = r.sub(C, y.position, l),
                      B = r.add(v.velocity, r.mult(r.perp(A), v.angularVelocity), c),
                      M = r.add(y.velocity, r.mult(r.perp(P), y.angularVelocity), d),
                      k = r.sub(B, M, u),
                      I = r.dot(g, k),
                      _ = r.dot(x, k),
                      T = Math.abs(_),
                      R = s.sign(_),
                      V = (1 + f.restitution) * I,
                      E = s.clamp(f.separation + I, 0, 1) * o._frictionNormalMultiplier,
                      L = _,
                      F = 1 / 0;

                  T > f.friction * f.frictionStatic * E * n && (F = T, L = s.clamp(f.friction * R * n, -F, F));
                  var O = r.cross(A, g),
                      q = r.cross(P, g),
                      W = b / (v.inverseMass + y.inverseMass + v.inverseInertia * O * O + y.inverseInertia * q * q);
                  if (V *= W, L *= W, I < 0 && I * I > o._restingThresh * n) S.normalImpulse = 0;else {
                    var D = S.normalImpulse;
                    S.normalImpulse = Math.min(S.normalImpulse + V, 0), V = S.normalImpulse - D;
                  }
                  if (_ * _ > o._restingThreshTangent * n) S.tangentImpulse = 0;else {
                    var N = S.tangentImpulse;
                    S.tangentImpulse = s.clamp(S.tangentImpulse + L, -F, F), L = S.tangentImpulse - N;
                  }
                  i.x = g.x * V + x.x * L, i.y = g.y * V + x.y * L, v.isStatic || v.isSleeping || (v.positionPrev.x += i.x * v.inverseMass, v.positionPrev.y += i.y * v.inverseMass, v.anglePrev += r.cross(A, i) * v.inverseInertia), y.isStatic || y.isSleeping || (y.positionPrev.x -= i.x * y.inverseMass, y.positionPrev.y -= i.y * y.inverseMass, y.anglePrev -= r.cross(P, i) * y.inverseInertia);
                }
              }
            }
          };
        }();
      }, {
        "../core/Common": 14,
        "../geometry/Bounds": 26,
        "../geometry/Vector": 28,
        "../geometry/Vertices": 29
      }],
      11: [function (e, t, n) {
        var o = {};
        t.exports = o;
        var i = e("../geometry/Vertices"),
            r = e("../geometry/Vector");
        !function () {
          o.collides = function (e, t, n) {
            var s,
                a,
                l,
                c,
                d = !1;

            if (n) {
              var u = e.parent,
                  p = t.parent,
                  f = u.speed * u.speed + u.angularSpeed * u.angularSpeed + p.speed * p.speed + p.angularSpeed * p.angularSpeed;
              d = n && n.collided && f < .2, c = n;
            } else c = {
              collided: !1,
              bodyA: e,
              bodyB: t
            };

            if (n && d) {
              var m = c.axisBody,
                  v = m === e ? t : e,
                  y = [m.axes[n.axisNumber]];
              if (l = o._overlapAxes(m.vertices, v.vertices, y), c.reused = !0, l.overlap <= 0) return c.collided = !1, c;
            } else {
              if (s = o._overlapAxes(e.vertices, t.vertices, e.axes), s.overlap <= 0) return c.collided = !1, c;
              if (a = o._overlapAxes(t.vertices, e.vertices, t.axes), a.overlap <= 0) return c.collided = !1, c;
              s.overlap < a.overlap ? (l = s, c.axisBody = e) : (l = a, c.axisBody = t), c.axisNumber = l.axisNumber;
            }

            c.bodyA = e.id < t.id ? e : t, c.bodyB = e.id < t.id ? t : e, c.collided = !0, c.depth = l.overlap, c.parentA = c.bodyA.parent, c.parentB = c.bodyB.parent, e = c.bodyA, t = c.bodyB, r.dot(l.axis, r.sub(t.position, e.position)) < 0 ? c.normal = {
              x: l.axis.x,
              y: l.axis.y
            } : c.normal = {
              x: -l.axis.x,
              y: -l.axis.y
            }, c.tangent = r.perp(c.normal), c.penetration = c.penetration || {}, c.penetration.x = c.normal.x * c.depth, c.penetration.y = c.normal.y * c.depth;

            var g = o._findSupports(e, t, c.normal),
                x = [];

            if (i.contains(e.vertices, g[0]) && x.push(g[0]), i.contains(e.vertices, g[1]) && x.push(g[1]), x.length < 2) {
              var h = o._findSupports(t, e, r.neg(c.normal));

              i.contains(t.vertices, h[0]) && x.push(h[0]), x.length < 2 && i.contains(t.vertices, h[1]) && x.push(h[1]);
            }

            return x.length < 1 && (x = [g[0]]), c.supports = x, c;
          }, o._overlapAxes = function (e, t, n) {
            for (var i, s, a = r._temp[0], l = r._temp[1], c = {
              overlap: Number.MAX_VALUE
            }, d = 0; d < n.length; d++) {
              if (s = n[d], o._projectToAxis(a, e, s), o._projectToAxis(l, t, s), (i = Math.min(a.max - l.min, l.max - a.min)) <= 0) return c.overlap = i, c;
              i < c.overlap && (c.overlap = i, c.axis = s, c.axisNumber = d);
            }

            return c;
          }, o._projectToAxis = function (e, t, n) {
            for (var o = r.dot(t[0], n), i = o, s = 1; s < t.length; s += 1) {
              var a = r.dot(t[s], n);
              a > i ? i = a : a < o && (o = a);
            }

            e.min = o, e.max = i;
          }, o._findSupports = function (e, t, n) {
            for (var o, i, s, a, l = Number.MAX_VALUE, c = r._temp[0], d = t.vertices, u = e.position, p = 0; p < d.length; p++) {
              i = d[p], c.x = i.x - u.x, c.y = i.y - u.y, (o = -r.dot(n, c)) < l && (l = o, s = i);
            }

            return i = d[s.index - 1 >= 0 ? s.index - 1 : d.length - 1], c.x = i.x - u.x, c.y = i.y - u.y, l = -r.dot(n, c), a = i, i = d[(s.index + 1) % d.length], c.x = i.x - u.x, c.y = i.y - u.y, o = -r.dot(n, c), o < l && (a = i), [s, a];
          };
        }();
      }, {
        "../geometry/Vector": 28,
        "../geometry/Vertices": 29
      }],
      12: [function (e, t, n) {
        var o = {};
        t.exports = o;
        var i = e("../geometry/Vertices"),
            r = e("../geometry/Vector"),
            s = e("../core/Sleeping"),
            a = e("../geometry/Bounds"),
            l = e("../geometry/Axes"),
            c = e("../core/Common");
        !function () {
          o._warming = .4, o._torqueDampen = 1, o._minLength = 1e-6, o.create = function (e) {
            var t = e;
            t.bodyA && !t.pointA && (t.pointA = {
              x: 0,
              y: 0
            }), t.bodyB && !t.pointB && (t.pointB = {
              x: 0,
              y: 0
            });
            var n = t.bodyA ? r.add(t.bodyA.position, t.pointA) : t.pointA,
                o = t.bodyB ? r.add(t.bodyB.position, t.pointB) : t.pointB,
                i = r.magnitude(r.sub(n, o));
            t.length = void 0 !== t.length ? t.length : i, t.id = t.id || c.nextId(), t.label = t.label || "Constraint", t.type = "constraint", t.stiffness = t.stiffness || (t.length > 0 ? 1 : .7), t.damping = t.damping || 0, t.angularStiffness = t.angularStiffness || 0, t.angleA = t.bodyA ? t.bodyA.angle : t.angleA, t.angleB = t.bodyB ? t.bodyB.angle : t.angleB, t.plugin = {};
            var s = {
              visible: !0,
              lineWidth: 2,
              strokeStyle: "#ffffff",
              type: "line",
              anchors: !0
            };
            return 0 === t.length && t.stiffness > .1 ? (s.type = "pin", s.anchors = !1) : t.stiffness < .9 && (s.type = "spring"), t.render = c.extend(s, t.render), t;
          }, o.preSolveAll = function (e) {
            for (var t = 0; t < e.length; t += 1) {
              var n = e[t],
                  o = n.constraintImpulse;
              n.isStatic || 0 === o.x && 0 === o.y && 0 === o.angle || (n.position.x += o.x, n.position.y += o.y, n.angle += o.angle);
            }
          }, o.solveAll = function (e, t) {
            for (var n = 0; n < e.length; n += 1) {
              var i = e[n],
                  r = !i.bodyA || i.bodyA && i.bodyA.isStatic,
                  s = !i.bodyB || i.bodyB && i.bodyB.isStatic;
              (r || s) && o.solve(e[n], t);
            }

            for (n = 0; n < e.length; n += 1) {
              i = e[n], r = !i.bodyA || i.bodyA && i.bodyA.isStatic, s = !i.bodyB || i.bodyB && i.bodyB.isStatic, r || s || o.solve(e[n], t);
            }
          }, o.solve = function (e, t) {
            var n = e.bodyA,
                i = e.bodyB,
                s = e.pointA,
                a = e.pointB;

            if (n || i) {
              n && !n.isStatic && (r.rotate(s, n.angle - e.angleA, s), e.angleA = n.angle), i && !i.isStatic && (r.rotate(a, i.angle - e.angleB, a), e.angleB = i.angle);
              var l = s,
                  c = a;

              if (n && (l = r.add(n.position, s)), i && (c = r.add(i.position, a)), l && c) {
                var d = r.sub(l, c),
                    u = r.magnitude(d);
                u < o._minLength && (u = o._minLength);
                var p,
                    f,
                    m,
                    v,
                    y,
                    g = (u - e.length) / u,
                    x = e.stiffness < 1 ? e.stiffness * t : e.stiffness,
                    h = r.mult(d, g * x),
                    b = (n ? n.inverseMass : 0) + (i ? i.inverseMass : 0),
                    w = (n ? n.inverseInertia : 0) + (i ? i.inverseInertia : 0),
                    S = b + w;

                if (e.damping) {
                  var C = r.create();
                  m = r.div(d, u), y = r.sub(i && r.sub(i.position, i.positionPrev) || C, n && r.sub(n.position, n.positionPrev) || C), v = r.dot(m, y);
                }

                n && !n.isStatic && (f = n.inverseMass / b, n.constraintImpulse.x -= h.x * f, n.constraintImpulse.y -= h.y * f, n.position.x -= h.x * f, n.position.y -= h.y * f, e.damping && (n.positionPrev.x -= e.damping * m.x * v * f, n.positionPrev.y -= e.damping * m.y * v * f), p = r.cross(s, h) / S * o._torqueDampen * n.inverseInertia * (1 - e.angularStiffness), n.constraintImpulse.angle -= p, n.angle -= p), i && !i.isStatic && (f = i.inverseMass / b, i.constraintImpulse.x += h.x * f, i.constraintImpulse.y += h.y * f, i.position.x += h.x * f, i.position.y += h.y * f, e.damping && (i.positionPrev.x += e.damping * m.x * v * f, i.positionPrev.y += e.damping * m.y * v * f), p = r.cross(a, h) / S * o._torqueDampen * i.inverseInertia * (1 - e.angularStiffness), i.constraintImpulse.angle += p, i.angle += p);
              }
            }
          }, o.postSolveAll = function (e) {
            for (var t = 0; t < e.length; t++) {
              var n = e[t],
                  c = n.constraintImpulse;

              if (!(n.isStatic || 0 === c.x && 0 === c.y && 0 === c.angle)) {
                s.set(n, !1);

                for (var d = 0; d < n.parts.length; d++) {
                  var u = n.parts[d];
                  i.translate(u.vertices, c), d > 0 && (u.position.x += c.x, u.position.y += c.y), 0 !== c.angle && (i.rotate(u.vertices, c.angle, n.position), l.rotate(u.axes, c.angle), d > 0 && r.rotateAbout(u.position, c.angle, n.position, u.position)), a.update(u.bounds, u.vertices, n.velocity);
                }

                c.angle *= o._warming, c.x *= o._warming, c.y *= o._warming;
              }
            }
          };
        }();
      }, {
        "../core/Common": 14,
        "../core/Sleeping": 22,
        "../geometry/Axes": 25,
        "../geometry/Bounds": 26,
        "../geometry/Vector": 28,
        "../geometry/Vertices": 29
      }],
      13: [function (e, t, n) {
        var o = {};
        t.exports = o;
        var i = e("../geometry/Vertices"),
            r = e("../core/Sleeping"),
            s = e("../core/Mouse"),
            a = e("../core/Events"),
            l = e("../collision/Detector"),
            c = e("./Constraint"),
            d = e("../body/Composite"),
            u = e("../core/Common"),
            p = e("../geometry/Bounds");
        !function () {
          o.create = function (e, t) {
            var n = (e ? e.mouse : null) || (t ? t.mouse : null);
            n || (e && e.render && e.render.canvas ? n = s.create(e.render.canvas) : t && t.element ? n = s.create(t.element) : (n = s.create(), u.warn("MouseConstraint.create: options.mouse was undefined, options.element was undefined, may not function as expected")));
            var i = c.create({
              label: "Mouse Constraint",
              pointA: n.position,
              pointB: {
                x: 0,
                y: 0
              },
              length: .01,
              stiffness: .1,
              angularStiffness: 1,
              render: {
                strokeStyle: "#90EE90",
                lineWidth: 3
              }
            }),
                r = {
              type: "mouseConstraint",
              mouse: n,
              element: null,
              body: null,
              constraint: i,
              collisionFilter: {
                category: 1,
                mask: 4294967295,
                group: 0
              }
            },
                l = u.extend(r, t);
            return a.on(e, "beforeUpdate", function () {
              var t = d.allBodies(e.world);
              o.update(l, t), o._triggerEvents(l);
            }), l;
          }, o.update = function (e, t) {
            var n = e.mouse,
                o = e.constraint,
                s = e.body;

            if (0 === n.button) {
              if (o.bodyB) r.set(o.bodyB, !1), o.pointA = n.position;else for (var c = 0; c < t.length; c++) {
                if (s = t[c], p.contains(s.bounds, n.position) && l.canCollide(s.collisionFilter, e.collisionFilter)) for (var d = s.parts.length > 1 ? 1 : 0; d < s.parts.length; d++) {
                  var u = s.parts[d];

                  if (i.contains(u.vertices, n.position)) {
                    o.pointA = n.position, o.bodyB = e.body = s, o.pointB = {
                      x: n.position.x - s.position.x,
                      y: n.position.y - s.position.y
                    }, o.angleB = s.angle, r.set(s, !1), a.trigger(e, "startdrag", {
                      mouse: n,
                      body: s
                    });
                    break;
                  }
                }
              }
            } else o.bodyB = e.body = null, o.pointB = null, s && a.trigger(e, "enddrag", {
              mouse: n,
              body: s
            });
          }, o._triggerEvents = function (e) {
            var t = e.mouse,
                n = t.sourceEvents;
            n.mousemove && a.trigger(e, "mousemove", {
              mouse: t
            }), n.mousedown && a.trigger(e, "mousedown", {
              mouse: t
            }), n.mouseup && a.trigger(e, "mouseup", {
              mouse: t
            }), s.clearSourceEvents(t);
          };
        }();
      }, {
        "../body/Composite": 2,
        "../collision/Detector": 5,
        "../core/Common": 14,
        "../core/Events": 16,
        "../core/Mouse": 19,
        "../core/Sleeping": 22,
        "../geometry/Bounds": 26,
        "../geometry/Vertices": 29,
        "./Constraint": 12
      }],
      14: [function (e, t, n) {
        (function (n) {
          var o = {};
          t.exports = o, function () {
            o._nextId = 0, o._seed = 0, o._nowStartTime = +new Date(), o.extend = function (e, t) {
              var n, i;
              "boolean" == typeof t ? (n = 2, i = t) : (n = 1, i = !0);

              for (var r = n; r < arguments.length; r++) {
                var s = arguments[r];
                if (s) for (var a in s) {
                  i && s[a] && s[a].constructor === Object ? e[a] && e[a].constructor !== Object ? e[a] = s[a] : (e[a] = e[a] || {}, o.extend(e[a], i, s[a])) : e[a] = s[a];
                }
              }

              return e;
            }, o.clone = function (e, t) {
              return o.extend({}, t, e);
            }, o.keys = function (e) {
              if (Object.keys) return Object.keys(e);
              var t = [];

              for (var n in e) {
                t.push(n);
              }

              return t;
            }, o.values = function (e) {
              var t = [];

              if (Object.keys) {
                for (var n = Object.keys(e), o = 0; o < n.length; o++) {
                  t.push(e[n[o]]);
                }

                return t;
              }

              for (var i in e) {
                t.push(e[i]);
              }

              return t;
            }, o.get = function (e, t, n, o) {
              t = t.split(".").slice(n, o);

              for (var i = 0; i < t.length; i += 1) {
                e = e[t[i]];
              }

              return e;
            }, o.set = function (e, t, n, i, r) {
              var s = t.split(".").slice(i, r);
              return o.get(e, t, 0, -1)[s[s.length - 1]] = n, n;
            }, o.shuffle = function (e) {
              for (var t = e.length - 1; t > 0; t--) {
                var n = Math.floor(o.random() * (t + 1)),
                    i = e[t];
                e[t] = e[n], e[n] = i;
              }

              return e;
            }, o.choose = function (e) {
              return e[Math.floor(o.random() * e.length)];
            }, o.isElement = function (e) {
              return "undefined" != typeof HTMLElement ? e instanceof HTMLElement : !!(e && e.nodeType && e.nodeName);
            }, o.isArray = function (e) {
              return "[object Array]" === Object.prototype.toString.call(e);
            }, o.isFunction = function (e) {
              return "function" == typeof e;
            }, o.isPlainObject = function (e) {
              return "object" == _typeof(e) && e.constructor === Object;
            }, o.isString = function (e) {
              return "[object String]" === toString.call(e);
            }, o.clamp = function (e, t, n) {
              return e < t ? t : e > n ? n : e;
            }, o.sign = function (e) {
              return e < 0 ? -1 : 1;
            }, o.now = function () {
              if (window.performance) {
                if (window.performance.now) return window.performance.now();
                if (window.performance.webkitNow) return window.performance.webkitNow();
              }

              return new Date() - o._nowStartTime;
            }, o.random = function (e, n) {
              return e = void 0 !== e ? e : 0, n = void 0 !== n ? n : 1, e + t() * (n - e);
            };

            var t = function t() {
              return o._seed = (9301 * o._seed + 49297) % 233280, o._seed / 233280;
            };

            o.colorToNumber = function (e) {
              return e = e.replace("#", ""), 3 == e.length && (e = e.charAt(0) + e.charAt(0) + e.charAt(1) + e.charAt(1) + e.charAt(2) + e.charAt(2)), parseInt(e, 16);
            }, o.logLevel = 1, o.log = function () {
              console && o.logLevel > 0 && o.logLevel <= 3 && console.log.apply(console, ["matter-js:"].concat(Array.prototype.slice.call(arguments)));
            }, o.info = function () {
              console && o.logLevel > 0 && o.logLevel <= 2 && console.info.apply(console, ["matter-js:"].concat(Array.prototype.slice.call(arguments)));
            }, o.warn = function () {
              console && o.logLevel > 0 && o.logLevel <= 3 && console.warn.apply(console, ["matter-js:"].concat(Array.prototype.slice.call(arguments)));
            }, o.nextId = function () {
              return o._nextId++;
            }, o.indexOf = function (e, t) {
              if (e.indexOf) return e.indexOf(t);

              for (var n = 0; n < e.length; n++) {
                if (e[n] === t) return n;
              }

              return -1;
            }, o.map = function (e, t) {
              if (e.map) return e.map(t);

              for (var n = [], o = 0; o < e.length; o += 1) {
                n.push(t(e[o]));
              }

              return n;
            }, o.topologicalSort = function (e) {
              var t = [],
                  n = [],
                  i = [];

              for (var r in e) {
                n[r] || i[r] || o._topologicalSort(r, n, i, e, t);
              }

              return t;
            }, o._topologicalSort = function (e, t, n, i, r) {
              var s = i[e] || [];
              n[e] = !0;

              for (var a = 0; a < s.length; a += 1) {
                var l = s[a];
                n[l] || t[l] || o._topologicalSort(l, t, n, i, r);
              }

              n[e] = !1, t[e] = !0, r.push(e);
            }, o.chain = function () {
              for (var e = [], t = 0; t < arguments.length; t += 1) {
                var n = arguments[t];
                n._chained ? e.push.apply(e, n._chained) : e.push(n);
              }

              var o = function o() {
                for (var t, n = new Array(arguments.length), o = 0, i = arguments.length; o < i; o++) {
                  n[o] = arguments[o];
                }

                for (o = 0; o < e.length; o += 1) {
                  var r = e[o].apply(t, n);
                  void 0 !== r && (t = r);
                }

                return t;
              };

              return o._chained = e, o;
            }, o.chainPathBefore = function (e, t, n) {
              return o.set(e, t, o.chain(n, o.get(e, t)));
            }, o.chainPathAfter = function (e, t, n) {
              return o.set(e, t, o.chain(o.get(e, t), n));
            }, o._requireGlobal = function (t, o) {
              return ("undefined" != typeof window ? window[t] : void 0 !== n ? n[t] : null) || e(o);
            };
          }();
        }).call(this, "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
      }, {}],
      15: [function (e, t, n) {
        var o = {};
        t.exports = o;
        var i = e("../body/World"),
            r = e("./Sleeping"),
            s = e("../collision/Resolver"),
            a = e("../render/Render"),
            l = e("../collision/Pairs"),
            c = (e("./Metrics"), e("../collision/Grid")),
            d = e("./Events"),
            u = e("../body/Composite"),
            p = e("../constraint/Constraint"),
            f = e("./Common"),
            m = e("../body/Body");
        !function () {
          o.create = function (e, t) {
            t = f.isElement(e) ? t : e, e = f.isElement(e) ? e : null, t = t || {}, (e || t.render) && f.warn("Engine.create: engine.render is deprecated (see docs)");
            var n = {
              positionIterations: 6,
              velocityIterations: 4,
              constraintIterations: 2,
              enableSleeping: !1,
              events: [],
              plugin: {},
              timing: {
                timestamp: 0,
                timeScale: 1
              },
              broadphase: {
                controller: c
              }
            },
                o = f.extend(n, t);

            if (e || o.render) {
              var r = {
                element: e,
                controller: a
              };
              o.render = f.extend(r, o.render);
            }

            return o.render && o.render.controller && (o.render = o.render.controller.create(o.render)), o.render && (o.render.engine = o), o.world = t.world || i.create(o.world), o.pairs = l.create(), o.broadphase = o.broadphase.controller.create(o.broadphase), o.metrics = o.metrics || {
              extended: !1
            }, o;
          }, o.update = function (e, t, n) {
            t = t || 1e3 / 60, n = n || 1;
            var i,
                a = e.world,
                c = e.timing,
                f = e.broadphase,
                m = [];
            c.timestamp += t * c.timeScale;
            var v = {
              timestamp: c.timestamp
            };
            d.trigger(e, "beforeUpdate", v);
            var y = u.allBodies(a),
                g = u.allConstraints(a);

            for (e.enableSleeping && r.update(y, c.timeScale), o._bodiesApplyGravity(y, a.gravity), o._bodiesUpdate(y, t, c.timeScale, n, a.bounds), p.preSolveAll(y), i = 0; i < e.constraintIterations; i++) {
              p.solveAll(g, c.timeScale);
            }

            p.postSolveAll(y), f.controller ? (a.isModified && f.controller.clear(f), f.controller.update(f, y, e, a.isModified), m = f.pairsList) : m = y, a.isModified && u.setModified(a, !1, !1, !0);
            var x = f.detector(m, e),
                h = e.pairs,
                b = c.timestamp;

            for (l.update(h, x, b), l.removeOld(h, b), e.enableSleeping && r.afterCollisions(h.list, c.timeScale), h.collisionStart.length > 0 && d.trigger(e, "collisionStart", {
              pairs: h.collisionStart
            }), s.preSolvePosition(h.list), i = 0; i < e.positionIterations; i++) {
              s.solvePosition(h.list, c.timeScale);
            }

            for (s.postSolvePosition(y), p.preSolveAll(y), i = 0; i < e.constraintIterations; i++) {
              p.solveAll(g, c.timeScale);
            }

            for (p.postSolveAll(y), s.preSolveVelocity(h.list), i = 0; i < e.velocityIterations; i++) {
              s.solveVelocity(h.list, c.timeScale);
            }

            return h.collisionActive.length > 0 && d.trigger(e, "collisionActive", {
              pairs: h.collisionActive
            }), h.collisionEnd.length > 0 && d.trigger(e, "collisionEnd", {
              pairs: h.collisionEnd
            }), o._bodiesClearForces(y), d.trigger(e, "afterUpdate", v), e;
          }, o.merge = function (e, t) {
            if (f.extend(e, t), t.world) {
              e.world = t.world, o.clear(e);

              for (var n = u.allBodies(e.world), i = 0; i < n.length; i++) {
                var s = n[i];
                r.set(s, !1), s.id = f.nextId();
              }
            }
          }, o.clear = function (e) {
            var t = e.world;
            l.clear(e.pairs);
            var n = e.broadphase;

            if (n.controller) {
              var o = u.allBodies(t);
              n.controller.clear(n), n.controller.update(n, o, e, !0);
            }
          }, o._bodiesClearForces = function (e) {
            for (var t = 0; t < e.length; t++) {
              var n = e[t];
              n.force.x = 0, n.force.y = 0, n.torque = 0;
            }
          }, o._bodiesApplyGravity = function (e, t) {
            var n = void 0 !== t.scale ? t.scale : .001;
            if ((0 !== t.x || 0 !== t.y) && 0 !== n) for (var o = 0; o < e.length; o++) {
              var i = e[o];
              i.isStatic || i.isSleeping || (i.force.y += i.mass * t.y * n, i.force.x += i.mass * t.x * n);
            }
          }, o._bodiesUpdate = function (e, t, n, o, i) {
            for (var r = 0; r < e.length; r++) {
              var s = e[r];
              s.isStatic || s.isSleeping || m.update(s, t, n, o);
            }
          };
        }();
      }, {
        "../body/Body": 1,
        "../body/Composite": 2,
        "../body/World": 3,
        "../collision/Grid": 6,
        "../collision/Pairs": 8,
        "../collision/Resolver": 10,
        "../constraint/Constraint": 12,
        "../render/Render": 31,
        "./Common": 14,
        "./Events": 16,
        "./Metrics": 18,
        "./Sleeping": 22
      }],
      16: [function (e, t, n) {
        var o = {};
        t.exports = o;
        var i = e("./Common");
        !function () {
          o.on = function (e, t, n) {
            for (var o, i = t.split(" "), r = 0; r < i.length; r++) {
              o = i[r], e.events = e.events || {}, e.events[o] = e.events[o] || [], e.events[o].push(n);
            }

            return n;
          }, o.off = function (e, t, n) {
            if (!t) return void (e.events = {});
            "function" == typeof t && (n = t, t = i.keys(e.events).join(" "));

            for (var o = t.split(" "), r = 0; r < o.length; r++) {
              var s = e.events[o[r]],
                  a = [];
              if (n && s) for (var l = 0; l < s.length; l++) {
                s[l] !== n && a.push(s[l]);
              }
              e.events[o[r]] = a;
            }
          }, o.trigger = function (e, t, n) {
            var o, r, s, a;

            if (e.events) {
              n || (n = {}), o = t.split(" ");

              for (var l = 0; l < o.length; l++) {
                if (r = o[l], s = e.events[r]) {
                  a = i.clone(n, !1), a.name = r, a.source = e;

                  for (var c = 0; c < s.length; c++) {
                    s[c].apply(e, [a]);
                  }
                }
              }
            }
          };
        }();
      }, {
        "./Common": 14
      }],
      17: [function (e, t, n) {
        var o = {};
        t.exports = o;
        var i = e("./Plugin"),
            r = e("./Common");
        !function () {
          o.name = "matter-js", o.version = "0.14.2", o.uses = [], o.used = [], o.use = function () {
            i.use(o, Array.prototype.slice.call(arguments));
          }, o.before = function (e, t) {
            return e = e.replace(/^Matter./, ""), r.chainPathBefore(o, e, t);
          }, o.after = function (e, t) {
            return e = e.replace(/^Matter./, ""), r.chainPathAfter(o, e, t);
          };
        }();
      }, {
        "./Common": 14,
        "./Plugin": 20
      }],
      18: [function (e, t, n) {}, {
        "../body/Composite": 2,
        "./Common": 14
      }],
      19: [function (e, t, n) {
        var o = {};
        t.exports = o;
        var i = e("../core/Common");
        !function () {
          o.create = function (e) {
            var t = {};
            return e || i.log("Mouse.create: element was undefined, defaulting to document.body", "warn"), t.element = e || document.body, t.absolute = {
              x: 0,
              y: 0
            }, t.position = {
              x: 0,
              y: 0
            }, t.mousedownPosition = {
              x: 0,
              y: 0
            }, t.mouseupPosition = {
              x: 0,
              y: 0
            }, t.offset = {
              x: 0,
              y: 0
            }, t.scale = {
              x: 1,
              y: 1
            }, t.wheelDelta = 0, t.button = -1, t.pixelRatio = t.element.getAttribute("data-pixel-ratio") || 1, t.sourceEvents = {
              mousemove: null,
              mousedown: null,
              mouseup: null,
              mousewheel: null
            }, t.mousemove = function (e) {
              var n = o._getRelativeMousePosition(e, t.element, t.pixelRatio);

              e.changedTouches && (t.button = 0, e.preventDefault()), t.absolute.x = n.x, t.absolute.y = n.y, t.position.x = t.absolute.x * t.scale.x + t.offset.x, t.position.y = t.absolute.y * t.scale.y + t.offset.y, t.sourceEvents.mousemove = e;
            }, t.mousedown = function (e) {
              var n = o._getRelativeMousePosition(e, t.element, t.pixelRatio);

              e.changedTouches ? (t.button = 0, e.preventDefault()) : t.button = e.button, t.absolute.x = n.x, t.absolute.y = n.y, t.position.x = t.absolute.x * t.scale.x + t.offset.x, t.position.y = t.absolute.y * t.scale.y + t.offset.y, t.mousedownPosition.x = t.position.x, t.mousedownPosition.y = t.position.y, t.sourceEvents.mousedown = e;
            }, t.mouseup = function (e) {
              var n = o._getRelativeMousePosition(e, t.element, t.pixelRatio);

              e.changedTouches && e.preventDefault(), t.button = -1, t.absolute.x = n.x, t.absolute.y = n.y, t.position.x = t.absolute.x * t.scale.x + t.offset.x, t.position.y = t.absolute.y * t.scale.y + t.offset.y, t.mouseupPosition.x = t.position.x, t.mouseupPosition.y = t.position.y, t.sourceEvents.mouseup = e;
            }, t.mousewheel = function (e) {
              t.wheelDelta = Math.max(-1, Math.min(1, e.wheelDelta || -e.detail)), e.preventDefault();
            }, o.setElement(t, t.element), t;
          }, o.setElement = function (e, t) {
            e.element = t, t.addEventListener("mousemove", e.mousemove), t.addEventListener("mousedown", e.mousedown), t.addEventListener("mouseup", e.mouseup), t.addEventListener("mousewheel", e.mousewheel), t.addEventListener("DOMMouseScroll", e.mousewheel), t.addEventListener("touchmove", e.mousemove), t.addEventListener("touchstart", e.mousedown), t.addEventListener("touchend", e.mouseup);
          }, o.clearSourceEvents = function (e) {
            e.sourceEvents.mousemove = null, e.sourceEvents.mousedown = null, e.sourceEvents.mouseup = null, e.sourceEvents.mousewheel = null, e.wheelDelta = 0;
          }, o.setOffset = function (e, t) {
            e.offset.x = t.x, e.offset.y = t.y, e.position.x = e.absolute.x * e.scale.x + e.offset.x, e.position.y = e.absolute.y * e.scale.y + e.offset.y;
          }, o.setScale = function (e, t) {
            e.scale.x = t.x, e.scale.y = t.y, e.position.x = e.absolute.x * e.scale.x + e.offset.x, e.position.y = e.absolute.y * e.scale.y + e.offset.y;
          }, o._getRelativeMousePosition = function (e, t, n) {
            var o,
                i,
                r = t.getBoundingClientRect(),
                s = document.documentElement || document.body.parentNode || document.body,
                a = void 0 !== window.pageXOffset ? window.pageXOffset : s.scrollLeft,
                l = void 0 !== window.pageYOffset ? window.pageYOffset : s.scrollTop,
                c = e.changedTouches;
            return c ? (o = c[0].pageX - r.left - a, i = c[0].pageY - r.top - l) : (o = e.pageX - r.left - a, i = e.pageY - r.top - l), {
              x: o / (t.clientWidth / (t.width || t.clientWidth) * n),
              y: i / (t.clientHeight / (t.height || t.clientHeight) * n)
            };
          };
        }();
      }, {
        "../core/Common": 14
      }],
      20: [function (e, t, n) {
        var o = {};
        t.exports = o;
        var i = e("./Common");
        !function () {
          o._registry = {}, o.register = function (e) {
            if (o.isPlugin(e) || i.warn("Plugin.register:", o.toString(e), "does not implement all required fields."), e.name in o._registry) {
              var t = o._registry[e.name],
                  n = o.versionParse(e.version).number,
                  r = o.versionParse(t.version).number;
              n > r ? (i.warn("Plugin.register:", o.toString(t), "was upgraded to", o.toString(e)), o._registry[e.name] = e) : n < r ? i.warn("Plugin.register:", o.toString(t), "can not be downgraded to", o.toString(e)) : e !== t && i.warn("Plugin.register:", o.toString(e), "is already registered to different plugin object");
            } else o._registry[e.name] = e;

            return e;
          }, o.resolve = function (e) {
            return o._registry[o.dependencyParse(e).name];
          }, o.toString = function (e) {
            return "string" == typeof e ? e : (e.name || "anonymous") + "@" + (e.version || e.range || "0.0.0");
          }, o.isPlugin = function (e) {
            return e && e.name && e.version && e.install;
          }, o.isUsed = function (e, t) {
            return e.used.indexOf(t) > -1;
          }, o.isFor = function (e, t) {
            var n = e["for"] && o.dependencyParse(e["for"]);
            return !e["for"] || t.name === n.name && o.versionSatisfies(t.version, n.range);
          }, o.use = function (e, t) {
            if (e.uses = (e.uses || []).concat(t || []), 0 === e.uses.length) return void i.warn("Plugin.use:", o.toString(e), "does not specify any dependencies to install.");

            for (var n = o.dependencies(e), r = i.topologicalSort(n), s = [], a = 0; a < r.length; a += 1) {
              if (r[a] !== e.name) {
                var l = o.resolve(r[a]);
                l ? o.isUsed(e, l.name) || (o.isFor(l, e) || (i.warn("Plugin.use:", o.toString(l), "is for", l["for"], "but installed on", o.toString(e) + "."), l._warned = !0), l.install ? l.install(e) : (i.warn("Plugin.use:", o.toString(l), "does not specify an install function."), l._warned = !0), l._warned ? (s.push("🔶 " + o.toString(l)), delete l._warned) : s.push("✅ " + o.toString(l)), e.used.push(l.name)) : s.push("❌ " + r[a]);
              }
            }

            s.length > 0 && i.info(s.join("  "));
          }, o.dependencies = function (e, t) {
            var n = o.dependencyParse(e),
                r = n.name;

            if (t = t || {}, !(r in t)) {
              e = o.resolve(e) || e, t[r] = i.map(e.uses || [], function (t) {
                o.isPlugin(t) && o.register(t);
                var r = o.dependencyParse(t),
                    s = o.resolve(t);
                return s && !o.versionSatisfies(s.version, r.range) ? (i.warn("Plugin.dependencies:", o.toString(s), "does not satisfy", o.toString(r), "used by", o.toString(n) + "."), s._warned = !0, e._warned = !0) : s || (i.warn("Plugin.dependencies:", o.toString(t), "used by", o.toString(n), "could not be resolved."), e._warned = !0), r.name;
              });

              for (var s = 0; s < t[r].length; s += 1) {
                o.dependencies(t[r][s], t);
              }

              return t;
            }
          }, o.dependencyParse = function (e) {
            if (i.isString(e)) {
              return /^[\w-]+(@(\*|[\^~]?\d+\.\d+\.\d+(-[0-9A-Za-z-]+)?))?$/.test(e) || i.warn("Plugin.dependencyParse:", e, "is not a valid dependency string."), {
                name: e.split("@")[0],
                range: e.split("@")[1] || "*"
              };
            }

            return {
              name: e.name,
              range: e.range || e.version
            };
          }, o.versionParse = function (e) {
            /^\*|[\^~]?\d+\.\d+\.\d+(-[0-9A-Za-z-]+)?$/.test(e) || i.warn("Plugin.versionParse:", e, "is not a valid version or range.");
            var t = e.split("-");
            e = t[0];
            var n = isNaN(Number(e[0])),
                o = n ? e.substr(1) : e,
                r = i.map(o.split("."), function (e) {
              return Number(e);
            });
            return {
              isRange: n,
              version: o,
              range: e,
              operator: n ? e[0] : "",
              parts: r,
              prerelease: t[1],
              number: 1e8 * r[0] + 1e4 * r[1] + r[2]
            };
          }, o.versionSatisfies = function (e, t) {
            t = t || "*";
            var n = o.versionParse(t),
                i = n.parts,
                r = o.versionParse(e),
                s = r.parts;

            if (n.isRange) {
              if ("*" === n.operator || "*" === e) return !0;
              if ("~" === n.operator) return s[0] === i[0] && s[1] === i[1] && s[2] >= i[2];
              if ("^" === n.operator) return i[0] > 0 ? s[0] === i[0] && r.number >= n.number : i[1] > 0 ? s[1] === i[1] && s[2] >= i[2] : s[2] === i[2];
            }

            return e === t || "*" === e;
          };
        }();
      }, {
        "./Common": 14
      }],
      21: [function (e, t, n) {
        var o = {};
        t.exports = o;
        var i = e("./Events"),
            r = e("./Engine"),
            s = e("./Common");
        !function () {
          var e, t;

          if ("undefined" != typeof window && (e = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.msRequestAnimationFrame, t = window.cancelAnimationFrame || window.mozCancelAnimationFrame || window.webkitCancelAnimationFrame || window.msCancelAnimationFrame), !e) {
            var n;
            e = function e(_e2) {
              n = setTimeout(function () {
                _e2(s.now());
              }, 1e3 / 60);
            }, t = function t() {
              clearTimeout(n);
            };
          }

          o.create = function (e) {
            var t = {
              fps: 60,
              correction: 1,
              deltaSampleSize: 60,
              counterTimestamp: 0,
              frameCounter: 0,
              deltaHistory: [],
              timePrev: null,
              timeScalePrev: 1,
              frameRequestId: null,
              isFixed: !1,
              enabled: !0
            },
                n = s.extend(t, e);
            return n.delta = n.delta || 1e3 / n.fps, n.deltaMin = n.deltaMin || 1e3 / n.fps, n.deltaMax = n.deltaMax || 1e3 / (.5 * n.fps), n.fps = 1e3 / n.delta, n;
          }, o.run = function (t, n) {
            return void 0 !== t.positionIterations && (n = t, t = o.create()), function i(r) {
              t.frameRequestId = e(i), r && t.enabled && o.tick(t, n, r);
            }(), t;
          }, o.tick = function (e, t, n) {
            var o,
                s = t.timing,
                a = 1,
                l = {
              timestamp: s.timestamp
            };
            i.trigger(e, "beforeTick", l), i.trigger(t, "beforeTick", l), e.isFixed ? o = e.delta : (o = n - e.timePrev || e.delta, e.timePrev = n, e.deltaHistory.push(o), e.deltaHistory = e.deltaHistory.slice(-e.deltaSampleSize), o = Math.min.apply(null, e.deltaHistory), o = o < e.deltaMin ? e.deltaMin : o, o = o > e.deltaMax ? e.deltaMax : o, a = o / e.delta, e.delta = o), 0 !== e.timeScalePrev && (a *= s.timeScale / e.timeScalePrev), 0 === s.timeScale && (a = 0), e.timeScalePrev = s.timeScale, e.correction = a, e.frameCounter += 1, n - e.counterTimestamp >= 1e3 && (e.fps = e.frameCounter * ((n - e.counterTimestamp) / 1e3), e.counterTimestamp = n, e.frameCounter = 0), i.trigger(e, "tick", l), i.trigger(t, "tick", l), t.world.isModified && t.render && t.render.controller && t.render.controller.clear && t.render.controller.clear(t.render), i.trigger(e, "beforeUpdate", l), r.update(t, o, a), i.trigger(e, "afterUpdate", l), t.render && t.render.controller && (i.trigger(e, "beforeRender", l), i.trigger(t, "beforeRender", l), t.render.controller.world(t.render), i.trigger(e, "afterRender", l), i.trigger(t, "afterRender", l)), i.trigger(e, "afterTick", l), i.trigger(t, "afterTick", l);
          }, o.stop = function (e) {
            t(e.frameRequestId);
          }, o.start = function (e, t) {
            o.run(e, t);
          };
        }();
      }, {
        "./Common": 14,
        "./Engine": 15,
        "./Events": 16
      }],
      22: [function (e, t, n) {
        var o = {};
        t.exports = o;
        var i = e("./Events");
        !function () {
          o._motionWakeThreshold = .18, o._motionSleepThreshold = .08, o._minBias = .9, o.update = function (e, t) {
            for (var n = t * t * t, i = 0; i < e.length; i++) {
              var r = e[i],
                  s = r.speed * r.speed + r.angularSpeed * r.angularSpeed;

              if (0 === r.force.x && 0 === r.force.y) {
                var a = Math.min(r.motion, s),
                    l = Math.max(r.motion, s);
                r.motion = o._minBias * a + (1 - o._minBias) * l, r.sleepThreshold > 0 && r.motion < o._motionSleepThreshold * n ? (r.sleepCounter += 1, r.sleepCounter >= r.sleepThreshold && o.set(r, !0)) : r.sleepCounter > 0 && (r.sleepCounter -= 1);
              } else o.set(r, !1);
            }
          }, o.afterCollisions = function (e, t) {
            for (var n = t * t * t, i = 0; i < e.length; i++) {
              var r = e[i];

              if (r.isActive) {
                var s = r.collision,
                    a = s.bodyA.parent,
                    l = s.bodyB.parent;

                if (!(a.isSleeping && l.isSleeping || a.isStatic || l.isStatic) && (a.isSleeping || l.isSleeping)) {
                  var c = a.isSleeping && !a.isStatic ? a : l,
                      d = c === a ? l : a;
                  !c.isStatic && d.motion > o._motionWakeThreshold * n && o.set(c, !1);
                }
              }
            }
          }, o.set = function (e, t) {
            var n = e.isSleeping;
            t ? (e.isSleeping = !0, e.sleepCounter = e.sleepThreshold, e.positionImpulse.x = 0, e.positionImpulse.y = 0, e.positionPrev.x = e.position.x, e.positionPrev.y = e.position.y, e.anglePrev = e.angle, e.speed = 0, e.angularSpeed = 0, e.motion = 0, n || i.trigger(e, "sleepStart")) : (e.isSleeping = !1, e.sleepCounter = 0, n && i.trigger(e, "sleepEnd"));
          };
        }();
      }, {
        "./Events": 16
      }],
      23: [function (e, t, n) {
        var o = {};
        t.exports = o;
        var i,
            r = e("../geometry/Vertices"),
            s = e("../core/Common"),
            a = e("../body/Body"),
            l = e("../geometry/Bounds"),
            c = e("../geometry/Vector");
        !function () {
          o.rectangle = function (e, t, n, o, i) {
            i = i || {};
            var l = {
              label: "Rectangle Body",
              position: {
                x: e,
                y: t
              },
              vertices: r.fromPath("L 0 0 L " + n + " 0 L " + n + " " + o + " L 0 " + o)
            };

            if (i.chamfer) {
              var c = i.chamfer;
              l.vertices = r.chamfer(l.vertices, c.radius, c.quality, c.qualityMin, c.qualityMax), delete i.chamfer;
            }

            return a.create(s.extend({}, l, i));
          }, o.trapezoid = function (e, t, n, o, i, l) {
            l = l || {}, i *= .5;
            var c,
                d = (1 - 2 * i) * n,
                u = n * i,
                p = u + d,
                f = p + u;
            c = i < .5 ? "L 0 0 L " + u + " " + -o + " L " + p + " " + -o + " L " + f + " 0" : "L 0 0 L " + p + " " + -o + " L " + f + " 0";
            var m = {
              label: "Trapezoid Body",
              position: {
                x: e,
                y: t
              },
              vertices: r.fromPath(c)
            };

            if (l.chamfer) {
              var v = l.chamfer;
              m.vertices = r.chamfer(m.vertices, v.radius, v.quality, v.qualityMin, v.qualityMax), delete l.chamfer;
            }

            return a.create(s.extend({}, m, l));
          }, o.circle = function (e, t, n, i, r) {
            i = i || {};
            var a = {
              label: "Circle Body",
              circleRadius: n
            };
            r = r || 25;
            var l = Math.ceil(Math.max(10, Math.min(r, n)));
            return l % 2 == 1 && (l += 1), o.polygon(e, t, l, n, s.extend({}, a, i));
          }, o.polygon = function (e, t, n, i, l) {
            if (l = l || {}, n < 3) return o.circle(e, t, i, l);

            for (var c = 2 * Math.PI / n, d = "", u = .5 * c, p = 0; p < n; p += 1) {
              var f = u + p * c,
                  m = Math.cos(f) * i,
                  v = Math.sin(f) * i;
              d += "L " + m.toFixed(3) + " " + v.toFixed(3) + " ";
            }

            var y = {
              label: "Polygon Body",
              position: {
                x: e,
                y: t
              },
              vertices: r.fromPath(d)
            };

            if (l.chamfer) {
              var g = l.chamfer;
              y.vertices = r.chamfer(y.vertices, g.radius, g.quality, g.qualityMin, g.qualityMax), delete l.chamfer;
            }

            return a.create(s.extend({}, y, l));
          }, o.fromVertices = function (e, t, n, o, d, u, p) {
            i || (i = s._requireGlobal("decomp", "poly-decomp"));
            var f, m, v, y, g, x, h, b, w;

            for (o = o || {}, m = [], d = void 0 !== d && d, u = void 0 !== u ? u : .01, p = void 0 !== p ? p : 10, i || s.warn("Bodies.fromVertices: poly-decomp.js required. Could not decompose vertices. Fallback to convex hull."), s.isArray(n[0]) || (n = [n]), b = 0; b < n.length; b += 1) {
              if (y = n[b], (v = r.isConvex(y)) || !i) y = v ? r.clockwiseSort(y) : r.hull(y), m.push({
                position: {
                  x: e,
                  y: t
                },
                vertices: y
              });else {
                var S = y.map(function (e) {
                  return [e.x, e.y];
                });
                i.makeCCW(S), !1 !== u && i.removeCollinearPoints(S, u);
                var C = i.quickDecomp(S);

                for (g = 0; g < C.length; g++) {
                  var A = C[g],
                      P = A.map(function (e) {
                    return {
                      x: e[0],
                      y: e[1]
                    };
                  });
                  p > 0 && r.area(P) < p || m.push({
                    position: r.centre(P),
                    vertices: P
                  });
                }
              }
            }

            for (g = 0; g < m.length; g++) {
              m[g] = a.create(s.extend(m[g], o));
            }

            if (d) {
              for (g = 0; g < m.length; g++) {
                var B = m[g];

                for (x = g + 1; x < m.length; x++) {
                  var M = m[x];

                  if (l.overlaps(B.bounds, M.bounds)) {
                    var k = B.vertices,
                        I = M.vertices;

                    for (h = 0; h < B.vertices.length; h++) {
                      for (w = 0; w < M.vertices.length; w++) {
                        var _ = c.magnitudeSquared(c.sub(k[(h + 1) % k.length], I[w])),
                            T = c.magnitudeSquared(c.sub(k[h], I[(w + 1) % I.length]));

                        _ < 5 && T < 5 && (k[h].isInternal = !0, I[w].isInternal = !0);
                      }
                    }
                  }
                }
              }
            }

            return m.length > 1 ? (f = a.create(s.extend({
              parts: m.slice(0)
            }, o)), a.setPosition(f, {
              x: e,
              y: t
            }), f) : m[0];
          };
        }();
      }, {
        "../body/Body": 1,
        "../core/Common": 14,
        "../geometry/Bounds": 26,
        "../geometry/Vector": 28,
        "../geometry/Vertices": 29
      }],
      24: [function (e, t, n) {
        var o = {};
        t.exports = o;
        var i = e("../body/Composite"),
            r = e("../constraint/Constraint"),
            s = e("../core/Common"),
            a = e("../body/Body"),
            l = e("./Bodies");
        !function () {
          o.stack = function (e, t, n, o, r, s, l) {
            for (var c, d = i.create({
              label: "Stack"
            }), u = e, p = t, f = 0, m = 0; m < o; m++) {
              for (var v = 0, y = 0; y < n; y++) {
                var g = l(u, p, y, m, c, f);

                if (g) {
                  var x = g.bounds.max.y - g.bounds.min.y,
                      h = g.bounds.max.x - g.bounds.min.x;
                  x > v && (v = x), a.translate(g, {
                    x: .5 * h,
                    y: .5 * x
                  }), u = g.bounds.max.x + r, i.addBody(d, g), c = g, f += 1;
                } else u += r;
              }

              p += v + s, u = e;
            }

            return d;
          }, o.chain = function (e, t, n, o, a, l) {
            for (var c = e.bodies, d = 1; d < c.length; d++) {
              var u = c[d - 1],
                  p = c[d],
                  f = u.bounds.max.y - u.bounds.min.y,
                  m = u.bounds.max.x - u.bounds.min.x,
                  v = p.bounds.max.y - p.bounds.min.y,
                  y = p.bounds.max.x - p.bounds.min.x,
                  g = {
                bodyA: u,
                pointA: {
                  x: m * t,
                  y: f * n
                },
                bodyB: p,
                pointB: {
                  x: y * o,
                  y: v * a
                }
              },
                  x = s.extend(g, l);
              i.addConstraint(e, r.create(x));
            }

            return e.label += " Chain", e;
          }, o.mesh = function (e, t, n, o, a) {
            var l,
                c,
                d,
                u,
                p,
                f = e.bodies;

            for (l = 0; l < n; l++) {
              for (c = 1; c < t; c++) {
                d = f[c - 1 + l * t], u = f[c + l * t], i.addConstraint(e, r.create(s.extend({
                  bodyA: d,
                  bodyB: u
                }, a)));
              }

              if (l > 0) for (c = 0; c < t; c++) {
                d = f[c + (l - 1) * t], u = f[c + l * t], i.addConstraint(e, r.create(s.extend({
                  bodyA: d,
                  bodyB: u
                }, a))), o && c > 0 && (p = f[c - 1 + (l - 1) * t], i.addConstraint(e, r.create(s.extend({
                  bodyA: p,
                  bodyB: u
                }, a)))), o && c < t - 1 && (p = f[c + 1 + (l - 1) * t], i.addConstraint(e, r.create(s.extend({
                  bodyA: p,
                  bodyB: u
                }, a))));
              }
            }

            return e.label += " Mesh", e;
          }, o.pyramid = function (e, t, n, i, r, s, l) {
            return o.stack(e, t, n, i, r, s, function (t, o, s, c, d, u) {
              var p = Math.min(i, Math.ceil(n / 2)),
                  f = d ? d.bounds.max.x - d.bounds.min.x : 0;

              if (!(c > p)) {
                c = p - c;
                var m = c,
                    v = n - 1 - c;

                if (!(s < m || s > v)) {
                  1 === u && a.translate(d, {
                    x: (s + (n % 2 == 1 ? 1 : -1)) * f,
                    y: 0
                  });
                  return l(e + (d ? s * f : 0) + s * r, o, s, c, d, u);
                }
              }
            });
          }, o.newtonsCradle = function (e, t, n, o, s) {
            for (var a = i.create({
              label: "Newtons Cradle"
            }), c = 0; c < n; c++) {
              var d = l.circle(e + c * (1.9 * o), t + s, o, {
                inertia: 1 / 0,
                restitution: 1,
                friction: 0,
                frictionAir: 1e-4,
                slop: 1
              }),
                  u = r.create({
                pointA: {
                  x: e + c * (1.9 * o),
                  y: t
                },
                bodyB: d
              });
              i.addBody(a, d), i.addConstraint(a, u);
            }

            return a;
          }, o.car = function (e, t, n, o, s) {
            var c = a.nextGroup(!0),
                d = .5 * -n + 20,
                u = .5 * n - 20,
                p = i.create({
              label: "Car"
            }),
                f = l.rectangle(e, t, n, o, {
              collisionFilter: {
                group: c
              },
              chamfer: {
                radius: .5 * o
              },
              density: 2e-4
            }),
                m = l.circle(e + d, t + 0, s, {
              collisionFilter: {
                group: c
              },
              friction: .8
            }),
                v = l.circle(e + u, t + 0, s, {
              collisionFilter: {
                group: c
              },
              friction: .8
            }),
                y = r.create({
              bodyB: f,
              pointB: {
                x: d,
                y: 0
              },
              bodyA: m,
              stiffness: 1,
              length: 0
            }),
                g = r.create({
              bodyB: f,
              pointB: {
                x: u,
                y: 0
              },
              bodyA: v,
              stiffness: 1,
              length: 0
            });
            return i.addBody(p, f), i.addBody(p, m), i.addBody(p, v), i.addConstraint(p, y), i.addConstraint(p, g), p;
          }, o.softBody = function (e, t, n, i, r, a, c, d, u, p) {
            u = s.extend({
              inertia: 1 / 0
            }, u), p = s.extend({
              stiffness: .2,
              render: {
                type: "line",
                anchors: !1
              }
            }, p);
            var f = o.stack(e, t, n, i, r, a, function (e, t) {
              return l.circle(e, t, d, u);
            });
            return o.mesh(f, n, i, c, p), f.label = "Soft Body", f;
          };
        }();
      }, {
        "../body/Body": 1,
        "../body/Composite": 2,
        "../constraint/Constraint": 12,
        "../core/Common": 14,
        "./Bodies": 23
      }],
      25: [function (e, t, n) {
        var o = {};
        t.exports = o;
        var i = e("../geometry/Vector"),
            r = e("../core/Common");
        !function () {
          o.fromVertices = function (e) {
            for (var t = {}, n = 0; n < e.length; n++) {
              var o = (n + 1) % e.length,
                  s = i.normalise({
                x: e[o].y - e[n].y,
                y: e[n].x - e[o].x
              }),
                  a = 0 === s.y ? 1 / 0 : s.x / s.y;
              a = a.toFixed(3).toString(), t[a] = s;
            }

            return r.values(t);
          }, o.rotate = function (e, t) {
            if (0 !== t) for (var n = Math.cos(t), o = Math.sin(t), i = 0; i < e.length; i++) {
              var r,
                  s = e[i];
              r = s.x * n - s.y * o, s.y = s.x * o + s.y * n, s.x = r;
            }
          };
        }();
      }, {
        "../core/Common": 14,
        "../geometry/Vector": 28
      }],
      26: [function (e, t, n) {
        var o = {};
        t.exports = o, function () {
          o.create = function (e) {
            var t = {
              min: {
                x: 0,
                y: 0
              },
              max: {
                x: 0,
                y: 0
              }
            };
            return e && o.update(t, e), t;
          }, o.update = function (e, t, n) {
            e.min.x = 1 / 0, e.max.x = -1 / 0, e.min.y = 1 / 0, e.max.y = -1 / 0;

            for (var o = 0; o < t.length; o++) {
              var i = t[o];
              i.x > e.max.x && (e.max.x = i.x), i.x < e.min.x && (e.min.x = i.x), i.y > e.max.y && (e.max.y = i.y), i.y < e.min.y && (e.min.y = i.y);
            }

            n && (n.x > 0 ? e.max.x += n.x : e.min.x += n.x, n.y > 0 ? e.max.y += n.y : e.min.y += n.y);
          }, o.contains = function (e, t) {
            return t.x >= e.min.x && t.x <= e.max.x && t.y >= e.min.y && t.y <= e.max.y;
          }, o.overlaps = function (e, t) {
            return e.min.x <= t.max.x && e.max.x >= t.min.x && e.max.y >= t.min.y && e.min.y <= t.max.y;
          }, o.translate = function (e, t) {
            e.min.x += t.x, e.max.x += t.x, e.min.y += t.y, e.max.y += t.y;
          }, o.shift = function (e, t) {
            var n = e.max.x - e.min.x,
                o = e.max.y - e.min.y;
            e.min.x = t.x, e.max.x = t.x + n, e.min.y = t.y, e.max.y = t.y + o;
          };
        }();
      }, {}],
      27: [function (e, t, n) {
        var o = {};
        t.exports = o;
        var i = (e("../geometry/Bounds"), e("../core/Common"));
        !function () {
          o.pathToVertices = function (e, t) {
            "undefined" == typeof window || "SVGPathSeg" in window || i.warn("Svg.pathToVertices: SVGPathSeg not defined, a polyfill is required.");
            var n,
                r,
                s,
                a,
                l,
                c,
                d,
                u,
                p,
                f,
                m,
                v,
                y = [],
                g = 0,
                x = 0,
                h = 0;
            t = t || 15;

            var b = function b(e, t, n) {
              var o = n % 2 == 1 && n > 1;

              if (!p || e != p.x || t != p.y) {
                p && o ? (m = p.x, v = p.y) : (m = 0, v = 0);
                var i = {
                  x: m + e,
                  y: v + t
                };
                !o && p || (p = i), y.push(i), x = m + e, h = v + t;
              }
            },
                w = function w(e) {
              var t = e.pathSegTypeAsLetter.toUpperCase();

              if ("Z" !== t) {
                switch (t) {
                  case "M":
                  case "L":
                  case "T":
                  case "C":
                  case "S":
                  case "Q":
                    x = e.x, h = e.y;
                    break;

                  case "H":
                    x = e.x;
                    break;

                  case "V":
                    h = e.y;
                }

                b(x, h, e.pathSegType);
              }
            };

            for (o._svgPathToAbsolute(e), s = e.getTotalLength(), c = [], n = 0; n < e.pathSegList.numberOfItems; n += 1) {
              c.push(e.pathSegList.getItem(n));
            }

            for (d = c.concat(); g < s;) {
              if (f = e.getPathSegAtLength(g), (l = c[f]) != u) {
                for (; d.length && d[0] != l;) {
                  w(d.shift());
                }

                u = l;
              }

              switch (l.pathSegTypeAsLetter.toUpperCase()) {
                case "C":
                case "T":
                case "S":
                case "Q":
                case "A":
                  a = e.getPointAtLength(g), b(a.x, a.y, 0);
              }

              g += t;
            }

            for (n = 0, r = d.length; n < r; ++n) {
              w(d[n]);
            }

            return y;
          }, o._svgPathToAbsolute = function (e) {
            for (var t, n, o, i, r, s, a = e.pathSegList, l = 0, c = 0, d = a.numberOfItems, u = 0; u < d; ++u) {
              var p = a.getItem(u),
                  f = p.pathSegTypeAsLetter;
              if (/[MLHVCSQTA]/.test(f)) "x" in p && (l = p.x), "y" in p && (c = p.y);else switch ("x1" in p && (o = l + p.x1), "x2" in p && (r = l + p.x2), "y1" in p && (i = c + p.y1), "y2" in p && (s = c + p.y2), "x" in p && (l += p.x), "y" in p && (c += p.y), f) {
                case "m":
                  a.replaceItem(e.createSVGPathSegMovetoAbs(l, c), u);
                  break;

                case "l":
                  a.replaceItem(e.createSVGPathSegLinetoAbs(l, c), u);
                  break;

                case "h":
                  a.replaceItem(e.createSVGPathSegLinetoHorizontalAbs(l), u);
                  break;

                case "v":
                  a.replaceItem(e.createSVGPathSegLinetoVerticalAbs(c), u);
                  break;

                case "c":
                  a.replaceItem(e.createSVGPathSegCurvetoCubicAbs(l, c, o, i, r, s), u);
                  break;

                case "s":
                  a.replaceItem(e.createSVGPathSegCurvetoCubicSmoothAbs(l, c, r, s), u);
                  break;

                case "q":
                  a.replaceItem(e.createSVGPathSegCurvetoQuadraticAbs(l, c, o, i), u);
                  break;

                case "t":
                  a.replaceItem(e.createSVGPathSegCurvetoQuadraticSmoothAbs(l, c), u);
                  break;

                case "a":
                  a.replaceItem(e.createSVGPathSegArcAbs(l, c, p.r1, p.r2, p.angle, p.largeArcFlag, p.sweepFlag), u);
                  break;

                case "z":
                case "Z":
                  l = t, c = n;
              }
              "M" != f && "m" != f || (t = l, n = c);
            }
          };
        }();
      }, {
        "../core/Common": 14,
        "../geometry/Bounds": 26
      }],
      28: [function (e, t, n) {
        var o = {};
        t.exports = o, function () {
          o.create = function (e, t) {
            return {
              x: e || 0,
              y: t || 0
            };
          }, o.clone = function (e) {
            return {
              x: e.x,
              y: e.y
            };
          }, o.magnitude = function (e) {
            return Math.sqrt(e.x * e.x + e.y * e.y);
          }, o.magnitudeSquared = function (e) {
            return e.x * e.x + e.y * e.y;
          }, o.rotate = function (e, t, n) {
            var o = Math.cos(t),
                i = Math.sin(t);
            n || (n = {});
            var r = e.x * o - e.y * i;
            return n.y = e.x * i + e.y * o, n.x = r, n;
          }, o.rotateAbout = function (e, t, n, o) {
            var i = Math.cos(t),
                r = Math.sin(t);
            o || (o = {});
            var s = n.x + ((e.x - n.x) * i - (e.y - n.y) * r);
            return o.y = n.y + ((e.x - n.x) * r + (e.y - n.y) * i), o.x = s, o;
          }, o.normalise = function (e) {
            var t = o.magnitude(e);
            return 0 === t ? {
              x: 0,
              y: 0
            } : {
              x: e.x / t,
              y: e.y / t
            };
          }, o.dot = function (e, t) {
            return e.x * t.x + e.y * t.y;
          }, o.cross = function (e, t) {
            return e.x * t.y - e.y * t.x;
          }, o.cross3 = function (e, t, n) {
            return (t.x - e.x) * (n.y - e.y) - (t.y - e.y) * (n.x - e.x);
          }, o.add = function (e, t, n) {
            return n || (n = {}), n.x = e.x + t.x, n.y = e.y + t.y, n;
          }, o.sub = function (e, t, n) {
            return n || (n = {}), n.x = e.x - t.x, n.y = e.y - t.y, n;
          }, o.mult = function (e, t) {
            return {
              x: e.x * t,
              y: e.y * t
            };
          }, o.div = function (e, t) {
            return {
              x: e.x / t,
              y: e.y / t
            };
          }, o.perp = function (e, t) {
            return t = !0 === t ? -1 : 1, {
              x: t * -e.y,
              y: t * e.x
            };
          }, o.neg = function (e) {
            return {
              x: -e.x,
              y: -e.y
            };
          }, o.angle = function (e, t) {
            return Math.atan2(t.y - e.y, t.x - e.x);
          }, o._temp = [o.create(), o.create(), o.create(), o.create(), o.create(), o.create()];
        }();
      }, {}],
      29: [function (e, t, n) {
        var o = {};
        t.exports = o;
        var i = e("../geometry/Vector"),
            r = e("../core/Common");
        !function () {
          o.create = function (e, t) {
            for (var n = [], o = 0; o < e.length; o++) {
              var i = e[o],
                  r = {
                x: i.x,
                y: i.y,
                index: o,
                body: t,
                isInternal: !1
              };
              n.push(r);
            }

            return n;
          }, o.fromPath = function (e, t) {
            var n = /L?\s*([\-\d\.e]+)[\s,]*([\-\d\.e]+)*/gi,
                i = [];
            return e.replace(n, function (e, t, n) {
              i.push({
                x: parseFloat(t),
                y: parseFloat(n)
              });
            }), o.create(i, t);
          }, o.centre = function (e) {
            for (var t, n, r, s = o.area(e, !0), a = {
              x: 0,
              y: 0
            }, l = 0; l < e.length; l++) {
              r = (l + 1) % e.length, t = i.cross(e[l], e[r]), n = i.mult(i.add(e[l], e[r]), t), a = i.add(a, n);
            }

            return i.div(a, 6 * s);
          }, o.mean = function (e) {
            for (var t = {
              x: 0,
              y: 0
            }, n = 0; n < e.length; n++) {
              t.x += e[n].x, t.y += e[n].y;
            }

            return i.div(t, e.length);
          }, o.area = function (e, t) {
            for (var n = 0, o = e.length - 1, i = 0; i < e.length; i++) {
              n += (e[o].x - e[i].x) * (e[o].y + e[i].y), o = i;
            }

            return t ? n / 2 : Math.abs(n) / 2;
          }, o.inertia = function (e, t) {
            for (var n, o, r = 0, s = 0, a = e, l = 0; l < a.length; l++) {
              o = (l + 1) % a.length, n = Math.abs(i.cross(a[o], a[l])), r += n * (i.dot(a[o], a[o]) + i.dot(a[o], a[l]) + i.dot(a[l], a[l])), s += n;
            }

            return t / 6 * (r / s);
          }, o.translate = function (e, t, n) {
            var o;
            if (n) for (o = 0; o < e.length; o++) {
              e[o].x += t.x * n, e[o].y += t.y * n;
            } else for (o = 0; o < e.length; o++) {
              e[o].x += t.x, e[o].y += t.y;
            }
            return e;
          }, o.rotate = function (e, t, n) {
            if (0 !== t) {
              for (var o = Math.cos(t), i = Math.sin(t), r = 0; r < e.length; r++) {
                var s = e[r],
                    a = s.x - n.x,
                    l = s.y - n.y;
                s.x = n.x + (a * o - l * i), s.y = n.y + (a * i + l * o);
              }

              return e;
            }
          }, o.contains = function (e, t) {
            for (var n = 0; n < e.length; n++) {
              var o = e[n],
                  i = e[(n + 1) % e.length];
              if ((t.x - o.x) * (i.y - o.y) + (t.y - o.y) * (o.x - i.x) > 0) return !1;
            }

            return !0;
          }, o.scale = function (e, t, n, r) {
            if (1 === t && 1 === n) return e;
            r = r || o.centre(e);

            for (var s, a, l = 0; l < e.length; l++) {
              s = e[l], a = i.sub(s, r), e[l].x = r.x + a.x * t, e[l].y = r.y + a.y * n;
            }

            return e;
          }, o.chamfer = function (e, t, n, o, s) {
            t = "number" == typeof t ? [t] : t || [8], n = void 0 !== n ? n : -1, o = o || 2, s = s || 14;

            for (var a = [], l = 0; l < e.length; l++) {
              var c = e[l - 1 >= 0 ? l - 1 : e.length - 1],
                  d = e[l],
                  u = e[(l + 1) % e.length],
                  p = t[l < t.length ? l : t.length - 1];

              if (0 !== p) {
                var f = i.normalise({
                  x: d.y - c.y,
                  y: c.x - d.x
                }),
                    m = i.normalise({
                  x: u.y - d.y,
                  y: d.x - u.x
                }),
                    v = Math.sqrt(2 * Math.pow(p, 2)),
                    y = i.mult(r.clone(f), p),
                    g = i.normalise(i.mult(i.add(f, m), .5)),
                    x = i.sub(d, i.mult(g, v)),
                    h = n;
                -1 === n && (h = 1.75 * Math.pow(p, .32)), h = r.clamp(h, o, s), h % 2 == 1 && (h += 1);

                for (var b = Math.acos(i.dot(f, m)), w = b / h, S = 0; S < h; S++) {
                  a.push(i.add(i.rotate(y, w * S), x));
                }
              } else a.push(d);
            }

            return a;
          }, o.clockwiseSort = function (e) {
            var t = o.mean(e);
            return e.sort(function (e, n) {
              return i.angle(t, e) - i.angle(t, n);
            }), e;
          }, o.isConvex = function (e) {
            var t,
                n,
                o,
                i,
                r = 0,
                s = e.length;
            if (s < 3) return null;

            for (t = 0; t < s; t++) {
              if (n = (t + 1) % s, o = (t + 2) % s, i = (e[n].x - e[t].x) * (e[o].y - e[n].y), i -= (e[n].y - e[t].y) * (e[o].x - e[n].x), i < 0 ? r |= 1 : i > 0 && (r |= 2), 3 === r) return !1;
            }

            return 0 !== r || null;
          }, o.hull = function (e) {
            var t,
                n,
                o = [],
                r = [];

            for (e = e.slice(0), e.sort(function (e, t) {
              var n = e.x - t.x;
              return 0 !== n ? n : e.y - t.y;
            }), n = 0; n < e.length; n += 1) {
              for (t = e[n]; r.length >= 2 && i.cross3(r[r.length - 2], r[r.length - 1], t) <= 0;) {
                r.pop();
              }

              r.push(t);
            }

            for (n = e.length - 1; n >= 0; n -= 1) {
              for (t = e[n]; o.length >= 2 && i.cross3(o[o.length - 2], o[o.length - 1], t) <= 0;) {
                o.pop();
              }

              o.push(t);
            }

            return o.pop(), r.pop(), o.concat(r);
          };
        }();
      }, {
        "../core/Common": 14,
        "../geometry/Vector": 28
      }],
      30: [function (e, t, n) {
        var o = t.exports = e("../core/Matter");
        o.Body = e("../body/Body"), o.Composite = e("../body/Composite"), o.World = e("../body/World"), o.Contact = e("../collision/Contact"), o.Detector = e("../collision/Detector"), o.Grid = e("../collision/Grid"), o.Pairs = e("../collision/Pairs"), o.Pair = e("../collision/Pair"), o.Query = e("../collision/Query"), o.Resolver = e("../collision/Resolver"), o.SAT = e("../collision/SAT"), o.Constraint = e("../constraint/Constraint"), o.MouseConstraint = e("../constraint/MouseConstraint"), o.Common = e("../core/Common"), o.Engine = e("../core/Engine"), o.Events = e("../core/Events"), o.Mouse = e("../core/Mouse"), o.Runner = e("../core/Runner"), o.Sleeping = e("../core/Sleeping"), o.Plugin = e("../core/Plugin"), o.Bodies = e("../factory/Bodies"), o.Composites = e("../factory/Composites"), o.Axes = e("../geometry/Axes"), o.Bounds = e("../geometry/Bounds"), o.Svg = e("../geometry/Svg"), o.Vector = e("../geometry/Vector"), o.Vertices = e("../geometry/Vertices"), o.Render = e("../render/Render"), o.RenderPixi = e("../render/RenderPixi"), o.World.add = o.Composite.add, o.World.remove = o.Composite.remove, o.World.addComposite = o.Composite.addComposite, o.World.addBody = o.Composite.addBody, o.World.addConstraint = o.Composite.addConstraint, o.World.clear = o.Composite.clear, o.Engine.run = o.Runner.run;
      }, {
        "../body/Body": 1,
        "../body/Composite": 2,
        "../body/World": 3,
        "../collision/Contact": 4,
        "../collision/Detector": 5,
        "../collision/Grid": 6,
        "../collision/Pair": 7,
        "../collision/Pairs": 8,
        "../collision/Query": 9,
        "../collision/Resolver": 10,
        "../collision/SAT": 11,
        "../constraint/Constraint": 12,
        "../constraint/MouseConstraint": 13,
        "../core/Common": 14,
        "../core/Engine": 15,
        "../core/Events": 16,
        "../core/Matter": 17,
        "../core/Metrics": 18,
        "../core/Mouse": 19,
        "../core/Plugin": 20,
        "../core/Runner": 21,
        "../core/Sleeping": 22,
        "../factory/Bodies": 23,
        "../factory/Composites": 24,
        "../geometry/Axes": 25,
        "../geometry/Bounds": 26,
        "../geometry/Svg": 27,
        "../geometry/Vector": 28,
        "../geometry/Vertices": 29,
        "../render/Render": 31,
        "../render/RenderPixi": 32
      }],
      31: [function (e, t, n) {
        var o = {};
        t.exports = o;
        var i = e("../core/Common"),
            r = e("../body/Composite"),
            s = e("../geometry/Bounds"),
            a = e("../core/Events"),
            l = e("../collision/Grid"),
            c = e("../geometry/Vector"),
            d = e("../core/Mouse");
        !function () {
          var e, t;
          "undefined" != typeof window && (e = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.msRequestAnimationFrame || function (e) {
            window.setTimeout(function () {
              e(i.now());
            }, 1e3 / 60);
          }, t = window.cancelAnimationFrame || window.mozCancelAnimationFrame || window.webkitCancelAnimationFrame || window.msCancelAnimationFrame), o.create = function (e) {
            var t = {
              controller: o,
              engine: null,
              element: null,
              canvas: null,
              mouse: null,
              frameRequestId: null,
              options: {
                width: 800,
                height: 600,
                pixelRatio: 1,
                background: "#18181d",
                wireframeBackground: "#0f0f13",
                hasBounds: !!e.bounds,
                enabled: !0,
                wireframes: !0,
                showSleeping: !0,
                showDebug: !1,
                showBroadphase: !1,
                showBounds: !1,
                showVelocity: !1,
                showCollisions: !1,
                showSeparations: !1,
                showAxes: !1,
                showPositions: !1,
                showAngleIndicator: !1,
                showIds: !1,
                showShadows: !1,
                showVertexNumbers: !1,
                showConvexHulls: !1,
                showInternalEdges: !1,
                showMousePosition: !1
              }
            },
                r = i.extend(t, e);
            return r.canvas && (r.canvas.width = r.options.width || r.canvas.width, r.canvas.height = r.options.height || r.canvas.height), r.mouse = e.mouse, r.engine = e.engine, r.canvas = r.canvas || n(r.options.width, r.options.height), r.context = r.canvas.getContext("2d"), r.textures = {}, r.bounds = r.bounds || {
              min: {
                x: 0,
                y: 0
              },
              max: {
                x: r.canvas.width,
                y: r.canvas.height
              }
            }, 1 !== r.options.pixelRatio && o.setPixelRatio(r, r.options.pixelRatio), i.isElement(r.element) ? r.element.appendChild(r.canvas) : r.canvas.parentNode || i.log("Render.create: options.element was undefined, render.canvas was created but not appended", "warn"), r;
          }, o.run = function (t) {
            !function n(i) {
              t.frameRequestId = e(n), o.world(t);
            }();
          }, o.stop = function (e) {
            t(e.frameRequestId);
          }, o.setPixelRatio = function (e, t) {
            var n = e.options,
                o = e.canvas;
            "auto" === t && (t = u(o)), n.pixelRatio = t, o.setAttribute("data-pixel-ratio", t), o.width = n.width * t, o.height = n.height * t, o.style.width = n.width + "px", o.style.height = n.height + "px", e.context.scale(t, t);
          }, o.lookAt = function (e, t, n, o) {
            o = void 0 === o || o, t = i.isArray(t) ? t : [t], n = n || {
              x: 0,
              y: 0
            };

            for (var r = {
              min: {
                x: 1 / 0,
                y: 1 / 0
              },
              max: {
                x: -1 / 0,
                y: -1 / 0
              }
            }, s = 0; s < t.length; s += 1) {
              var a = t[s],
                  l = a.bounds ? a.bounds.min : a.min || a.position || a,
                  c = a.bounds ? a.bounds.max : a.max || a.position || a;
              l && c && (l.x < r.min.x && (r.min.x = l.x), c.x > r.max.x && (r.max.x = c.x), l.y < r.min.y && (r.min.y = l.y), c.y > r.max.y && (r.max.y = c.y));
            }

            var u = r.max.x - r.min.x + 2 * n.x,
                p = r.max.y - r.min.y + 2 * n.y,
                f = e.canvas.height,
                m = e.canvas.width,
                v = m / f,
                y = u / p,
                g = 1,
                x = 1;
            y > v ? x = y / v : g = v / y, e.options.hasBounds = !0, e.bounds.min.x = r.min.x, e.bounds.max.x = r.min.x + u * g, e.bounds.min.y = r.min.y, e.bounds.max.y = r.min.y + p * x, o && (e.bounds.min.x += .5 * u - u * g * .5, e.bounds.max.x += .5 * u - u * g * .5, e.bounds.min.y += .5 * p - p * x * .5, e.bounds.max.y += .5 * p - p * x * .5), e.bounds.min.x -= n.x, e.bounds.max.x -= n.x, e.bounds.min.y -= n.y, e.bounds.max.y -= n.y, e.mouse && (d.setScale(e.mouse, {
              x: (e.bounds.max.x - e.bounds.min.x) / e.canvas.width,
              y: (e.bounds.max.y - e.bounds.min.y) / e.canvas.height
            }), d.setOffset(e.mouse, e.bounds.min));
          }, o.startViewTransform = function (e) {
            var t = e.bounds.max.x - e.bounds.min.x,
                n = e.bounds.max.y - e.bounds.min.y,
                o = t / e.options.width,
                i = n / e.options.height;
            e.context.scale(1 / o, 1 / i), e.context.translate(-e.bounds.min.x, -e.bounds.min.y);
          }, o.endViewTransform = function (e) {
            e.context.setTransform(e.options.pixelRatio, 0, 0, e.options.pixelRatio, 0, 0);
          }, o.world = function (e) {
            var t,
                n = e.engine,
                i = n.world,
                u = e.canvas,
                p = e.context,
                m = e.options,
                v = r.allBodies(i),
                y = r.allConstraints(i),
                g = m.wireframes ? m.wireframeBackground : m.background,
                x = [],
                h = [],
                b = {
              timestamp: n.timing.timestamp
            };

            if (a.trigger(e, "beforeRender", b), e.currentBackground !== g && f(e, g), p.globalCompositeOperation = "source-in", p.fillStyle = "transparent", p.fillRect(0, 0, u.width, u.height), p.globalCompositeOperation = "source-over", m.hasBounds) {
              for (t = 0; t < v.length; t++) {
                var w = v[t];
                s.overlaps(w.bounds, e.bounds) && x.push(w);
              }

              for (t = 0; t < y.length; t++) {
                var S = y[t],
                    C = S.bodyA,
                    A = S.bodyB,
                    P = S.pointA,
                    B = S.pointB;
                C && (P = c.add(C.position, S.pointA)), A && (B = c.add(A.position, S.pointB)), P && B && (s.contains(e.bounds, P) || s.contains(e.bounds, B)) && h.push(S);
              }

              o.startViewTransform(e), e.mouse && (d.setScale(e.mouse, {
                x: (e.bounds.max.x - e.bounds.min.x) / e.canvas.width,
                y: (e.bounds.max.y - e.bounds.min.y) / e.canvas.height
              }), d.setOffset(e.mouse, e.bounds.min));
            } else h = y, x = v;

            !m.wireframes || n.enableSleeping && m.showSleeping ? o.bodies(e, x, p) : (m.showConvexHulls && o.bodyConvexHulls(e, x, p), o.bodyWireframes(e, x, p)), m.showBounds && o.bodyBounds(e, x, p), (m.showAxes || m.showAngleIndicator) && o.bodyAxes(e, x, p), m.showPositions && o.bodyPositions(e, x, p), m.showVelocity && o.bodyVelocity(e, x, p), m.showIds && o.bodyIds(e, x, p), m.showSeparations && o.separations(e, n.pairs.list, p), m.showCollisions && o.collisions(e, n.pairs.list, p), m.showVertexNumbers && o.vertexNumbers(e, x, p), m.showMousePosition && o.mousePosition(e, e.mouse, p), o.constraints(h, p), m.showBroadphase && n.broadphase.controller === l && o.grid(e, n.broadphase, p), m.showDebug && o.debug(e, p), m.hasBounds && o.endViewTransform(e), a.trigger(e, "afterRender", b);
          }, o.debug = function (e, t) {
            var n = t,
                o = e.engine,
                i = o.world,
                s = o.metrics,
                a = e.options;
            r.allBodies(i);

            if (o.timing.timestamp - (e.debugTimestamp || 0) >= 500) {
              var l = "";
              s.timing && (l += "fps: " + Math.round(s.timing.fps) + "    "), e.debugString = l, e.debugTimestamp = o.timing.timestamp;
            }

            if (e.debugString) {
              n.font = "12px Arial", a.wireframes ? n.fillStyle = "rgba(255,255,255,0.5)" : n.fillStyle = "rgba(0,0,0,0.5)";

              for (var c = e.debugString.split("\n"), d = 0; d < c.length; d++) {
                n.fillText(c[d], 50, 50 + 18 * d);
              }
            }
          }, o.constraints = function (e, t) {
            for (var n = t, o = 0; o < e.length; o++) {
              var r = e[o];

              if (r.render.visible && r.pointA && r.pointB) {
                var s,
                    a,
                    l = r.bodyA,
                    d = r.bodyB;
                if (s = l ? c.add(l.position, r.pointA) : r.pointA, "pin" === r.render.type) n.beginPath(), n.arc(s.x, s.y, 3, 0, 2 * Math.PI), n.closePath();else {
                  if (a = d ? c.add(d.position, r.pointB) : r.pointB, n.beginPath(), n.moveTo(s.x, s.y), "spring" === r.render.type) for (var u, p = c.sub(a, s), f = c.perp(c.normalise(p)), m = Math.ceil(i.clamp(r.length / 5, 12, 20)), v = 1; v < m; v += 1) {
                    u = v % 2 == 0 ? 1 : -1, n.lineTo(s.x + p.x * (v / m) + f.x * u * 4, s.y + p.y * (v / m) + f.y * u * 4);
                  }
                  n.lineTo(a.x, a.y);
                }
                r.render.lineWidth && (n.lineWidth = r.render.lineWidth, n.strokeStyle = r.render.strokeStyle, n.stroke()), r.render.anchors && (n.fillStyle = r.render.strokeStyle, n.beginPath(), n.arc(s.x, s.y, 3, 0, 2 * Math.PI), n.arc(a.x, a.y, 3, 0, 2 * Math.PI), n.closePath(), n.fill());
              }
            }
          }, o.bodyShadows = function (e, t, n) {
            for (var o = n, i = (e.engine, 0); i < t.length; i++) {
              var r = t[i];

              if (r.render.visible) {
                if (r.circleRadius) o.beginPath(), o.arc(r.position.x, r.position.y, r.circleRadius, 0, 2 * Math.PI), o.closePath();else {
                  o.beginPath(), o.moveTo(r.vertices[0].x, r.vertices[0].y);

                  for (var s = 1; s < r.vertices.length; s++) {
                    o.lineTo(r.vertices[s].x, r.vertices[s].y);
                  }

                  o.closePath();
                }
                var a = r.position.x - .5 * e.options.width,
                    l = r.position.y - .2 * e.options.height,
                    c = Math.abs(a) + Math.abs(l);
                o.shadowColor = "rgba(0,0,0,0.15)", o.shadowOffsetX = .05 * a, o.shadowOffsetY = .05 * l, o.shadowBlur = 1 + 12 * Math.min(1, c / 1e3), o.fill(), o.shadowColor = null, o.shadowOffsetX = null, o.shadowOffsetY = null, o.shadowBlur = null;
              }
            }
          }, o.bodies = function (e, t, n) {
            var o,
                i,
                r,
                s,
                a = n,
                l = (e.engine, e.options),
                c = l.showInternalEdges || !l.wireframes;

            for (r = 0; r < t.length; r++) {
              if (o = t[r], o.render.visible) for (s = o.parts.length > 1 ? 1 : 0; s < o.parts.length; s++) {
                if (i = o.parts[s], i.render.visible) {
                  if (l.showSleeping && o.isSleeping ? a.globalAlpha = .5 * i.render.opacity : 1 !== i.render.opacity && (a.globalAlpha = i.render.opacity), i.render.sprite && i.render.sprite.texture && !l.wireframes) {
                    var d = i.render.sprite,
                        u = p(e, d.texture);
                    a.translate(i.position.x, i.position.y), a.rotate(i.angle), a.drawImage(u, u.width * -d.xOffset * d.xScale, u.height * -d.yOffset * d.yScale, u.width * d.xScale, u.height * d.yScale), a.rotate(-i.angle), a.translate(-i.position.x, -i.position.y);
                  } else {
                    if (i.circleRadius) a.beginPath(), a.arc(i.position.x, i.position.y, i.circleRadius, 0, 2 * Math.PI);else {
                      a.beginPath(), a.moveTo(i.vertices[0].x, i.vertices[0].y);

                      for (var f = 1; f < i.vertices.length; f++) {
                        !i.vertices[f - 1].isInternal || c ? a.lineTo(i.vertices[f].x, i.vertices[f].y) : a.moveTo(i.vertices[f].x, i.vertices[f].y), i.vertices[f].isInternal && !c && a.moveTo(i.vertices[(f + 1) % i.vertices.length].x, i.vertices[(f + 1) % i.vertices.length].y);
                      }

                      a.lineTo(i.vertices[0].x, i.vertices[0].y), a.closePath();
                    }
                    l.wireframes ? (a.lineWidth = 1, a.strokeStyle = "#bbb", a.stroke()) : (a.fillStyle = i.render.fillStyle, i.render.lineWidth && (a.lineWidth = i.render.lineWidth, a.strokeStyle = i.render.strokeStyle, a.stroke()), a.fill());
                  }

                  a.globalAlpha = 1;
                }
              }
            }
          }, o.bodyWireframes = function (e, t, n) {
            var o,
                i,
                r,
                s,
                a,
                l = n,
                c = e.options.showInternalEdges;

            for (l.beginPath(), r = 0; r < t.length; r++) {
              if (o = t[r], o.render.visible) for (a = o.parts.length > 1 ? 1 : 0; a < o.parts.length; a++) {
                for (i = o.parts[a], l.moveTo(i.vertices[0].x, i.vertices[0].y), s = 1; s < i.vertices.length; s++) {
                  !i.vertices[s - 1].isInternal || c ? l.lineTo(i.vertices[s].x, i.vertices[s].y) : l.moveTo(i.vertices[s].x, i.vertices[s].y), i.vertices[s].isInternal && !c && l.moveTo(i.vertices[(s + 1) % i.vertices.length].x, i.vertices[(s + 1) % i.vertices.length].y);
                }

                l.lineTo(i.vertices[0].x, i.vertices[0].y);
              }
            }

            l.lineWidth = 1, l.strokeStyle = "#bbb", l.stroke();
          }, o.bodyConvexHulls = function (e, t, n) {
            var o,
                i,
                r,
                s = n;

            for (s.beginPath(), i = 0; i < t.length; i++) {
              if (o = t[i], o.render.visible && 1 !== o.parts.length) {
                for (s.moveTo(o.vertices[0].x, o.vertices[0].y), r = 1; r < o.vertices.length; r++) {
                  s.lineTo(o.vertices[r].x, o.vertices[r].y);
                }

                s.lineTo(o.vertices[0].x, o.vertices[0].y);
              }
            }

            s.lineWidth = 1, s.strokeStyle = "rgba(255,255,255,0.2)", s.stroke();
          }, o.vertexNumbers = function (e, t, n) {
            var o,
                i,
                r,
                s = n;

            for (o = 0; o < t.length; o++) {
              var a = t[o].parts;

              for (r = a.length > 1 ? 1 : 0; r < a.length; r++) {
                var l = a[r];

                for (i = 0; i < l.vertices.length; i++) {
                  s.fillStyle = "rgba(255,255,255,0.2)", s.fillText(o + "_" + i, l.position.x + .8 * (l.vertices[i].x - l.position.x), l.position.y + .8 * (l.vertices[i].y - l.position.y));
                }
              }
            }
          }, o.mousePosition = function (e, t, n) {
            var o = n;
            o.fillStyle = "rgba(255,255,255,0.8)", o.fillText(t.position.x + "  " + t.position.y, t.position.x + 5, t.position.y - 5);
          }, o.bodyBounds = function (e, t, n) {
            var o = n,
                i = (e.engine, e.options);
            o.beginPath();

            for (var r = 0; r < t.length; r++) {
              if (t[r].render.visible) for (var s = t[r].parts, a = s.length > 1 ? 1 : 0; a < s.length; a++) {
                var l = s[a];
                o.rect(l.bounds.min.x, l.bounds.min.y, l.bounds.max.x - l.bounds.min.x, l.bounds.max.y - l.bounds.min.y);
              }
            }

            i.wireframes ? o.strokeStyle = "rgba(255,255,255,0.08)" : o.strokeStyle = "rgba(0,0,0,0.1)", o.lineWidth = 1, o.stroke();
          }, o.bodyAxes = function (e, t, n) {
            var o,
                i,
                r,
                s,
                a = n,
                l = (e.engine, e.options);

            for (a.beginPath(), i = 0; i < t.length; i++) {
              var c = t[i],
                  d = c.parts;
              if (c.render.visible) if (l.showAxes) for (r = d.length > 1 ? 1 : 0; r < d.length; r++) {
                for (o = d[r], s = 0; s < o.axes.length; s++) {
                  var u = o.axes[s];
                  a.moveTo(o.position.x, o.position.y), a.lineTo(o.position.x + 20 * u.x, o.position.y + 20 * u.y);
                }
              } else for (r = d.length > 1 ? 1 : 0; r < d.length; r++) {
                for (o = d[r], s = 0; s < o.axes.length; s++) {
                  a.moveTo(o.position.x, o.position.y), a.lineTo((o.vertices[0].x + o.vertices[o.vertices.length - 1].x) / 2, (o.vertices[0].y + o.vertices[o.vertices.length - 1].y) / 2);
                }
              }
            }

            l.wireframes ? (a.strokeStyle = "indianred", a.lineWidth = 1) : (a.strokeStyle = "rgba(255, 255, 255, 0.4)", a.globalCompositeOperation = "overlay", a.lineWidth = 2), a.stroke(), a.globalCompositeOperation = "source-over";
          }, o.bodyPositions = function (e, t, n) {
            var o,
                i,
                r,
                s,
                a = n,
                l = (e.engine, e.options);

            for (a.beginPath(), r = 0; r < t.length; r++) {
              if (o = t[r], o.render.visible) for (s = 0; s < o.parts.length; s++) {
                i = o.parts[s], a.arc(i.position.x, i.position.y, 3, 0, 2 * Math.PI, !1), a.closePath();
              }
            }

            for (l.wireframes ? a.fillStyle = "indianred" : a.fillStyle = "rgba(0,0,0,0.5)", a.fill(), a.beginPath(), r = 0; r < t.length; r++) {
              o = t[r], o.render.visible && (a.arc(o.positionPrev.x, o.positionPrev.y, 2, 0, 2 * Math.PI, !1), a.closePath());
            }

            a.fillStyle = "rgba(255,165,0,0.8)", a.fill();
          }, o.bodyVelocity = function (e, t, n) {
            var o = n;
            o.beginPath();

            for (var i = 0; i < t.length; i++) {
              var r = t[i];
              r.render.visible && (o.moveTo(r.position.x, r.position.y), o.lineTo(r.position.x + 2 * (r.position.x - r.positionPrev.x), r.position.y + 2 * (r.position.y - r.positionPrev.y)));
            }

            o.lineWidth = 3, o.strokeStyle = "cornflowerblue", o.stroke();
          }, o.bodyIds = function (e, t, n) {
            var o,
                i,
                r = n;

            for (o = 0; o < t.length; o++) {
              if (t[o].render.visible) {
                var s = t[o].parts;

                for (i = s.length > 1 ? 1 : 0; i < s.length; i++) {
                  var a = s[i];
                  r.font = "12px Arial", r.fillStyle = "rgba(255,255,255,0.5)", r.fillText(a.id, a.position.x + 10, a.position.y - 10);
                }
              }
            }
          }, o.collisions = function (e, t, n) {
            var o,
                i,
                r,
                s,
                a = n,
                l = e.options;

            for (a.beginPath(), r = 0; r < t.length; r++) {
              if (o = t[r], o.isActive) for (i = o.collision, s = 0; s < o.activeContacts.length; s++) {
                var c = o.activeContacts[s],
                    d = c.vertex;
                a.rect(d.x - 1.5, d.y - 1.5, 3.5, 3.5);
              }
            }

            for (l.wireframes ? a.fillStyle = "rgba(255,255,255,0.7)" : a.fillStyle = "orange", a.fill(), a.beginPath(), r = 0; r < t.length; r++) {
              if (o = t[r], o.isActive && (i = o.collision, o.activeContacts.length > 0)) {
                var u = o.activeContacts[0].vertex.x,
                    p = o.activeContacts[0].vertex.y;
                2 === o.activeContacts.length && (u = (o.activeContacts[0].vertex.x + o.activeContacts[1].vertex.x) / 2, p = (o.activeContacts[0].vertex.y + o.activeContacts[1].vertex.y) / 2), i.bodyB === i.supports[0].body || !0 === i.bodyA.isStatic ? a.moveTo(u - 8 * i.normal.x, p - 8 * i.normal.y) : a.moveTo(u + 8 * i.normal.x, p + 8 * i.normal.y), a.lineTo(u, p);
              }
            }

            l.wireframes ? a.strokeStyle = "rgba(255,165,0,0.7)" : a.strokeStyle = "orange", a.lineWidth = 1, a.stroke();
          }, o.separations = function (e, t, n) {
            var o,
                i,
                r,
                s,
                a,
                l = n,
                c = e.options;

            for (l.beginPath(), a = 0; a < t.length; a++) {
              if (o = t[a], o.isActive) {
                i = o.collision, r = i.bodyA, s = i.bodyB;
                var d = 1;
                s.isStatic || r.isStatic || (d = .5), s.isStatic && (d = 0), l.moveTo(s.position.x, s.position.y), l.lineTo(s.position.x - i.penetration.x * d, s.position.y - i.penetration.y * d), d = 1, s.isStatic || r.isStatic || (d = .5), r.isStatic && (d = 0), l.moveTo(r.position.x, r.position.y), l.lineTo(r.position.x + i.penetration.x * d, r.position.y + i.penetration.y * d);
              }
            }

            c.wireframes ? l.strokeStyle = "rgba(255,165,0,0.5)" : l.strokeStyle = "orange", l.stroke();
          }, o.grid = function (e, t, n) {
            var o = n;
            e.options.wireframes ? o.strokeStyle = "rgba(255,180,0,0.1)" : o.strokeStyle = "rgba(255,180,0,0.5)", o.beginPath();

            for (var r = i.keys(t.buckets), s = 0; s < r.length; s++) {
              var a = r[s];

              if (!(t.buckets[a].length < 2)) {
                var l = a.split(/C|R/);
                o.rect(.5 + parseInt(l[1], 10) * t.bucketWidth, .5 + parseInt(l[2], 10) * t.bucketHeight, t.bucketWidth, t.bucketHeight);
              }
            }

            o.lineWidth = 1, o.stroke();
          }, o.inspector = function (e, t) {
            var n,
                o = (e.engine, e.selected),
                i = e.render,
                r = i.options;

            if (r.hasBounds) {
              var s = i.bounds.max.x - i.bounds.min.x,
                  a = i.bounds.max.y - i.bounds.min.y,
                  l = s / i.options.width,
                  c = a / i.options.height;
              t.scale(1 / l, 1 / c), t.translate(-i.bounds.min.x, -i.bounds.min.y);
            }

            for (var d = 0; d < o.length; d++) {
              var u = o[d].data;

              switch (t.translate(.5, .5), t.lineWidth = 1, t.strokeStyle = "rgba(255,165,0,0.9)", t.setLineDash([1, 2]), u.type) {
                case "body":
                  n = u.bounds, t.beginPath(), t.rect(Math.floor(n.min.x - 3), Math.floor(n.min.y - 3), Math.floor(n.max.x - n.min.x + 6), Math.floor(n.max.y - n.min.y + 6)), t.closePath(), t.stroke();
                  break;

                case "constraint":
                  var p = u.pointA;
                  u.bodyA && (p = u.pointB), t.beginPath(), t.arc(p.x, p.y, 10, 0, 2 * Math.PI), t.closePath(), t.stroke();
              }

              t.setLineDash([]), t.translate(-.5, -.5);
            }

            null !== e.selectStart && (t.translate(.5, .5), t.lineWidth = 1, t.strokeStyle = "rgba(255,165,0,0.6)", t.fillStyle = "rgba(255,165,0,0.1)", n = e.selectBounds, t.beginPath(), t.rect(Math.floor(n.min.x), Math.floor(n.min.y), Math.floor(n.max.x - n.min.x), Math.floor(n.max.y - n.min.y)), t.closePath(), t.stroke(), t.fill(), t.translate(-.5, -.5)), r.hasBounds && t.setTransform(1, 0, 0, 1, 0, 0);
          };

          var n = function n(e, t) {
            var n = document.createElement("canvas");
            return n.width = e, n.height = t, n.oncontextmenu = function () {
              return !1;
            }, n.onselectstart = function () {
              return !1;
            }, n;
          },
              u = function u(e) {
            var t = e.getContext("2d");
            return (window.devicePixelRatio || 1) / (t.webkitBackingStorePixelRatio || t.mozBackingStorePixelRatio || t.msBackingStorePixelRatio || t.oBackingStorePixelRatio || t.backingStorePixelRatio || 1);
          },
              p = function p(e, t) {
            var n = e.textures[t];
            return n || (n = e.textures[t] = new Image(), n.src = t, n);
          },
              f = function f(e, t) {
            var n = t;
            /(jpg|gif|png)$/.test(t) && (n = "url(" + t + ")"), e.canvas.style.background = n, e.canvas.style.backgroundSize = "contain", e.currentBackground = t;
          };
        }();
      }, {
        "../body/Composite": 2,
        "../collision/Grid": 6,
        "../core/Common": 14,
        "../core/Events": 16,
        "../core/Mouse": 19,
        "../geometry/Bounds": 26,
        "../geometry/Vector": 28
      }],
      32: [function (e, t, n) {
        var o = {};
        t.exports = o;
        var i = e("../geometry/Bounds"),
            r = e("../body/Composite"),
            s = e("../core/Common"),
            a = e("../core/Events"),
            l = e("../geometry/Vector");
        !function () {
          var e, t;
          "undefined" != typeof window && (e = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.msRequestAnimationFrame || function (e) {
            window.setTimeout(function () {
              e(s.now());
            }, 1e3 / 60);
          }, t = window.cancelAnimationFrame || window.mozCancelAnimationFrame || window.webkitCancelAnimationFrame || window.msCancelAnimationFrame), o.create = function (e) {
            s.warn("RenderPixi.create: Matter.RenderPixi is deprecated (see docs)");
            var t = {
              controller: o,
              engine: null,
              element: null,
              frameRequestId: null,
              canvas: null,
              renderer: null,
              container: null,
              spriteContainer: null,
              pixiOptions: null,
              options: {
                width: 800,
                height: 600,
                background: "#fafafa",
                wireframeBackground: "#222",
                hasBounds: !1,
                enabled: !0,
                wireframes: !0,
                showSleeping: !0,
                showDebug: !1,
                showBroadphase: !1,
                showBounds: !1,
                showVelocity: !1,
                showCollisions: !1,
                showAxes: !1,
                showPositions: !1,
                showAngleIndicator: !1,
                showIds: !1,
                showShadows: !1
              }
            },
                n = s.extend(t, e),
                i = !n.options.wireframes && "transparent" === n.options.background;
            return n.pixiOptions = n.pixiOptions || {
              view: n.canvas,
              transparent: i,
              antialias: !0,
              backgroundColor: e.background
            }, n.mouse = e.mouse, n.engine = e.engine, n.renderer = n.renderer || new PIXI.WebGLRenderer(n.options.width, n.options.height, n.pixiOptions), n.container = n.container || new PIXI.Container(), n.spriteContainer = n.spriteContainer || new PIXI.Container(), n.canvas = n.canvas || n.renderer.view, n.bounds = n.bounds || {
              min: {
                x: 0,
                y: 0
              },
              max: {
                x: n.options.width,
                y: n.options.height
              }
            }, a.on(n.engine, "beforeUpdate", function () {
              o.clear(n);
            }), n.textures = {}, n.sprites = {}, n.primitives = {}, n.container.addChild(n.spriteContainer), s.isElement(n.element) ? n.element.appendChild(n.canvas) : s.warn('No "render.element" passed, "render.canvas" was not inserted into document.'), n.canvas.oncontextmenu = function () {
              return !1;
            }, n.canvas.onselectstart = function () {
              return !1;
            }, n;
          }, o.run = function (t) {
            !function n(i) {
              t.frameRequestId = e(n), o.world(t);
            }();
          }, o.stop = function (e) {
            t(e.frameRequestId);
          }, o.clear = function (e) {
            for (var t = e.container, n = e.spriteContainer; t.children[0];) {
              t.removeChild(t.children[0]);
            }

            for (; n.children[0];) {
              n.removeChild(n.children[0]);
            }

            var o = e.sprites["bg-0"];
            e.textures = {}, e.sprites = {}, e.primitives = {}, e.sprites["bg-0"] = o, o && t.addChildAt(o, 0), e.container.addChild(e.spriteContainer), e.currentBackground = null, t.scale.set(1, 1), t.position.set(0, 0);
          }, o.setBackground = function (e, t) {
            if (e.currentBackground !== t) {
              var n = t.indexOf && -1 !== t.indexOf("#"),
                  o = e.sprites["bg-0"];

              if (n) {
                var i = s.colorToNumber(t);
                e.renderer.backgroundColor = i, o && e.container.removeChild(o);
              } else if (!o) {
                var r = d(e, t);
                o = e.sprites["bg-0"] = new PIXI.Sprite(r), o.position.x = 0, o.position.y = 0, e.container.addChildAt(o, 0);
              }

              e.currentBackground = t;
            }
          }, o.world = function (e) {
            var t,
                n = e.engine,
                s = n.world,
                a = e.renderer,
                c = e.container,
                d = e.options,
                u = r.allBodies(s),
                p = r.allConstraints(s),
                f = [];
            d.wireframes ? o.setBackground(e, d.wireframeBackground) : o.setBackground(e, d.background);
            var m = e.bounds.max.x - e.bounds.min.x,
                v = e.bounds.max.y - e.bounds.min.y,
                y = m / e.options.width,
                g = v / e.options.height;

            if (d.hasBounds) {
              for (t = 0; t < u.length; t++) {
                var x = u[t];
                x.render.sprite.visible = i.overlaps(x.bounds, e.bounds);
              }

              for (t = 0; t < p.length; t++) {
                var h = p[t],
                    b = h.bodyA,
                    w = h.bodyB,
                    S = h.pointA,
                    C = h.pointB;
                b && (S = l.add(b.position, h.pointA)), w && (C = l.add(w.position, h.pointB)), S && C && (i.contains(e.bounds, S) || i.contains(e.bounds, C)) && f.push(h);
              }

              c.scale.set(1 / y, 1 / g), c.position.set(-e.bounds.min.x * (1 / y), -e.bounds.min.y * (1 / g));
            } else f = p;

            for (t = 0; t < u.length; t++) {
              o.body(e, u[t]);
            }

            for (t = 0; t < f.length; t++) {
              o.constraint(e, f[t]);
            }

            a.render(c);
          }, o.constraint = function (e, t) {
            var n = (e.engine, t.bodyA),
                o = t.bodyB,
                i = t.pointA,
                r = t.pointB,
                a = e.container,
                l = t.render,
                c = "c-" + t.id,
                d = e.primitives[c];
            if (d || (d = e.primitives[c] = new PIXI.Graphics()), !l.visible || !t.pointA || !t.pointB) return void d.clear();
            -1 === s.indexOf(a.children, d) && a.addChild(d), d.clear(), d.beginFill(0, 0), d.lineStyle(l.lineWidth, s.colorToNumber(l.strokeStyle), 1), n ? d.moveTo(n.position.x + i.x, n.position.y + i.y) : d.moveTo(i.x, i.y), o ? d.lineTo(o.position.x + r.x, o.position.y + r.y) : d.lineTo(r.x, r.y), d.endFill();
          }, o.body = function (e, t) {
            var o = (e.engine, t.render);
            if (o.visible) if (o.sprite && o.sprite.texture) {
              var i = "b-" + t.id,
                  r = e.sprites[i],
                  a = e.spriteContainer;
              r || (r = e.sprites[i] = n(e, t)), -1 === s.indexOf(a.children, r) && a.addChild(r), r.position.x = t.position.x, r.position.y = t.position.y, r.rotation = t.angle, r.scale.x = o.sprite.xScale || 1, r.scale.y = o.sprite.yScale || 1;
            } else {
              var l = "b-" + t.id,
                  d = e.primitives[l],
                  u = e.container;
              d || (d = e.primitives[l] = c(e, t), d.initialAngle = t.angle), -1 === s.indexOf(u.children, d) && u.addChild(d), d.position.x = t.position.x, d.position.y = t.position.y, d.rotation = t.angle - d.initialAngle;
            }
          };

          var n = function n(e, t) {
            var n = t.render,
                o = n.sprite.texture,
                i = d(e, o),
                r = new PIXI.Sprite(i);
            return r.anchor.x = t.render.sprite.xOffset, r.anchor.y = t.render.sprite.yOffset, r;
          },
              c = function c(e, t) {
            var n,
                o = t.render,
                i = e.options,
                r = new PIXI.Graphics(),
                a = s.colorToNumber(o.fillStyle),
                l = s.colorToNumber(o.strokeStyle),
                c = s.colorToNumber(o.strokeStyle),
                d = s.colorToNumber("#bbb"),
                u = s.colorToNumber("#CD5C5C");
            r.clear();

            for (var p = t.parts.length > 1 ? 1 : 0; p < t.parts.length; p++) {
              n = t.parts[p], i.wireframes ? (r.beginFill(0, 0), r.lineStyle(1, d, 1)) : (r.beginFill(a, 1), r.lineStyle(o.lineWidth, l, 1)), r.moveTo(n.vertices[0].x - t.position.x, n.vertices[0].y - t.position.y);

              for (var f = 1; f < n.vertices.length; f++) {
                r.lineTo(n.vertices[f].x - t.position.x, n.vertices[f].y - t.position.y);
              }

              r.lineTo(n.vertices[0].x - t.position.x, n.vertices[0].y - t.position.y), r.endFill(), (i.showAngleIndicator || i.showAxes) && (r.beginFill(0, 0), i.wireframes ? r.lineStyle(1, u, 1) : r.lineStyle(1, c), r.moveTo(n.position.x - t.position.x, n.position.y - t.position.y), r.lineTo((n.vertices[0].x + n.vertices[n.vertices.length - 1].x) / 2 - t.position.x, (n.vertices[0].y + n.vertices[n.vertices.length - 1].y) / 2 - t.position.y), r.endFill());
            }

            return r;
          },
              d = function d(e, t) {
            var n = e.textures[t];
            return n || (n = e.textures[t] = PIXI.Texture.fromImage(t)), n;
          };
        }();
      }, {
        "../body/Composite": 2,
        "../core/Common": 14,
        "../core/Events": 16,
        "../geometry/Bounds": 26,
        "../geometry/Vector": 28
      }]
    }, {}, [30])(30);
  });

  !function (f, a, c) {
    var s,
        l = 256,
        p = "random",
        d = c.pow(l, 6),
        g = c.pow(2, 52),
        y = 2 * g,
        h = l - 1;

    function n(n, t, r) {
      function e() {
        for (var n = u.g(6), t = d, r = 0; n < g;) {
          n = (n + r) * l, t *= l, r = u.g(1);
        }

        for (; y <= n;) {
          n /= 2, t /= 2, r >>>= 1;
        }

        return (n + r) / t;
      }

      var o = [],
          i = j(function n(t, r) {
        var e,
            o = [],
            i = _typeof(t);

        if (r && "object" == i) for (e in t) {
          try {
            o.push(n(t[e], r - 1));
          } catch (n) {}
        }
        return o.length ? o : "string" == i ? t : t + "\0";
      }((t = 1 == t ? {
        entropy: !0
      } : t || {}).entropy ? [n, S(a)] : null == n ? function () {
        try {
          var n;
          return s && (n = s.randomBytes) ? n = n(l) : (n = new Uint8Array(l), (f.crypto || f.msCrypto).getRandomValues(n)), S(n);
        } catch (n) {
          var t = f.navigator,
              r = t && t.plugins;
          return [+new Date(), f, r, f.screen, S(a)];
        }
      }() : n, 3), o),
          u = new m(o);
      return e.int32 = function () {
        return 0 | u.g(4);
      }, e.quick = function () {
        return u.g(4) / 4294967296;
      }, e["double"] = e, j(S(u.S), a), (t.pass || r || function (n, t, r, e) {
        return e && (e.S && v(e, u), n.state = function () {
          return v(u, {});
        }), r ? (c[p] = n, t) : n;
      })(e, i, "global" in t ? t.global : this == c, t.state);
    }

    function m(n) {
      var t,
          r = n.length,
          u = this,
          e = 0,
          o = u.i = u.j = 0,
          i = u.S = [];

      for (r || (n = [r++]); e < l;) {
        i[e] = e++;
      }

      for (e = 0; e < l; e++) {
        i[e] = i[o = h & o + n[e % r] + (t = i[e])], i[o] = t;
      }

      (u.g = function (n) {
        for (var t, r = 0, e = u.i, o = u.j, i = u.S; n--;) {
          t = i[e = h & e + 1], r = r * l + i[h & (i[e] = i[o = h & o + t]) + (i[o] = t)];
        }

        return u.i = e, u.j = o, r;
      })(l);
    }

    function v(n, t) {
      return t.i = n.i, t.j = n.j, t.S = n.S.slice(), t;
    }

    function j(n, t) {
      for (var r, e = n + "", o = 0; o < e.length;) {
        t[h & o] = h & (r ^= 19 * t[h & o]) + e.charCodeAt(o++);
      }

      return S(t);
    }

    function S(n) {
      return String.fromCharCode.apply(0, n);
    }

    if (j(c.random(), a), "object" == (typeof module === "undefined" ? "undefined" : _typeof(module)) && module.exports) {
      module.exports = n;

      try {
        s = require("crypto");
      } catch (n) {}
    } else "function" == typeof define && define.amd ? define(function () {
      return n;
    }) : c["seed" + p] = n;
  }("undefined" != typeof self ? self : undefined, [], Math);

  /**
   * Compute the intersection between two lines.
   * @static
   * @method lineInt
   * @param  {Array}  l1          Line vector 1
   * @param  {Array}  l2          Line vector 2
   * @param  {Number} precision   Precision to use when checking if the lines are parallel
   * @return {Array}              The intersection point.
   */
  function lineInt(l1, l2, precision) {
    precision = precision || 0;
    var i = [0, 0]; // point

    var a1, b1, c1, a2, b2, c2, det; // scalars

    a1 = l1[1][1] - l1[0][1];
    b1 = l1[0][0] - l1[1][0];
    c1 = a1 * l1[0][0] + b1 * l1[0][1];
    a2 = l2[1][1] - l2[0][1];
    b2 = l2[0][0] - l2[1][0];
    c2 = a2 * l2[0][0] + b2 * l2[0][1];
    det = a1 * b2 - a2 * b1;

    if (!scalar_eq(det, 0, precision)) {
      // lines are not parallel
      i[0] = (b2 * c1 - b1 * c2) / det;
      i[1] = (a1 * c2 - a2 * c1) / det;
    }

    return i;
  }
  /**
   * Checks if two line segments intersects.
   * @method segmentsIntersect
   * @param {Array} p1 The start vertex of the first line segment.
   * @param {Array} p2 The end vertex of the first line segment.
   * @param {Array} q1 The start vertex of the second line segment.
   * @param {Array} q2 The end vertex of the second line segment.
   * @return {Boolean} True if the two line segments intersect
   */


  function lineSegmentsIntersect(p1, p2, q1, q2) {
    var dx = p2[0] - p1[0];
    var dy = p2[1] - p1[1];
    var da = q2[0] - q1[0];
    var db = q2[1] - q1[1]; // segments are parallel

    if (da * dy - db * dx === 0) {
      return false;
    }

    var s = (dx * (q1[1] - p1[1]) + dy * (p1[0] - q1[0])) / (da * dy - db * dx);
    var t = (da * (p1[1] - q1[1]) + db * (q1[0] - p1[0])) / (db * dx - da * dy);
    return s >= 0 && s <= 1 && t >= 0 && t <= 1;
  }
  /**
   * Get the area of a triangle spanned by the three given points. Note that the area will be negative if the points are not given in counter-clockwise order.
   * @static
   * @method area
   * @param  {Array} a
   * @param  {Array} b
   * @param  {Array} c
   * @return {Number}
   */


  function triangleArea(a, b, c) {
    return (b[0] - a[0]) * (c[1] - a[1]) - (c[0] - a[0]) * (b[1] - a[1]);
  }

  function isLeft(a, b, c) {
    return triangleArea(a, b, c) > 0;
  }

  function isLeftOn(a, b, c) {
    return triangleArea(a, b, c) >= 0;
  }

  function isRight(a, b, c) {
    return triangleArea(a, b, c) < 0;
  }

  function isRightOn(a, b, c) {
    return triangleArea(a, b, c) <= 0;
  }

  var tmpPoint1 = [],
      tmpPoint2 = [];
  /**
   * Check if three points are collinear
   * @method collinear
   * @param  {Array} a
   * @param  {Array} b
   * @param  {Array} c
   * @param  {Number} [thresholdAngle=0] Threshold angle to use when comparing the vectors. The function will return true if the angle between the resulting vectors is less than this value. Use zero for max precision.
   * @return {Boolean}
   */

  function collinear(a, b, c, thresholdAngle) {
    if (!thresholdAngle) {
      return triangleArea(a, b, c) === 0;
    } else {
      var ab = tmpPoint1,
          bc = tmpPoint2;
      ab[0] = b[0] - a[0];
      ab[1] = b[1] - a[1];
      bc[0] = c[0] - b[0];
      bc[1] = c[1] - b[1];
      var dot = ab[0] * bc[0] + ab[1] * bc[1],
          magA = Math.sqrt(ab[0] * ab[0] + ab[1] * ab[1]),
          magB = Math.sqrt(bc[0] * bc[0] + bc[1] * bc[1]),
          angle = Math.acos(dot / (magA * magB));
      return angle < thresholdAngle;
    }
  }

  function sqdist(a, b) {
    var dx = b[0] - a[0];
    var dy = b[1] - a[1];
    return dx * dx + dy * dy;
  }
  /**
   * Get a vertex at position i. It does not matter if i is out of bounds, this function will just cycle.
   * @method at
   * @param  {Number} i
   * @return {Array}
   */


  function polygonAt(polygon, i) {
    var s = polygon.length;
    return polygon[i < 0 ? i % s + s : i % s];
  }
  /**
   * Clear the polygon data
   * @method clear
   * @return {Array}
   */


  function polygonClear(polygon) {
    polygon.length = 0;
  }
  /**
   * Append points "from" to "to"-1 from an other polygon "poly" onto this one.
   * @method append
   * @param {Polygon} poly The polygon to get points from.
   * @param {Number}  from The vertex index in "poly".
   * @param {Number}  to The end vertex index in "poly". Note that this vertex is NOT included when appending.
   * @return {Array}
   */


  function polygonAppend(polygon, poly, from, to) {
    for (var i = from; i < to; i++) {
      polygon.push(poly[i]);
    }
  }
  /**
   * Make sure that the polygon vertices are ordered counter-clockwise.
   * @method makeCCW
   */


  function polygonMakeCCW(polygon) {
    var br = 0,
        v = polygon; // find bottom right point

    for (var i = 1; i < polygon.length; ++i) {
      if (v[i][1] < v[br][1] || v[i][1] === v[br][1] && v[i][0] > v[br][0]) {
        br = i;
      }
    } // reverse poly if clockwise


    if (!isLeft(polygonAt(polygon, br - 1), polygonAt(polygon, br), polygonAt(polygon, br + 1))) {
      polygonReverse(polygon);
      return true;
    } else {
      return false;
    }
  }
  /**
   * Reverse the vertices in the polygon
   * @method reverse
   */


  function polygonReverse(polygon) {
    var tmp = [];
    var N = polygon.length;

    for (var i = 0; i !== N; i++) {
      tmp.push(polygon.pop());
    }

    for (var i = 0; i !== N; i++) {
      polygon[i] = tmp[i];
    }
  }
  /**
   * Check if a point in the polygon is a reflex point
   * @method isReflex
   * @param  {Number}  i
   * @return {Boolean}
   */


  function polygonIsReflex(polygon, i) {
    return isRight(polygonAt(polygon, i - 1), polygonAt(polygon, i), polygonAt(polygon, i + 1));
  }

  var tmpLine1 = [],
      tmpLine2 = [];
  /**
   * Check if two vertices in the polygon can see each other
   * @method canSee
   * @param  {Number} a Vertex index 1
   * @param  {Number} b Vertex index 2
   * @return {Boolean}
   */

  function polygonCanSee(polygon, a, b) {
    var p,
        dist,
        l1 = tmpLine1,
        l2 = tmpLine2;

    if (isLeftOn(polygonAt(polygon, a + 1), polygonAt(polygon, a), polygonAt(polygon, b)) && isRightOn(polygonAt(polygon, a - 1), polygonAt(polygon, a), polygonAt(polygon, b))) {
      return false;
    }

    dist = sqdist(polygonAt(polygon, a), polygonAt(polygon, b));

    for (var i = 0; i !== polygon.length; ++i) {
      // for each edge
      if ((i + 1) % polygon.length === a || i === a) {
        // ignore incident edges
        continue;
      }

      if (isLeftOn(polygonAt(polygon, a), polygonAt(polygon, b), polygonAt(polygon, i + 1)) && isRightOn(polygonAt(polygon, a), polygonAt(polygon, b), polygonAt(polygon, i))) {
        // if diag intersects an edge
        l1[0] = polygonAt(polygon, a);
        l1[1] = polygonAt(polygon, b);
        l2[0] = polygonAt(polygon, i);
        l2[1] = polygonAt(polygon, i + 1);
        p = lineInt(l1, l2);

        if (sqdist(polygonAt(polygon, a), p) < dist) {
          // if edge is blocking visibility to b
          return false;
        }
      }
    }

    return true;
  }
  /**
   * Check if two vertices in the polygon can see each other
   * @method canSee2
   * @param  {Number} a Vertex index 1
   * @param  {Number} b Vertex index 2
   * @return {Boolean}
   */


  function polygonCanSee2(polygon, a, b) {
    // for each edge
    for (var i = 0; i !== polygon.length; ++i) {
      // ignore incident edges
      if (i === a || i === b || (i + 1) % polygon.length === a || (i + 1) % polygon.length === b) {
        continue;
      }

      if (lineSegmentsIntersect(polygonAt(polygon, a), polygonAt(polygon, b), polygonAt(polygon, i), polygonAt(polygon, i + 1))) {
        return false;
      }
    }

    return true;
  }
  /**
   * Copy the polygon from vertex i to vertex j.
   * @method copy
   * @param  {Number} i
   * @param  {Number} j
   * @param  {Polygon} [targetPoly]   Optional target polygon to save in.
   * @return {Polygon}                The resulting copy.
   */


  function polygonCopy(polygon, i, j, targetPoly) {
    var p = targetPoly || [];
    polygonClear(p);

    if (i < j) {
      // Insert all vertices from i to j
      for (var k = i; k <= j; k++) {
        p.push(polygon[k]);
      }
    } else {
      // Insert vertices 0 to j
      for (var k = 0; k <= j; k++) {
        p.push(polygon[k]);
      } // Insert vertices i to end


      for (var k = i; k < polygon.length; k++) {
        p.push(polygon[k]);
      }
    }

    return p;
  }
  /**
   * Decomposes the polygon into convex pieces. Returns a list of edges [[p1,p2],[p2,p3],...] that cuts the polygon.
   * Note that this algorithm has complexity O(N^4) and will be very slow for polygons with many vertices.
   * @method getCutEdges
   * @return {Array}
   */


  function polygonGetCutEdges(polygon) {
    var min = [],
        tmp1 = [],
        tmp2 = [],
        tmpPoly = [];
    var nDiags = Number.MAX_VALUE;

    for (var i = 0; i < polygon.length; ++i) {
      if (polygonIsReflex(polygon, i)) {
        for (var j = 0; j < polygon.length; ++j) {
          if (polygonCanSee(polygon, i, j)) {
            tmp1 = polygonGetCutEdges(polygonCopy(polygon, i, j, tmpPoly));
            tmp2 = polygonGetCutEdges(polygonCopy(polygon, j, i, tmpPoly));

            for (var k = 0; k < tmp2.length; k++) {
              tmp1.push(tmp2[k]);
            }

            if (tmp1.length < nDiags) {
              min = tmp1;
              nDiags = tmp1.length;
              min.push([polygonAt(polygon, i), polygonAt(polygon, j)]);
            }
          }
        }
      }
    }

    return min;
  }
  /**
   * Decomposes the polygon into one or more convex sub-Polygons.
   * @method decomp
   * @return {Array} An array or Polygon objects.
   */


  function polygonDecomp(polygon) {
    var edges = polygonGetCutEdges(polygon);

    if (edges.length > 0) {
      return polygonSlice(polygon, edges);
    } else {
      return [polygon];
    }
  }
  /**
   * Slices the polygon given one or more cut edges. If given one, this function will return two polygons (false on failure). If many, an array of polygons.
   * @method slice
   * @param {Array} cutEdges A list of edges, as returned by .getCutEdges()
   * @return {Array}
   */


  function polygonSlice(polygon, cutEdges) {
    if (cutEdges.length === 0) {
      return [polygon];
    }

    if (cutEdges instanceof Array && cutEdges.length && cutEdges[0] instanceof Array && cutEdges[0].length === 2 && cutEdges[0][0] instanceof Array) {
      var polys = [polygon];

      for (var i = 0; i < cutEdges.length; i++) {
        var cutEdge = cutEdges[i]; // Cut all polys

        for (var j = 0; j < polys.length; j++) {
          var poly = polys[j];
          var result = polygonSlice(poly, cutEdge);

          if (result) {
            // Found poly! Cut and quit
            polys.splice(j, 1);
            polys.push(result[0], result[1]);
            break;
          }
        }
      }

      return polys;
    } else {
      // Was given one edge
      var cutEdge = cutEdges;
      var i = polygon.indexOf(cutEdge[0]);
      var j = polygon.indexOf(cutEdge[1]);

      if (i !== -1 && j !== -1) {
        return [polygonCopy(polygon, i, j), polygonCopy(polygon, j, i)];
      } else {
        return false;
      }
    }
  }
  /**
   * Checks that the line segments of this polygon do not intersect each other.
   * @method isSimple
   * @param  {Array} path An array of vertices e.g. [[0,0],[0,1],...]
   * @return {Boolean}
   * @todo Should it check all segments with all others?
   */


  function polygonIsSimple(polygon) {
    var path = polygon,
        i; // Check

    for (i = 0; i < path.length - 1; i++) {
      for (var j = 0; j < i - 1; j++) {
        if (lineSegmentsIntersect(path[i], path[i + 1], path[j], path[j + 1])) {
          return false;
        }
      }
    } // Check the segment between the last and the first point to all others


    for (i = 1; i < path.length - 2; i++) {
      if (lineSegmentsIntersect(path[0], path[path.length - 1], path[i], path[i + 1])) {
        return false;
      }
    }

    return true;
  }

  function getIntersectionPoint(p1, p2, q1, q2, delta) {
    delta = delta || 0;
    var a1 = p2[1] - p1[1];
    var b1 = p1[0] - p2[0];
    var c1 = a1 * p1[0] + b1 * p1[1];
    var a2 = q2[1] - q1[1];
    var b2 = q1[0] - q2[0];
    var c2 = a2 * q1[0] + b2 * q1[1];
    var det = a1 * b2 - a2 * b1;

    if (!scalar_eq(det, 0, delta)) {
      return [(b2 * c1 - b1 * c2) / det, (a1 * c2 - a2 * c1) / det];
    } else {
      return [0, 0];
    }
  }
  /**
   * Quickly decompose the Polygon into convex sub-polygons.
   * @method quickDecomp
   * @param  {Array} result
   * @param  {Array} [reflexVertices]
   * @param  {Array} [steinerPoints]
   * @param  {Number} [delta]
   * @param  {Number} [maxlevel]
   * @param  {Number} [level]
   * @return {Array}
   */


  function polygonQuickDecomp(polygon, result, reflexVertices, steinerPoints, delta, maxlevel, level) {
    maxlevel = maxlevel || 100;
    level = level || 0;
    delta = delta || 25;
    result = typeof result !== "undefined" ? result : [];
    reflexVertices = reflexVertices || [];
    steinerPoints = steinerPoints || [];
    var upperInt = [0, 0],
        lowerInt = [0, 0],
        p = [0, 0]; // Points

    var upperDist = 0,
        lowerDist = 0,
        d = 0,
        closestDist = 0; // scalars

    var upperIndex = 0,
        lowerIndex = 0,
        closestIndex = 0; // Integers

    var lowerPoly = [],
        upperPoly = []; // polygons

    var poly = polygon,
        v = polygon;

    if (v.length < 3) {
      return result;
    }

    level++;

    if (level > maxlevel) {
      console.warn("quickDecomp: max level (" + maxlevel + ") reached.");
      return result;
    }

    for (var i = 0; i < polygon.length; ++i) {
      if (polygonIsReflex(poly, i)) {
        reflexVertices.push(poly[i]);
        upperDist = lowerDist = Number.MAX_VALUE;

        for (var j = 0; j < polygon.length; ++j) {
          if (isLeft(polygonAt(poly, i - 1), polygonAt(poly, i), polygonAt(poly, j)) && isRightOn(polygonAt(poly, i - 1), polygonAt(poly, i), polygonAt(poly, j - 1))) {
            // if line intersects with an edge
            p = getIntersectionPoint(polygonAt(poly, i - 1), polygonAt(poly, i), polygonAt(poly, j), polygonAt(poly, j - 1)); // find the point of intersection

            if (isRight(polygonAt(poly, i + 1), polygonAt(poly, i), p)) {
              // make sure it's inside the poly
              d = sqdist(poly[i], p);

              if (d < lowerDist) {
                // keep only the closest intersection
                lowerDist = d;
                lowerInt = p;
                lowerIndex = j;
              }
            }
          }

          if (isLeft(polygonAt(poly, i + 1), polygonAt(poly, i), polygonAt(poly, j + 1)) && isRightOn(polygonAt(poly, i + 1), polygonAt(poly, i), polygonAt(poly, j))) {
            p = getIntersectionPoint(polygonAt(poly, i + 1), polygonAt(poly, i), polygonAt(poly, j), polygonAt(poly, j + 1));

            if (isLeft(polygonAt(poly, i - 1), polygonAt(poly, i), p)) {
              d = sqdist(poly[i], p);

              if (d < upperDist) {
                upperDist = d;
                upperInt = p;
                upperIndex = j;
              }
            }
          }
        } // if there are no vertices to connect to, choose a point in the middle


        if (lowerIndex === (upperIndex + 1) % polygon.length) {
          //console.log("Case 1: Vertex("+i+"), lowerIndex("+lowerIndex+"), upperIndex("+upperIndex+"), poly.size("+polygon.length+")");
          p[0] = (lowerInt[0] + upperInt[0]) / 2;
          p[1] = (lowerInt[1] + upperInt[1]) / 2;
          steinerPoints.push(p);

          if (i < upperIndex) {
            //lowerPoly.insert(lowerPoly.end(), poly.begin() + i, poly.begin() + upperIndex + 1);
            polygonAppend(lowerPoly, poly, i, upperIndex + 1);
            lowerPoly.push(p);
            upperPoly.push(p);

            if (lowerIndex !== 0) {
              //upperPoly.insert(upperPoly.end(), poly.begin() + lowerIndex, poly.end());
              polygonAppend(upperPoly, poly, lowerIndex, poly.length);
            } //upperPoly.insert(upperPoly.end(), poly.begin(), poly.begin() + i + 1);


            polygonAppend(upperPoly, poly, 0, i + 1);
          } else {
            if (i !== 0) {
              //lowerPoly.insert(lowerPoly.end(), poly.begin() + i, poly.end());
              polygonAppend(lowerPoly, poly, i, poly.length);
            } //lowerPoly.insert(lowerPoly.end(), poly.begin(), poly.begin() + upperIndex + 1);


            polygonAppend(lowerPoly, poly, 0, upperIndex + 1);
            lowerPoly.push(p);
            upperPoly.push(p); //upperPoly.insert(upperPoly.end(), poly.begin() + lowerIndex, poly.begin() + i + 1);

            polygonAppend(upperPoly, poly, lowerIndex, i + 1);
          }
        } else {
          // connect to the closest point within the triangle
          //console.log("Case 2: Vertex("+i+"), closestIndex("+closestIndex+"), poly.size("+polygon.length+")\n");
          if (lowerIndex > upperIndex) {
            upperIndex += polygon.length;
          }

          closestDist = Number.MAX_VALUE;

          if (upperIndex < lowerIndex) {
            return result;
          }

          for (var j = lowerIndex; j <= upperIndex; ++j) {
            if (isLeftOn(polygonAt(poly, i - 1), polygonAt(poly, i), polygonAt(poly, j)) && isRightOn(polygonAt(poly, i + 1), polygonAt(poly, i), polygonAt(poly, j))) {
              d = sqdist(polygonAt(poly, i), polygonAt(poly, j));

              if (d < closestDist && polygonCanSee2(poly, i, j)) {
                closestDist = d;
                closestIndex = j % polygon.length;
              }
            }
          }

          if (i < closestIndex) {
            polygonAppend(lowerPoly, poly, i, closestIndex + 1);

            if (closestIndex !== 0) {
              polygonAppend(upperPoly, poly, closestIndex, v.length);
            }

            polygonAppend(upperPoly, poly, 0, i + 1);
          } else {
            if (i !== 0) {
              polygonAppend(lowerPoly, poly, i, v.length);
            }

            polygonAppend(lowerPoly, poly, 0, closestIndex + 1);
            polygonAppend(upperPoly, poly, closestIndex, i + 1);
          }
        } // solve smallest poly first


        if (lowerPoly.length < upperPoly.length) {
          polygonQuickDecomp(lowerPoly, result, reflexVertices, steinerPoints, delta, maxlevel, level);
          polygonQuickDecomp(upperPoly, result, reflexVertices, steinerPoints, delta, maxlevel, level);
        } else {
          polygonQuickDecomp(upperPoly, result, reflexVertices, steinerPoints, delta, maxlevel, level);
          polygonQuickDecomp(lowerPoly, result, reflexVertices, steinerPoints, delta, maxlevel, level);
        }

        return result;
      }
    }

    result.push(polygon);
    return result;
  }
  /**
   * Remove collinear points in the polygon.
   * @method removeCollinearPoints
   * @param  {Number} [precision] The threshold angle to use when determining whether two edges are collinear. Use zero for finest precision.
   * @return {Number}           The number of points removed
   */


  function polygonRemoveCollinearPoints(polygon, precision) {
    var num = 0;

    for (var i = polygon.length - 1; polygon.length > 3 && i >= 0; --i) {
      if (collinear(polygonAt(polygon, i - 1), polygonAt(polygon, i), polygonAt(polygon, i + 1), precision)) {
        // Remove the middle point
        polygon.splice(i % polygon.length, 1);
        num++;
      }
    }

    return num;
  }
  /**
   * Remove duplicate points in the polygon.
   * @method removeDuplicatePoints
   * @param  {Number} [precision] The threshold to use when determining whether two points are the same. Use zero for best precision.
   */


  function polygonRemoveDuplicatePoints(polygon, precision) {
    for (var i = polygon.length - 1; i >= 1; --i) {
      var pi = polygon[i];

      for (var j = i - 1; j >= 0; --j) {
        if (points_eq(pi, polygon[j], precision)) {
          polygon.splice(i, 1);
          continue;
        }
      }
    }
  }
  /**
   * Check if two scalars are equal
   * @static
   * @method eq
   * @param  {Number} a
   * @param  {Number} b
   * @param  {Number} [precision]
   * @return {Boolean}
   */


  function scalar_eq(a, b, precision) {
    precision = precision || 0;
    return Math.abs(a - b) <= precision;
  }
  /**
   * Check if two points are equal
   * @static
   * @method points_eq
   * @param  {Array} a
   * @param  {Array} b
   * @param  {Number} [precision]
   * @return {Boolean}
   */


  function points_eq(a, b, precision) {
    return scalar_eq(a[0], b[0], precision) && scalar_eq(a[1], b[1], precision);
  }

  var decomp = {
    decomp: polygonDecomp,
    quickDecomp: polygonQuickDecomp,
    isSimple: polygonIsSimple,
    removeCollinearPoints: polygonRemoveCollinearPoints,
    removeDuplicatePoints: polygonRemoveDuplicatePoints,
    makeCCW: polygonMakeCCW
  };

  var ErrorConsole =
  /*#__PURE__*/
  function () {
    function ErrorConsole(_ref) {
      var _ref$elementId = _ref.elementId,
          elementId = _ref$elementId === void 0 ? null : _ref$elementId,
          _ref$alertOnError = _ref.alertOnError,
          alertOnError = _ref$alertOnError === void 0 ? false : _ref$alertOnError,
          _ref$ignoreMessages = _ref.ignoreMessages,
          ignoreMessages = _ref$ignoreMessages === void 0 ? [] : _ref$ignoreMessages;

      _classCallCheck(this, ErrorConsole);

      this.register();
      this.errors = [];
      this.ignoreMessages = ignoreMessages;
      this.alertOnError = alertOnError;

      if (elementId) {
        this.consoleElement = document.getElementById(elementId); // Assign style to element

        this.consoleElement.style.display = "none";
        this.consoleElement.style.position = "absolute";
        this.consoleElement.style.width = "100%";
        this.consoleElement.style.background = "rgba(0,0,0,0.8)";
        this.consoleElement.style.color = "#FFFFFF";
        this.consoleElement.style.fontFamily = "monospace";
        this.consoleElement.style.maxHeight = "256px";
        this.consoleElement.style.overflowY = "scroll";
        if (!this.consoleElement) console.warn("ElementID '".concat(elementId, "' not found while trying to register Error Console"));
      }
    }

    _createClass(ErrorConsole, [{
      key: "register",
      value: function register() {
        window.onerror = this.handleError.bind(this);
      } // Global Error Handling

    }, {
      key: "handleError",
      value: function handleError(msg, url, line, col, error) {
        if (!url && !line && !col) return; // Ignore false positives on iOS Firefox
        // Allow some messages to be ignored

        if (this.ignoreMessages.indexOf(msg.replace("Uncaught Error: ", "").replace("Error: ", "")) > -1) return; // console.error(msg, url, line, col, error);

        this.errors.push({
          msg: msg,
          url: url,
          line: line,
          col: col,
          error: error
        });
        if (this.alertOnError) alert(msg + "\n\n" + error);
        this.updateConsoleElement();
      } // Handles promises

    }, {
      key: "handleRejection",
      value: function handleRejection(event) {
        console.log(arguments);
        this.handleError.bind(this)('Unhandled rejection', '', '', '', event.reason);
      }
    }, {
      key: "hideConsole",
      value: function hideConsole() {
        this.consoleElement.display = "none";
      }
    }, {
      key: "showConsole",
      value: function showConsole() {
        this.consoleElement.display = "block";
        this.updateConsoleElement();
      }
    }, {
      key: "updateConsoleElement",
      value: function updateConsoleElement() {
        if (!this.consoleElement) return;
        this.consoleElement.innerHTML = '';
        if (this.errors.length) this.consoleElement.style.display = "";
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = this.errors[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var error = _step.value;
            this.consoleElement.innerHTML += "".concat(error.msg, " <br/>\n                                            &nbsp;&nbsp;&nbsp; in ").concat(error.url, " <br/>\n                                            &nbsp;&nbsp;&nbsp; at line ").concat(error.line, ", column ").concat(error.col, " </br>");
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator["return"] != null) {
              _iterator["return"]();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
      }
    }]);

    return ErrorConsole;
  }();

  var CONST = {
    AUTO_DETECT_DEVICE_PIXEL_RATIO: true,
    AUTO_DETECT_TEXTURE_COMPRESSION_AVAILABILITY: false,
    LIGHTING_ENABLED: true,
    DIRECTIONAL_SHADOWS_ENABLED: true,
    POINT_SHADOWS_ENABLED: false,
    SHADOWS_VSM_ENABLED: false,
    DEFAULT_SHADOW_BIAS: 0.00002,
    MAX_BONES: 8,
    MAX_LIGHTS: 4,
    AVAILABLE_EXTENSIONS: []
  };

  /* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files (the "Software"), to deal
  in the Software without restriction, including without limitation the rights
  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  copies of the Software, and to permit persons to whom the Software is
  furnished to do so, subject to the following conditions:

  The above copyright notice and this permission notice shall be included in
  all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
  THE SOFTWARE. */

  /**
   * Common utilities
   * @module glMatrix
   */
  // Configuration Constants
  var EPSILON = 0.000001;
  var ARRAY_TYPE = typeof Float32Array !== 'undefined' ? Float32Array : Array;

  /* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files (the "Software"), to deal
  in the Software without restriction, including without limitation the rights
  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  copies of the Software, and to permit persons to whom the Software is
  furnished to do so, subject to the following conditions:

  The above copyright notice and this permission notice shall be included in
  all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
  THE SOFTWARE. */
  /**
   * 3x3 Matrix
   * @module mat3
   */

  /**
   * Creates a new identity mat3
   *
   * @returns {mat3} a new 3x3 matrix
   */

  function create() {
    var out = new ARRAY_TYPE(9);
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 1;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 1;
    return out;
  }

  /* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files (the "Software"), to deal
  in the Software without restriction, including without limitation the rights
  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  copies of the Software, and to permit persons to whom the Software is
  furnished to do so, subject to the following conditions:

  The above copyright notice and this permission notice shall be included in
  all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
  THE SOFTWARE. */
  /**
   * @class 4x4 Matrix<br>Format: column-major, when typed out it looks like row-major<br>The matrices are being post multiplied.
   * @name mat4
   */

  /**
   * Creates a new identity mat4
   *
   * @returns {mat4} a new 4x4 matrix
   */

  function create$1() {
    var out = new ARRAY_TYPE(16);
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
  }
  /**
   * Copy the values from one mat4 to another
   *
   * @param {mat4} out the receiving matrix
   * @param {mat4} a the source matrix
   * @returns {mat4} out
   */

  function copy(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
  }
  /**
   * Set a mat4 to the identity matrix
   *
   * @param {mat4} out the receiving matrix
   * @returns {mat4} out
   */

  function identity(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
  }
  /**
   * Transpose the values of a mat4
   *
   * @param {mat4} out the receiving matrix
   * @param {mat4} a the source matrix
   * @returns {mat4} out
   */

  function transpose(out, a) {
    // If we are transposing ourselves we can skip a few steps but have to cache some values
    if (out === a) {
      var a01 = a[1],
          a02 = a[2],
          a03 = a[3];
      var a12 = a[6],
          a13 = a[7];
      var a23 = a[11];
      out[1] = a[4];
      out[2] = a[8];
      out[3] = a[12];
      out[4] = a01;
      out[6] = a[9];
      out[7] = a[13];
      out[8] = a02;
      out[9] = a12;
      out[11] = a[14];
      out[12] = a03;
      out[13] = a13;
      out[14] = a23;
    } else {
      out[0] = a[0];
      out[1] = a[4];
      out[2] = a[8];
      out[3] = a[12];
      out[4] = a[1];
      out[5] = a[5];
      out[6] = a[9];
      out[7] = a[13];
      out[8] = a[2];
      out[9] = a[6];
      out[10] = a[10];
      out[11] = a[14];
      out[12] = a[3];
      out[13] = a[7];
      out[14] = a[11];
      out[15] = a[15];
    }

    return out;
  }
  /**
   * Inverts a mat4
   *
   * @param {mat4} out the receiving matrix
   * @param {mat4} a the source matrix
   * @returns {mat4} out
   */

  function invert(out, a) {
    var a00 = a[0],
        a01 = a[1],
        a02 = a[2],
        a03 = a[3];
    var a10 = a[4],
        a11 = a[5],
        a12 = a[6],
        a13 = a[7];
    var a20 = a[8],
        a21 = a[9],
        a22 = a[10],
        a23 = a[11];
    var a30 = a[12],
        a31 = a[13],
        a32 = a[14],
        a33 = a[15];
    var b00 = a00 * a11 - a01 * a10;
    var b01 = a00 * a12 - a02 * a10;
    var b02 = a00 * a13 - a03 * a10;
    var b03 = a01 * a12 - a02 * a11;
    var b04 = a01 * a13 - a03 * a11;
    var b05 = a02 * a13 - a03 * a12;
    var b06 = a20 * a31 - a21 * a30;
    var b07 = a20 * a32 - a22 * a30;
    var b08 = a20 * a33 - a23 * a30;
    var b09 = a21 * a32 - a22 * a31;
    var b10 = a21 * a33 - a23 * a31;
    var b11 = a22 * a33 - a23 * a32; // Calculate the determinant

    var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

    if (!det) {
      return null;
    }

    det = 1.0 / det;
    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
    out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
    out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
    out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
    out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
    out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
    out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
    out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
    out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
    out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
    out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
    out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
    out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
    out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
    out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
    out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
    return out;
  }
  /**
   * Multiplies two mat4s
   *
   * @param {mat4} out the receiving matrix
   * @param {mat4} a the first operand
   * @param {mat4} b the second operand
   * @returns {mat4} out
   */

  function multiply(out, a, b) {
    var a00 = a[0],
        a01 = a[1],
        a02 = a[2],
        a03 = a[3];
    var a10 = a[4],
        a11 = a[5],
        a12 = a[6],
        a13 = a[7];
    var a20 = a[8],
        a21 = a[9],
        a22 = a[10],
        a23 = a[11];
    var a30 = a[12],
        a31 = a[13],
        a32 = a[14],
        a33 = a[15]; // Cache only the current line of the second matrix

    var b0 = b[0],
        b1 = b[1],
        b2 = b[2],
        b3 = b[3];
    out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    b0 = b[4];
    b1 = b[5];
    b2 = b[6];
    b3 = b[7];
    out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    b0 = b[8];
    b1 = b[9];
    b2 = b[10];
    b3 = b[11];
    out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    b0 = b[12];
    b1 = b[13];
    b2 = b[14];
    b3 = b[15];
    out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    return out;
  }
  /**
   * Returns the translation vector component of a transformation
   *  matrix. If a matrix is built with fromRotationTranslation,
   *  the returned vector will be the same as the translation vector
   *  originally supplied.
   * @param  {vec3} out Vector to receive translation component
   * @param  {mat4} mat Matrix to be decomposed (input)
   * @return {vec3} out
   */

  function getTranslation(out, mat) {
    out[0] = mat[12];
    out[1] = mat[13];
    out[2] = mat[14];
    return out;
  }
  /**
   * Returns the scaling factor component of a transformation
   *  matrix. If a matrix is built with fromRotationTranslationScale
   *  with a normalized Quaternion paramter, the returned vector will be
   *  the same as the scaling vector
   *  originally supplied.
   * @param  {vec3} out Vector to receive scaling factor component
   * @param  {mat4} mat Matrix to be decomposed (input)
   * @return {vec3} out
   */

  function getScaling(out, mat) {
    var m11 = mat[0];
    var m12 = mat[1];
    var m13 = mat[2];
    var m21 = mat[4];
    var m22 = mat[5];
    var m23 = mat[6];
    var m31 = mat[8];
    var m32 = mat[9];
    var m33 = mat[10];
    out[0] = Math.sqrt(m11 * m11 + m12 * m12 + m13 * m13);
    out[1] = Math.sqrt(m21 * m21 + m22 * m22 + m23 * m23);
    out[2] = Math.sqrt(m31 * m31 + m32 * m32 + m33 * m33);
    return out;
  }
  /**
   * Returns a quaternion representing the rotational component
   *  of a transformation matrix. If a matrix is built with
   *  fromRotationTranslation, the returned quaternion will be the
   *  same as the quaternion originally supplied.
   * @param {quat} out Quaternion to receive the rotation component
   * @param {mat4} mat Matrix to be decomposed (input)
   * @return {quat} out
   */

  function getRotation(out, mat) {
    // Algorithm taken from http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm
    var trace = mat[0] + mat[5] + mat[10];
    var S = 0;

    if (trace > 0) {
      S = Math.sqrt(trace + 1.0) * 2;
      out[3] = 0.25 * S;
      out[0] = (mat[6] - mat[9]) / S;
      out[1] = (mat[8] - mat[2]) / S;
      out[2] = (mat[1] - mat[4]) / S;
    } else if (mat[0] > mat[5] && mat[0] > mat[10]) {
      S = Math.sqrt(1.0 + mat[0] - mat[5] - mat[10]) * 2;
      out[3] = (mat[6] - mat[9]) / S;
      out[0] = 0.25 * S;
      out[1] = (mat[1] + mat[4]) / S;
      out[2] = (mat[8] + mat[2]) / S;
    } else if (mat[5] > mat[10]) {
      S = Math.sqrt(1.0 + mat[5] - mat[0] - mat[10]) * 2;
      out[3] = (mat[8] - mat[2]) / S;
      out[0] = (mat[1] + mat[4]) / S;
      out[1] = 0.25 * S;
      out[2] = (mat[6] + mat[9]) / S;
    } else {
      S = Math.sqrt(1.0 + mat[10] - mat[0] - mat[5]) * 2;
      out[3] = (mat[1] - mat[4]) / S;
      out[0] = (mat[8] + mat[2]) / S;
      out[1] = (mat[6] + mat[9]) / S;
      out[2] = 0.25 * S;
    }

    return out;
  }
  /**
   * Creates a matrix from a quaternion rotation, vector translation and vector scale
   * This is equivalent to (but much faster than):
   *
   *     mat4.identity(dest);
   *     mat4.translate(dest, vec);
   *     let quatMat = mat4.create();
   *     quat4.toMat4(quat, quatMat);
   *     mat4.multiply(dest, quatMat);
   *     mat4.scale(dest, scale)
   *
   * @param {mat4} out mat4 receiving operation result
   * @param {quat4} q Rotation quaternion
   * @param {vec3} v Translation vector
   * @param {vec3} s Scaling vector
   * @returns {mat4} out
   */

  function fromRotationTranslationScale(out, q, v, s) {
    // Quaternion math
    var x = q[0],
        y = q[1],
        z = q[2],
        w = q[3];
    var x2 = x + x;
    var y2 = y + y;
    var z2 = z + z;
    var xx = x * x2;
    var xy = x * y2;
    var xz = x * z2;
    var yy = y * y2;
    var yz = y * z2;
    var zz = z * z2;
    var wx = w * x2;
    var wy = w * y2;
    var wz = w * z2;
    var sx = s[0];
    var sy = s[1];
    var sz = s[2];
    out[0] = (1 - (yy + zz)) * sx;
    out[1] = (xy + wz) * sx;
    out[2] = (xz - wy) * sx;
    out[3] = 0;
    out[4] = (xy - wz) * sy;
    out[5] = (1 - (xx + zz)) * sy;
    out[6] = (yz + wx) * sy;
    out[7] = 0;
    out[8] = (xz + wy) * sz;
    out[9] = (yz - wx) * sz;
    out[10] = (1 - (xx + yy)) * sz;
    out[11] = 0;
    out[12] = v[0];
    out[13] = v[1];
    out[14] = v[2];
    out[15] = 1;
    return out;
  }
  /**
   * Generates a perspective projection matrix with the given bounds
   *
   * @param {mat4} out mat4 frustum matrix will be written into
   * @param {number} fovy Vertical field of view in radians
   * @param {number} aspect Aspect ratio. typically viewport width/height
   * @param {number} near Near bound of the frustum
   * @param {number} far Far bound of the frustum
   * @returns {mat4} out
   */

  function perspective(out, fovy, aspect, near, far) {
    var f = 1.0 / Math.tan(fovy / 2);
    var nf = 1 / (near - far);
    out[0] = f / aspect;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = f;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = (far + near) * nf;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[14] = 2 * far * near * nf;
    out[15] = 0;
    return out;
  }
  /**
   * Generates a orthogonal projection matrix with the given bounds
   *
   * @param {mat4} out mat4 frustum matrix will be written into
   * @param {number} left Left bound of the frustum
   * @param {number} right Right bound of the frustum
   * @param {number} bottom Bottom bound of the frustum
   * @param {number} top Top bound of the frustum
   * @param {number} near Near bound of the frustum
   * @param {number} far Far bound of the frustum
   * @returns {mat4} out
   */

  function ortho(out, left, right, bottom, top, near, far) {
    var lr = 1 / (left - right);
    var bt = 1 / (bottom - top);
    var nf = 1 / (near - far);
    out[0] = -2 * lr;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = -2 * bt;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 2 * nf;
    out[11] = 0;
    out[12] = (left + right) * lr;
    out[13] = (top + bottom) * bt;
    out[14] = (far + near) * nf;
    out[15] = 1;
    return out;
  }
  /**
   * Generates a look-at matrix with the given eye position, focal point, and up axis. 
   * If you want a matrix that actually makes an object look at another object, you should use targetTo instead.
   *
   * @param {mat4} out mat4 frustum matrix will be written into
   * @param {vec3} eye Position of the viewer
   * @param {vec3} center Point the viewer is looking at
   * @param {vec3} up vec3 pointing up
   * @returns {mat4} out
   */

  function lookAt(out, eye, center, up) {
    var x0, x1, x2, y0, y1, y2, z0, z1, z2, len;
    var eyex = eye[0];
    var eyey = eye[1];
    var eyez = eye[2];
    var upx = up[0];
    var upy = up[1];
    var upz = up[2];
    var centerx = center[0];
    var centery = center[1];
    var centerz = center[2];

    if (Math.abs(eyex - centerx) < EPSILON && Math.abs(eyey - centery) < EPSILON && Math.abs(eyez - centerz) < EPSILON) {
      return identity(out);
    }

    z0 = eyex - centerx;
    z1 = eyey - centery;
    z2 = eyez - centerz;
    len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
    z0 *= len;
    z1 *= len;
    z2 *= len;
    x0 = upy * z2 - upz * z1;
    x1 = upz * z0 - upx * z2;
    x2 = upx * z1 - upy * z0;
    len = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);

    if (!len) {
      x0 = 0;
      x1 = 0;
      x2 = 0;
    } else {
      len = 1 / len;
      x0 *= len;
      x1 *= len;
      x2 *= len;
    }

    y0 = z1 * x2 - z2 * x1;
    y1 = z2 * x0 - z0 * x2;
    y2 = z0 * x1 - z1 * x0;
    len = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);

    if (!len) {
      y0 = 0;
      y1 = 0;
      y2 = 0;
    } else {
      len = 1 / len;
      y0 *= len;
      y1 *= len;
      y2 *= len;
    }

    out[0] = x0;
    out[1] = y0;
    out[2] = z0;
    out[3] = 0;
    out[4] = x1;
    out[5] = y1;
    out[6] = z1;
    out[7] = 0;
    out[8] = x2;
    out[9] = y2;
    out[10] = z2;
    out[11] = 0;
    out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
    out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
    out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
    out[15] = 1;
    return out;
  }
  /**
   * Generates a matrix that makes something look at something else.
   *
   * @param {mat4} out mat4 frustum matrix will be written into
   * @param {vec3} eye Position of the viewer
   * @param {vec3} center Point the viewer is looking at
   * @param {vec3} up vec3 pointing up
   * @returns {mat4} out
   */

  function targetTo(out, eye, target, up) {
    var eyex = eye[0],
        eyey = eye[1],
        eyez = eye[2],
        upx = up[0],
        upy = up[1],
        upz = up[2];
    var z0 = eyex - target[0],
        z1 = eyey - target[1],
        z2 = eyez - target[2];
    var len = z0 * z0 + z1 * z1 + z2 * z2;

    if (len > 0) {
      len = 1 / Math.sqrt(len);
      z0 *= len;
      z1 *= len;
      z2 *= len;
    }

    var x0 = upy * z2 - upz * z1,
        x1 = upz * z0 - upx * z2,
        x2 = upx * z1 - upy * z0;
    len = x0 * x0 + x1 * x1 + x2 * x2;

    if (len > 0) {
      len = 1 / Math.sqrt(len);
      x0 *= len;
      x1 *= len;
      x2 *= len;
    }

    out[0] = x0;
    out[1] = x1;
    out[2] = x2;
    out[3] = 0;
    out[4] = z1 * x2 - z2 * x1;
    out[5] = z2 * x0 - z0 * x2;
    out[6] = z0 * x1 - z1 * x0;
    out[7] = 0;
    out[8] = z0;
    out[9] = z1;
    out[10] = z2;
    out[11] = 0;
    out[12] = eyex;
    out[13] = eyey;
    out[14] = eyez;
    out[15] = 1;
    return out;
  }
  /**
   * Alias for {@link mat4.multiply}
   * @function
   */

  var mul = multiply;

  /* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files (the "Software"), to deal
  in the Software without restriction, including without limitation the rights
  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  copies of the Software, and to permit persons to whom the Software is
  furnished to do so, subject to the following conditions:

  The above copyright notice and this permission notice shall be included in
  all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
  THE SOFTWARE. */
  /**
   * 3 Dimensional Vector
   * @module vec3
   */

  /**
   * Creates a new, empty vec3
   *
   * @returns {vec3} a new 3D vector
   */

  function create$2() {
    var out = new ARRAY_TYPE(3);
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    return out;
  }
  /**
   * Calculates the length of a vec3
   *
   * @param {vec3} a vector to calculate length of
   * @returns {Number} length of a
   */

  function length(a) {
    var x = a[0];
    var y = a[1];
    var z = a[2];
    return Math.sqrt(x * x + y * y + z * z);
  }
  /**
   * Creates a new vec3 initialized with the given values
   *
   * @param {Number} x X component
   * @param {Number} y Y component
   * @param {Number} z Z component
   * @returns {vec3} a new 3D vector
   */

  function fromValues(x, y, z) {
    var out = new ARRAY_TYPE(3);
    out[0] = x;
    out[1] = y;
    out[2] = z;
    return out;
  }
  /**
   * Normalize a vec3
   *
   * @param {vec3} out the receiving vector
   * @param {vec3} a vector to normalize
   * @returns {vec3} out
   */

  function normalize(out, a) {
    var x = a[0];
    var y = a[1];
    var z = a[2];
    var len = x * x + y * y + z * z;

    if (len > 0) {
      //TODO: evaluate use of glm_invsqrt here?
      len = 1 / Math.sqrt(len);
      out[0] = a[0] * len;
      out[1] = a[1] * len;
      out[2] = a[2] * len;
    }

    return out;
  }
  /**
   * Calculates the dot product of two vec3's
   *
   * @param {vec3} a the first operand
   * @param {vec3} b the second operand
   * @returns {Number} dot product of a and b
   */

  function dot(a, b) {
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
  }
  /**
   * Computes the cross product of two vec3's
   *
   * @param {vec3} out the receiving vector
   * @param {vec3} a the first operand
   * @param {vec3} b the second operand
   * @returns {vec3} out
   */

  function cross(out, a, b) {
    var ax = a[0],
        ay = a[1],
        az = a[2];
    var bx = b[0],
        by = b[1],
        bz = b[2];
    out[0] = ay * bz - az * by;
    out[1] = az * bx - ax * bz;
    out[2] = ax * by - ay * bx;
    return out;
  }
  /**
   * Rotate a 3D vector around the x-axis
   * @param {vec3} out The receiving vec3
   * @param {vec3} a The vec3 point to rotate
   * @param {vec3} b The origin of the rotation
   * @param {Number} c The angle of rotation
   * @returns {vec3} out
   */

  function rotateX(out, a, b, c) {
    var p = [],
        r = []; //Translate point to the origin

    p[0] = a[0] - b[0];
    p[1] = a[1] - b[1];
    p[2] = a[2] - b[2]; //perform rotation

    r[0] = p[0];
    r[1] = p[1] * Math.cos(c) - p[2] * Math.sin(c);
    r[2] = p[1] * Math.sin(c) + p[2] * Math.cos(c); //translate to correct position

    out[0] = r[0] + b[0];
    out[1] = r[1] + b[1];
    out[2] = r[2] + b[2];
    return out;
  }
  /**
   * Rotate a 3D vector around the y-axis
   * @param {vec3} out The receiving vec3
   * @param {vec3} a The vec3 point to rotate
   * @param {vec3} b The origin of the rotation
   * @param {Number} c The angle of rotation
   * @returns {vec3} out
   */

  function rotateY(out, a, b, c) {
    var p = [],
        r = []; //Translate point to the origin

    p[0] = a[0] - b[0];
    p[1] = a[1] - b[1];
    p[2] = a[2] - b[2]; //perform rotation

    r[0] = p[2] * Math.sin(c) + p[0] * Math.cos(c);
    r[1] = p[1];
    r[2] = p[2] * Math.cos(c) - p[0] * Math.sin(c); //translate to correct position

    out[0] = r[0] + b[0];
    out[1] = r[1] + b[1];
    out[2] = r[2] + b[2];
    return out;
  }
  /**
   * Rotate a 3D vector around the z-axis
   * @param {vec3} out The receiving vec3
   * @param {vec3} a The vec3 point to rotate
   * @param {vec3} b The origin of the rotation
   * @param {Number} c The angle of rotation
   * @returns {vec3} out
   */

  function rotateZ(out, a, b, c) {
    var p = [],
        r = []; //Translate point to the origin

    p[0] = a[0] - b[0];
    p[1] = a[1] - b[1];
    p[2] = a[2] - b[2]; //perform rotation

    r[0] = p[0] * Math.cos(c) - p[1] * Math.sin(c);
    r[1] = p[0] * Math.sin(c) + p[1] * Math.cos(c);
    r[2] = p[2]; //translate to correct position

    out[0] = r[0] + b[0];
    out[1] = r[1] + b[1];
    out[2] = r[2] + b[2];
    return out;
  }
  /**
   * Alias for {@link vec3.length}
   * @function
   */

  var len = length;
  /**
   * Perform some operation over an array of vec3s.
   *
   * @param {Array} a the array of vectors to iterate over
   * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed
   * @param {Number} offset Number of elements to skip at the beginning of the array
   * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array
   * @param {Function} fn Function to call for each vector in the array
   * @param {Object} [arg] additional argument to pass to fn
   * @returns {Array} a
   * @function
   */

  var forEach = function () {
    var vec = create$2();
    return function (a, stride, offset, count, fn, arg) {
      var i, l;

      if (!stride) {
        stride = 3;
      }

      if (!offset) {
        offset = 0;
      }

      if (count) {
        l = Math.min(count * stride + offset, a.length);
      } else {
        l = a.length;
      }

      for (i = offset; i < l; i += stride) {
        vec[0] = a[i];
        vec[1] = a[i + 1];
        vec[2] = a[i + 2];
        fn(vec, vec, arg);
        a[i] = vec[0];
        a[i + 1] = vec[1];
        a[i + 2] = vec[2];
      }

      return a;
    };
  }();

  /* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files (the "Software"), to deal
  in the Software without restriction, including without limitation the rights
  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  copies of the Software, and to permit persons to whom the Software is
  furnished to do so, subject to the following conditions:

  The above copyright notice and this permission notice shall be included in
  all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
  THE SOFTWARE. */
  /**
   * 4 Dimensional Vector
   * @module vec4
   */

  /**
   * Creates a new, empty vec4
   *
   * @returns {vec4} a new 4D vector
   */

  function create$3() {
    var out = new ARRAY_TYPE(4);
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    return out;
  }
  /**
   * Normalize a vec4
   *
   * @param {vec4} out the receiving vector
   * @param {vec4} a vector to normalize
   * @returns {vec4} out
   */

  function normalize$1(out, a) {
    var x = a[0];
    var y = a[1];
    var z = a[2];
    var w = a[3];
    var len = x * x + y * y + z * z + w * w;

    if (len > 0) {
      len = 1 / Math.sqrt(len);
      out[0] = x * len;
      out[1] = y * len;
      out[2] = z * len;
      out[3] = w * len;
    }

    return out;
  }
  /**
   * Transforms the vec4 with a mat4.
   *
   * @param {vec4} out the receiving vector
   * @param {vec4} a the vector to transform
   * @param {mat4} m matrix to transform with
   * @returns {vec4} out
   */

  function transformMat4(out, a, m) {
    var x = a[0],
        y = a[1],
        z = a[2],
        w = a[3];
    out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;
    out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;
    out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;
    out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;
    return out;
  }
  /**
   * Perform some operation over an array of vec4s.
   *
   * @param {Array} a the array of vectors to iterate over
   * @param {Number} stride Number of elements between the start of each vec4. If 0 assumes tightly packed
   * @param {Number} offset Number of elements to skip at the beginning of the array
   * @param {Number} count Number of vec4s to iterate over. If 0 iterates over entire array
   * @param {Function} fn Function to call for each vector in the array
   * @param {Object} [arg] additional argument to pass to fn
   * @returns {Array} a
   * @function
   */

  var forEach$1 = function () {
    var vec = create$3();
    return function (a, stride, offset, count, fn, arg) {
      var i, l;

      if (!stride) {
        stride = 4;
      }

      if (!offset) {
        offset = 0;
      }

      if (count) {
        l = Math.min(count * stride + offset, a.length);
      } else {
        l = a.length;
      }

      for (i = offset; i < l; i += stride) {
        vec[0] = a[i];
        vec[1] = a[i + 1];
        vec[2] = a[i + 2];
        vec[3] = a[i + 3];
        fn(vec, vec, arg);
        a[i] = vec[0];
        a[i + 1] = vec[1];
        a[i + 2] = vec[2];
        a[i + 3] = vec[3];
      }

      return a;
    };
  }();

  /* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files (the "Software"), to deal
  in the Software without restriction, including without limitation the rights
  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  copies of the Software, and to permit persons to whom the Software is
  furnished to do so, subject to the following conditions:

  The above copyright notice and this permission notice shall be included in
  all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
  THE SOFTWARE. */
  /**
   * Quaternion
   * @module quat
   */

  /**
   * Creates a new identity quat
   *
   * @returns {quat} a new quaternion
   */

  function create$4() {
    var out = new ARRAY_TYPE(4);
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    return out;
  }
  /**
   * Sets a quat from the given angle and rotation axis,
   * then returns it.
   *
   * @param {quat} out the receiving quaternion
   * @param {vec3} axis the axis around which to rotate
   * @param {Number} rad the angle in radians
   * @returns {quat} out
   **/

  function setAxisAngle(out, axis, rad) {
    rad = rad * 0.5;
    var s = Math.sin(rad);
    out[0] = s * axis[0];
    out[1] = s * axis[1];
    out[2] = s * axis[2];
    out[3] = Math.cos(rad);
    return out;
  }
  /**
   * Performs a spherical linear interpolation between two quat
   *
   * @param {quat} out the receiving quaternion
   * @param {quat} a the first operand
   * @param {quat} b the second operand
   * @param {Number} t interpolation amount between the two inputs
   * @returns {quat} out
   */

  function slerp(out, a, b, t) {
    // benchmarks:
    //    http://jsperf.com/quaternion-slerp-implementations
    var ax = a[0],
        ay = a[1],
        az = a[2],
        aw = a[3];
    var bx = b[0],
        by = b[1],
        bz = b[2],
        bw = b[3];
    var omega, cosom, sinom, scale0, scale1; // calc cosine

    cosom = ax * bx + ay * by + az * bz + aw * bw; // adjust signs (if necessary)

    if (cosom < 0.0) {
      cosom = -cosom;
      bx = -bx;
      by = -by;
      bz = -bz;
      bw = -bw;
    } // calculate coefficients


    if (1.0 - cosom > 0.000001) {
      // standard case (slerp)
      omega = Math.acos(cosom);
      sinom = Math.sin(omega);
      scale0 = Math.sin((1.0 - t) * omega) / sinom;
      scale1 = Math.sin(t * omega) / sinom;
    } else {
      // "from" and "to" quaternions are very close
      //  ... so we can do a linear interpolation
      scale0 = 1.0 - t;
      scale1 = t;
    } // calculate final values


    out[0] = scale0 * ax + scale1 * bx;
    out[1] = scale0 * ay + scale1 * by;
    out[2] = scale0 * az + scale1 * bz;
    out[3] = scale0 * aw + scale1 * bw;
    return out;
  }
  /**
   * Creates a quaternion from the given 3x3 rotation matrix.
   *
   * NOTE: The resultant quaternion is not normalized, so you should be sure
   * to renormalize the quaternion yourself where necessary.
   *
   * @param {quat} out the receiving quaternion
   * @param {mat3} m rotation matrix
   * @returns {quat} out
   * @function
   */

  function fromMat3(out, m) {
    // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes
    // article "Quaternion Calculus and Fast Animation".
    var fTrace = m[0] + m[4] + m[8];
    var fRoot;

    if (fTrace > 0.0) {
      // |w| > 1/2, may as well choose w > 1/2
      fRoot = Math.sqrt(fTrace + 1.0); // 2w

      out[3] = 0.5 * fRoot;
      fRoot = 0.5 / fRoot; // 1/(4w)

      out[0] = (m[5] - m[7]) * fRoot;
      out[1] = (m[6] - m[2]) * fRoot;
      out[2] = (m[1] - m[3]) * fRoot;
    } else {
      // |w| <= 1/2
      var i = 0;
      if (m[4] > m[0]) i = 1;
      if (m[8] > m[i * 3 + i]) i = 2;
      var j = (i + 1) % 3;
      var k = (i + 2) % 3;
      fRoot = Math.sqrt(m[i * 3 + i] - m[j * 3 + j] - m[k * 3 + k] + 1.0);
      out[i] = 0.5 * fRoot;
      fRoot = 0.5 / fRoot;
      out[3] = (m[j * 3 + k] - m[k * 3 + j]) * fRoot;
      out[j] = (m[j * 3 + i] + m[i * 3 + j]) * fRoot;
      out[k] = (m[k * 3 + i] + m[i * 3 + k]) * fRoot;
    }

    return out;
  }
  /**
   * Creates a quaternion from the given euler angle x, y, z.
   *
   * @param {quat} out the receiving quaternion
   * @param {x} Angle to rotate around X axis in degrees.
   * @param {y} Angle to rotate around Y axis in degrees.
   * @param {z} Angle to rotate around Z axis in degrees.
   * @returns {quat} out
   * @function
   */

  function fromEuler(out, x, y, z) {
    var halfToRad = 0.5 * Math.PI / 180.0;
    x *= halfToRad;
    y *= halfToRad;
    z *= halfToRad;
    var sx = Math.sin(x);
    var cx = Math.cos(x);
    var sy = Math.sin(y);
    var cy = Math.cos(y);
    var sz = Math.sin(z);
    var cz = Math.cos(z);
    out[0] = sx * cy * cz - cx * sy * sz;
    out[1] = cx * sy * cz + sx * cy * sz;
    out[2] = cx * cy * sz - sx * sy * cz;
    out[3] = cx * cy * cz + sx * sy * sz;
    return out;
  }
  /**
   * Normalize a quat
   *
   * @param {quat} out the receiving quaternion
   * @param {quat} a quaternion to normalize
   * @returns {quat} out
   * @function
   */

  var normalize$2 = normalize$1;
  /**
   * Sets a quaternion to represent the shortest rotation from one
   * vector to another.
   *
   * Both vectors are assumed to be unit length.
   *
   * @param {quat} out the receiving quaternion.
   * @param {vec3} a the initial vector
   * @param {vec3} b the destination vector
   * @returns {quat} out
   */

  var rotationTo = function () {
    var tmpvec3 = create$2();
    var xUnitVec3 = fromValues(1, 0, 0);
    var yUnitVec3 = fromValues(0, 1, 0);
    return function (out, a, b) {
      var dot$1 = dot(a, b);

      if (dot$1 < -0.999999) {
        cross(tmpvec3, xUnitVec3, a);
        if (len(tmpvec3) < 0.000001) cross(tmpvec3, yUnitVec3, a);
        normalize(tmpvec3, tmpvec3);
        setAxisAngle(out, tmpvec3, Math.PI);
        return out;
      } else if (dot$1 > 0.999999) {
        out[0] = 0;
        out[1] = 0;
        out[2] = 0;
        out[3] = 1;
        return out;
      } else {
        cross(tmpvec3, a, b);
        out[0] = tmpvec3[0];
        out[1] = tmpvec3[1];
        out[2] = tmpvec3[2];
        out[3] = 1 + dot$1;
        return normalize$2(out, out);
      }
    };
  }();
  /**
   * Performs a spherical linear interpolation with two control points
   *
   * @param {quat} out the receiving quaternion
   * @param {quat} a the first operand
   * @param {quat} b the second operand
   * @param {quat} c the third operand
   * @param {quat} d the fourth operand
   * @param {Number} t interpolation amount
   * @returns {quat} out
   */

  var sqlerp = function () {
    var temp1 = create$4();
    var temp2 = create$4();
    return function (out, a, b, c, d, t) {
      slerp(temp1, a, d, t);
      slerp(temp2, b, c, t);
      slerp(out, temp1, temp2, 2 * t * (1 - t));
      return out;
    };
  }();
  /**
   * Sets the specified quaternion with values corresponding to the given
   * axes. Each axis is a vec3 and is expected to be unit length and
   * perpendicular to all other specified axes.
   *
   * @param {vec3} view  the vector representing the viewing direction
   * @param {vec3} right the vector representing the local "right" direction
   * @param {vec3} up    the vector representing the local "up" direction
   * @returns {quat} out
   */

  var setAxes = function () {
    var matr = create();
    return function (out, view, right, up) {
      matr[0] = right[0];
      matr[3] = right[1];
      matr[6] = right[2];
      matr[1] = up[0];
      matr[4] = up[1];
      matr[7] = up[2];
      matr[2] = -view[0];
      matr[5] = -view[1];
      matr[8] = -view[2];
      return normalize$2(out, fromMat3(out, matr));
    };
  }();

  /* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files (the "Software"), to deal
  in the Software without restriction, including without limitation the rights
  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  copies of the Software, and to permit persons to whom the Software is
  furnished to do so, subject to the following conditions:

  The above copyright notice and this permission notice shall be included in
  all copies or substantial portions of the Software.

  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
  THE SOFTWARE. */
  /**
   * 2 Dimensional Vector
   * @module vec2
   */

  /**
   * Creates a new, empty vec2
   *
   * @returns {vec2} a new 2D vector
   */

  function create$5() {
    var out = new ARRAY_TYPE(2);
    out[0] = 0;
    out[1] = 0;
    return out;
  }
  /**
   * Perform some operation over an array of vec2s.
   *
   * @param {Array} a the array of vectors to iterate over
   * @param {Number} stride Number of elements between the start of each vec2. If 0 assumes tightly packed
   * @param {Number} offset Number of elements to skip at the beginning of the array
   * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array
   * @param {Function} fn Function to call for each vector in the array
   * @param {Object} [arg] additional argument to pass to fn
   * @returns {Array} a
   * @function
   */

  var forEach$2 = function () {
    var vec = create$5();
    return function (a, stride, offset, count, fn, arg) {
      var i, l;

      if (!stride) {
        stride = 2;
      }

      if (!offset) {
        offset = 0;
      }

      if (count) {
        l = Math.min(count * stride + offset, a.length);
      } else {
        l = a.length;
      }

      for (i = offset; i < l; i += stride) {
        vec[0] = a[i];
        vec[1] = a[i + 1];
        fn(vec, vec, arg);
        a[i] = vec[0];
        a[i + 1] = vec[1];
      }

      return a;
    };
  }();

  var tMatrix = create$1();
  var _id = 0;
  var Component =
  /*#__PURE__*/
  function () {
    function Component() {
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref$id = _ref.id,
          id = _ref$id === void 0 ? "Component_" + _id++ : _ref$id,
          _ref$enabled = _ref.enabled,
          enabled = _ref$enabled === void 0 ? true : _ref$enabled,
          _ref$transform = _ref.transform,
          transform = _ref$transform === void 0 ? new Transform() : _ref$transform,
          _ref$visible = _ref.visible,
          visible = _ref$visible === void 0 ? true : _ref$visible;

      _classCallCheck(this, Component);

      this.id = id;
      this.enabled = enabled;
      this.transform = transform;
      this.visible = visible;
    }

    _createClass(Component, [{
      key: "update",
      value: function update(dt, scene, entity) {}
    }, {
      key: "render",
      value: function render(dt, scene, viewport, camera, stack, viewMatrix, modelMatrix, materialOverride) {}
    }]);

    return Component;
  }();

  var _id$1 = 0;
  var _index = 0;
  var Entity =
  /*#__PURE__*/
  function () {
    function Entity() {
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref$id = _ref.id,
          id = _ref$id === void 0 ? _id$1++ : _ref$id,
          _ref$components = _ref.components,
          components = _ref$components === void 0 ? [] : _ref$components,
          _ref$enabled = _ref.enabled,
          enabled = _ref$enabled === void 0 ? true : _ref$enabled,
          _ref$visible = _ref.visible,
          visible = _ref$visible === void 0 ? true : _ref$visible,
          _ref$pointerEvents = _ref.pointerEvents,
          pointerEvents = _ref$pointerEvents === void 0 ? true : _ref$pointerEvents,
          _ref$transform = _ref.transform,
          transform = _ref$transform === void 0 ? new Transform() : _ref$transform;

      _classCallCheck(this, Entity);

      // Extend _priv vars
      if (!this._priv) {
        this._priv = {
          events: []
        };
      }

      if (!this._priv.events) this._priv.events = [];
      this.id = id;
      this.index = _index++;
      this.enabled = enabled;
      this.visible = visible;
      this.opacity = 1.0;
      this.pointerEvents = pointerEvents;
      this.parentScene = null;
      this.components = components;
      this.transform = transform;
      this.inputState = {
        mouseOver: false
      };
      this.tMatrix = create$1();
    }
    /**
     * Called on every Scene update
     */


    _createClass(Entity, [{
      key: "update",
      value: function update(dt, scene) {
        if (!this.enabled) return;

        for (var i = 0; i < this.components.length; i++) {
          if (this.components[i].enabled) {
            this.components[i].update(dt, scene, this);
          }
        }
      }
      /**
       * Called on every Scene render
       */

    }, {
      key: "render",
      value: function render(dt, scene, viewport, camera, stack, viewMatrix, modelMatrix, materialOverride, frameBufferTextureStack) {
        if (!this.visible) return;
        stack.push(this); // Calculate model matrix

        if (modelMatrix) {
          mul(this.tMatrix, modelMatrix, this.transform.localMatrix);
        } else {
          copy(this.tMatrix, this.transform.localMatrix);
        }

        for (var i = 0; i < this.components.length; i++) {
          if (this.components[i].visible) {
            // matrix is being multiplied by other children's
            this.components[i].render(dt, scene, viewport, camera, stack, viewMatrix, this.tMatrix, materialOverride, frameBufferTextureStack);
          }
        }

        stack.pop();
      }
      /**
       * Add a new component
       */

    }, {
      key: "addComponent",
      value: function addComponent(component) {
        this.components.push(component);
        component.parentScene = this.parentScene;
        return component;
      }
      /**
      * Add a new component
      */

    }, {
      key: "removeComponent",
      value: function removeComponent(component) {
        if (this.components.indexOf(component) <= -1) return;
        this.components.splice(this.components.indexOf(component), 1);
        return component;
      }
      /**
       * Called on every Scene render pick
       */

    }, {
      key: "renderPick",
      value: function renderPick(viewport, camera, entityId) {
        if (!this.visible || !this.pointerEvents) return;

        for (var i = 0; i < this.components.length; i++) {
          if (this.components[i].visible) {
            if (this.components[i].renderPick) this.components[i].renderPick(viewport, camera, this, entityId);
          }
        }
      }
    }, {
      key: "findByIndex",
      value: function findByIndex(index) {
        if (this.index === index) return this;

        for (var i = 0; i < this.components.length; i++) {
          if (this.components[i].index === index) return this.components[i]; // TODO: Optimize

          if (this.components[i].findByIndex && this.components[i].findByIndex(index)) return this.components[i].findByIndex(index);
        }
      }
    }, {
      key: "registerHandler",
      value: function registerHandler() {// keep track of eventhandlers so we can remove them on destroy
        // this._priv.events.push();
      }
    }, {
      key: "unregisterHandler",
      value: function unregisterHandler() {}
    }, {
      key: "onload",
      value: function onload() {
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = this._priv.events[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var event = _step.value;
            this.registerHandler(event);
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator["return"] != null) {
              _iterator["return"]();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
      }
    }, {
      key: "onunload",
      value: function onunload() {
        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
          for (var _iterator2 = this._priv.events[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var event = _step2.value;
            this.unregisterHandler(event);
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
              _iterator2["return"]();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }
      }
      /**
      * Called every time the object is added to the scene
      */

    }, {
      key: "onSpawn",
      value: function onSpawn(scene) {
        this.parentScene = scene;
      }
      /**
       * Called every time the object is removed from the scene
       */

    }, {
      key: "onDestroy",
      value: function onDestroy(scene) {}
    }, {
      key: "onMouseDown",
      value: function onMouseDown(event) {}
    }, {
      key: "onMouseUp",
      value: function onMouseUp(event) {}
    }, {
      key: "onMouseOver",
      value: function onMouseOver(event) {}
    }, {
      key: "onMouseExit",
      value: function onMouseExit(event) {}
    }, {
      key: "onMouseDrop",
      value: function onMouseDrop(event) {}
    }, {
      key: "setTimeout",
      value: function setTimeout(callback, delay) {
        var _this = this;

        var timer = new Timer();
        this.addComponent(timer);
        timer.setTimeout(function (entity, dt, progress) {
          _this.removeComponent(timer);

          if (callback) callback();
        }, delay);
        return timer;
      }
    }, {
      key: "setInterval",
      value: function setInterval(callback) {
        var delay = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        var intervalCount = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
        var timer = new Timer();
        this.addComponent(timer);
        timer.setInterval(function (entity, dt, progress) {
          if (callback) callback();
        }, delay, intervalCount);
        return timer;
      }
    }, {
      key: "setModulate",
      value: function setModulate(callback, delay) {
        var timer = new Timer();
        this.addComponent(timer);
        timer.setModulate(function (dt, progress, count) {
          if (callback) callback(dt, progress, count);
        }, delay);
        return timer;
      }
    }, {
      key: "setTween",
      value: function setTween(_ref2) {
        var _this2 = this;

        var _ref2$propParent = _ref2.propParent,
            propParent = _ref2$propParent === void 0 ? this : _ref2$propParent,
            property = _ref2.property,
            to = _ref2.to,
            from = _ref2.from,
            duration = _ref2.duration,
            method = _ref2.method,
            onComplete = _ref2.onComplete,
            onUpdate = _ref2.onUpdate;
        var t = new Tween({
          propParent: propParent,
          property: property,
          to: to,
          from: from,
          duration: duration,
          method: method,
          onUpdate: onUpdate,
          callback: function callback() {
            if (onComplete) onComplete();

            _this2.removeComponent(t);
          }
        });
        this.addComponent(t);
        return t;
      }
    }, {
      key: "sortComponentsByZ",
      value: function sortComponentsByZ(inverse) {
        if (inverse) {
          this.components.sort(function (a, b) {
            return a.transform && b.transform && a.transform.z - b.transform.z;
          });
        } else {
          this.components.sort(function (a, b) {
            return !a.transform || !b.transform || b.transform.z - a.transform.z;
          });
        }
      } // TODO

    }, {
      key: "emit",
      value: function emit(id) {
        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }

        var _iteratorNormalCompletion3 = true;
        var _didIteratorError3 = false;
        var _iteratorError3 = undefined;

        try {
          for (var _iterator3 = this._priv.events[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
            var event = _step3.value;

            if (event.event == id) {
              event.target[event.property].apply(this, args);
            }
          }
        } catch (err) {
          _didIteratorError3 = true;
          _iteratorError3 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
              _iterator3["return"]();
            }
          } finally {
            if (_didIteratorError3) {
              throw _iteratorError3;
            }
          }
        }
      }
    }], [{
      key: "resetIndex",
      value: function resetIndex() {
        var val = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
        _index = val;
      }
    }, {
      key: "getIndex",
      value: function getIndex() {
        return _index;
      }
    }]);

    return Entity;
  }();

  var imgCache = {};

  var isPowerOf2 = function isPowerOf2(n) {
    return n && (n & n - 1) === 0;
  };

  var Texture =
  /*#__PURE__*/
  function () {
    _createClass(Texture, [{
      key: "width",
      get: function get() {
        return this.img.naturalWidth || this.img.width;
      },
      set: function set(val) {
        return this.img.width = val;
      }
    }, {
      key: "height",
      get: function get() {
        return this.img.naturalHeight || this.img.height;
      },
      set: function set(val) {
        return this.img.height = val;
      }
    }]);

    function Texture() {
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref$src = _ref.src,
          src = _ref$src === void 0 ? "" : _ref$src,
          _ref$flipY = _ref.flipY,
          flipY = _ref$flipY === void 0 ? true : _ref$flipY,
          _ref$textureType = _ref.textureType,
          textureType = _ref$textureType === void 0 ? "TEXTURE_2D" : _ref$textureType,
          _ref$magFilter = _ref.magFilter,
          magFilter = _ref$magFilter === void 0 ? "LINEAR" : _ref$magFilter,
          _ref$minFilter = _ref.minFilter,
          minFilter = _ref$minFilter === void 0 ? "LINEAR_MIPMAP_LINEAR" : _ref$minFilter,
          _ref$generateMipmap = _ref.generateMipmap,
          generateMipmap = _ref$generateMipmap === void 0 ? true : _ref$generateMipmap,
          img = _ref.img,
          buffer = _ref.buffer,
          _ref$wrap = _ref.wrap,
          wrap = _ref$wrap === void 0 ? {
        s: "CLAMP_TO_EDGE",
        t: "CLAMP_TO_EDGE"
      } : _ref$wrap;

      _classCallCheck(this, Texture);

      this.src = src;
      this._loadPromise = null;
      this.loaded = false;
      this.texture = [];
      this.img = img;
      this.buffer = buffer;
      this.flipY = flipY;
      this.magFilter = magFilter;
      this.minFilter = minFilter;
      this.textureType = textureType;
      this._generateMipmap = generateMipmap;
      this.wrap = wrap;
      this.compressionFormat = ""; // Auto-detect format

      if ( !this.src.includes(".")) this.autoDetectFormat(); // if(src) this.load();
    }

    _createClass(Texture, [{
      key: "autoDetectFormat",
      value: function autoDetectFormat() {
        this.compressionFormat = "";
        if (CONST.AVAILABLE_EXTENSIONS.includes('WEBGL_compressed_texture_pvrtc')) this.compressionFormat = "pvrtc";
        if (CONST.AVAILABLE_EXTENSIONS.includes('WEBGL_compressed_texture_s3tc')) this.compressionFormat = "dtx";
        if (CONST.AVAILABLE_EXTENSIONS.includes('WEBGL_compressed_texture_atc')) this.compressionFormat = "atc";
        if (CONST.AVAILABLE_EXTENSIONS.includes('WEBGL_compressed_texture_etc1')) this.compressionFormat = "etc";

        if (this.compressionFormat) {
          this.src = this.src.replace(".png", ".ktx");
          this.src = this.src.replace(".ktx", "-".concat(this.compressionFormat, ".ktx"));
        }
      }
    }, {
      key: "load",
      value: function load() {
        var _this = this;

        var viewport = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
        if (this._loadPromise) return this._loadPromise;

        if (imgCache[this.src]) {
          this.img = imgCache[this.src];
          this._loadPromise = new Promise(function (resolve, reject) {
            _this.loaded = true;
            _this._loadPromise = null;

            if (viewport) {
              if (Array.isArray(viewport)) {
                var _iteratorNormalCompletion = true;
                var _didIteratorError = false;
                var _iteratorError = undefined;

                try {
                  for (var _iterator = viewport[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                    var vp = _step.value;

                    _this.setAsTexture(vp);
                  }
                } catch (err) {
                  _didIteratorError = true;
                  _iteratorError = err;
                } finally {
                  try {
                    if (!_iteratorNormalCompletion && _iterator["return"] != null) {
                      _iterator["return"]();
                    }
                  } finally {
                    if (_didIteratorError) {
                      throw _iteratorError;
                    }
                  }
                }
              } else {
                _this.setAsTexture(viewport);
              }
            }

            resolve(_this);
          });
        } else {
          if (!this.compressionFormat) {
            this._loadPromise = this.loadImage(viewport);
          } else {
            this._loadPromise = this.loadTexture(viewport);
          }
        }

        return this._loadPromise;
      }
    }, {
      key: "loadImage",
      value: function () {
        var _loadImage = _asyncToGenerator(
        /*#__PURE__*/
        regeneratorRuntime.mark(function _callee(viewport) {
          var _this2 = this;

          return regeneratorRuntime.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  return _context.abrupt("return", new Promise(function (resolve, reject) {
                    _this2.img = new Image();

                    _this2.img.onload = function () {
                      _this2.loaded = true;
                      _this2._loadPromise = null;
                      imgCache[_this2.src] = _this2.img;
                      if (!isPowerOf2(_this2.img.width) || !isPowerOf2(_this2.img.height)) _this2._generateMipmap = false;

                      if (viewport) {
                        if (Array.isArray(viewport)) {
                          var _iteratorNormalCompletion2 = true;
                          var _didIteratorError2 = false;
                          var _iteratorError2 = undefined;

                          try {
                            for (var _iterator2 = viewport[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                              var vp = _step2.value;

                              _this2.setAsTexture(vp);
                            }
                          } catch (err) {
                            _didIteratorError2 = true;
                            _iteratorError2 = err;
                          } finally {
                            try {
                              if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
                                _iterator2["return"]();
                              }
                            } finally {
                              if (_didIteratorError2) {
                                throw _iteratorError2;
                              }
                            }
                          }
                        } else {
                          _this2.setAsTexture(viewport);
                        }
                      }

                      resolve(_this2);
                    };

                    _this2.img.onerror = function (e) {
                      _this2.loaded = false;
                      _this2._loadPromise = null;
                      reject("Error loading image file: '".concat(_this2.img.src, "'"));
                    };

                    _this2.img.src = _this2.src;
                  }));

                case 1:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee);
        }));

        function loadImage(_x) {
          return _loadImage.apply(this, arguments);
        }

        return loadImage;
      }()
    }, {
      key: "loadTexture",
      value: function () {
        var _loadTexture = _asyncToGenerator(
        /*#__PURE__*/
        regeneratorRuntime.mark(function _callee3(viewport) {
          var _this3 = this;

          return regeneratorRuntime.wrap(function _callee3$(_context3) {
            while (1) {
              switch (_context3.prev = _context3.next) {
                case 0:
                  return _context3.abrupt("return", new Promise(
                  /*#__PURE__*/
                  function () {
                    var _ref2 = _asyncToGenerator(
                    /*#__PURE__*/
                    regeneratorRuntime.mark(function _callee2(resolve, reject) {
                      var _iteratorNormalCompletion3, _didIteratorError3, _iteratorError3, _iterator3, _step3, vp;

                      return regeneratorRuntime.wrap(function _callee2$(_context2) {
                        while (1) {
                          switch (_context2.prev = _context2.next) {
                            case 0:
                              _context2.next = 2;
                              return fetch(_this3.src).then(function (response) {
                                return response.arrayBuffer();
                              });

                            case 2:
                              _this3.buffer = _context2.sent;

                              if (!viewport) {
                                _context2.next = 27;
                                break;
                              }

                              if (!Array.isArray(viewport)) {
                                _context2.next = 26;
                                break;
                              }

                              _iteratorNormalCompletion3 = true;
                              _didIteratorError3 = false;
                              _iteratorError3 = undefined;
                              _context2.prev = 8;

                              for (_iterator3 = viewport[Symbol.iterator](); !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                                vp = _step3.value;

                                _this3.setAsTexture(vp);
                              }

                              _context2.next = 16;
                              break;

                            case 12:
                              _context2.prev = 12;
                              _context2.t0 = _context2["catch"](8);
                              _didIteratorError3 = true;
                              _iteratorError3 = _context2.t0;

                            case 16:
                              _context2.prev = 16;
                              _context2.prev = 17;

                              if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
                                _iterator3["return"]();
                              }

                            case 19:
                              _context2.prev = 19;

                              if (!_didIteratorError3) {
                                _context2.next = 22;
                                break;
                              }

                              throw _iteratorError3;

                            case 22:
                              return _context2.finish(19);

                            case 23:
                              return _context2.finish(16);

                            case 24:
                              _context2.next = 27;
                              break;

                            case 26:
                              _this3.setAsTexture(viewport);

                            case 27:
                              resolve(_this3);

                            case 28:
                            case "end":
                              return _context2.stop();
                          }
                        }
                      }, _callee2, null, [[8, 12, 16, 24], [17,, 19, 23]]);
                    }));

                    return function (_x3, _x4) {
                      return _ref2.apply(this, arguments);
                    };
                  }()));

                case 1:
                case "end":
                  return _context3.stop();
              }
            }
          }, _callee3);
        }));

        function loadTexture(_x2) {
          return _loadTexture.apply(this, arguments);
        }

        return loadTexture;
      }()
    }, {
      key: "unload",
      value: function unload(viewport) {
        viewport.webgl.deleteTexture(this.texture[viewport.id]);
      }
    }, {
      key: "createTexture",
      value: function createTexture(viewport) {
        this.texture[viewport.id] = viewport.webgl.createTexture();
        viewport.webgl.bindTexture(viewport.webgl[this.textureType], this.texture[viewport.id]);
        viewport.webgl.pixelStorei(viewport.webgl.UNPACK_FLIP_Y_WEBGL, this.flipY); // viewport.webgl.pixelStorei(viewport.webgl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);

        if (this.textureType === "TEXTURE_CUBE_MAP") {
          for (var i = 0; i < 6; i++) {
            viewport.webgl.texImage2D(viewport.webgl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, viewport.webgl.RGBA, viewport.webgl.RGBA, viewport.webgl.UNSIGNED_BYTE, this.img);
          }
        } else {
          viewport.webgl.texImage2D(viewport.webgl[this.textureType], 0, viewport.webgl.RGBA, viewport.webgl.RGBA, viewport.webgl.UNSIGNED_BYTE, this.img);
        }
      }
    }, {
      key: "updateTexture",
      value: function updateTexture(viewport) {
        if (this._generateMipmap) {
          viewport.webgl.generateMipmap(viewport.webgl[this.textureType]);
        } // For video
        // if(this.video.readyState === 4){
        // 	viewport.webgl.texImage2D(viewport.webgl[this.textureType], 0, viewport.webgl.RGBA, viewport.webgl.RGBA, viewport.webgl.UNSIGNED_BYTE, this.video);
        // }
        //viewport.webgl.texParameteri(viewport.webgl[this.textureType], viewport.webgl.TEXTURE_MAG_FILTER, viewport.webgl.NEAREST);
        //viewport.webgl.texParameteri(viewport.webgl[this.textureType], viewport.webgl.TEXTURE_MIN_FILTER, viewport.webgl.NEAREST);

      }
    }, {
      key: "setAsTexture",
      value: function setAsTexture(viewport) {
        var textureNumber = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        var uniformPosition = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

        // TODO: Set to black texture if none loaded
        if (!this.img) {
          console.error('Texture has no image loaded');
          return false;
        }

        if (!this.loaded) {
          console.warn('Texture image not yet loaded');
          return false;
        }

        if (viewport._currentTexture[textureNumber] == this) return; // Create the texture if it doesn't exist yet

        if (!this.texture[viewport.id]) {
          this.createTexture(viewport);
          this.updateTexture(viewport);
        }

        viewport.webgl.activeTexture(viewport.webgl["TEXTURE" + textureNumber]);
        viewport.webgl.bindTexture(viewport.webgl[this.textureType], this.texture[viewport.id]); // Allow non-square textures

        viewport.webgl.texParameteri(viewport.webgl[this.textureType], viewport.webgl.TEXTURE_WRAP_S, viewport.webgl[this.wrap.s]);
        viewport.webgl.texParameteri(viewport.webgl[this.textureType], viewport.webgl.TEXTURE_WRAP_T, viewport.webgl[this.wrap.t]);
        viewport.webgl.texParameteri(viewport.webgl[this.textureType], viewport.webgl.TEXTURE_MAG_FILTER, viewport.webgl[this.magFilter]);
        viewport.webgl.texParameteri(viewport.webgl[this.textureType], viewport.webgl.TEXTURE_MIN_FILTER, viewport.webgl[this.minFilter]);

        if (uniformPosition) {
          viewport.webgl.uniform1i(uniformPosition, textureNumber);
        }

        viewport._currentTexture[textureNumber] = this;
        return true;
      }
    }]);

    return Texture;
  }();

  var tMatrix$1 = create$1();

  var viewMatrix = create$1();
  var Camera =
  /*#__PURE__*/
  function (_Entity) {
    _inherits(Camera, _Entity);

    _createClass(Camera, [{
      key: "nearPlane",
      get: function get() {
        return this._nearPlane;
      },
      set: function set(value) {
        this._nearPlane = value; // this.evaluate();

        return this._nearPlane;
      }
    }, {
      key: "farPlane",
      get: function get() {
        return this._farPlane;
      },
      set: function set(value) {
        this._farPlane = value; // this.evaluate();

        return this._farPlane;
      }
    }, {
      key: "projectionType",
      get: function get() {
        return this._projectionType;
      },
      set: function set(value) {
        this._projectionType = value; // this.evaluate();

        return this._projectionType;
      }
    }]);

    function Camera() {
      var _this;

      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref$nearPlane = _ref.nearPlane,
          nearPlane = _ref$nearPlane === void 0 ? 1 : _ref$nearPlane,
          _ref$farPlane = _ref.farPlane,
          farPlane = _ref$farPlane === void 0 ? 1000 : _ref$farPlane,
          _ref$fov = _ref.fov,
          fov = _ref$fov === void 0 ? 0.872665 : _ref$fov,
          _ref$projectionType = _ref.projectionType,
          projectionType = _ref$projectionType === void 0 ? "projection" : _ref$projectionType,
          _ref$followType = _ref.followType,
          followType = _ref$followType === void 0 ? "STATIC" : _ref$followType,
          _ref$stiffness = _ref.stiffness,
          stiffness = _ref$stiffness === void 0 ? [0.65, 0.65, 0.65] : _ref$stiffness;

      _classCallCheck(this, Camera);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(Camera).apply(this, arguments));
      _this._nearPlane = nearPlane;
      _this._farPlane = farPlane;
      _this._projectionType = projectionType;
      _this.fov = fov;
      _this.viewports = [];
      _this.shaderPasses = [];
      _this.mvTransform = new Transform(); // World space
      // Set mvTransform identity
      // mat4.identity(this.transform.localMatrix);
      // mat4.identity(this.mvTransform.localMatrix);
      // Should "follow" be a component so we can use it for other things?

      _this.followEntity = null;
      _this.followOffset = [0, 0, 0]; // Should this be a transform?

      _this.followType = followType;
      _this.stiffness = stiffness;
      _this.limit = {
        minimum: {
          x: null,
          y: null,
          z: null
        },
        maximum: {
          x: null,
          y: null,
          z: null
        }
      };
      _this.velocity = [0, 0, 0];
      _this.dampening = [0, 0, 0];
      _this.lock = [null, null, null];
      return _this;
    }

    _createClass(Camera, [{
      key: "render",
      value: function render(dt, scene, viewport, stack, matrix, materialOverride, frameBufferTextureStack) {
        stack.push(this); // Calculate view matrix

        mul(viewMatrix, matrix, this.transform.localMatrixInversed); // mat4.mul(viewMatrixFixed, matrix, mat4.create());
        // Render entity to viewport

        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = scene.entities[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var entity = _step.value;

            if (entity !== this && entity.visible) {
              entity.render(dt, scene, viewport, this, stack, entity.transform.positionFixed ? matrix : viewMatrix, null, materialOverride, frameBufferTextureStack);
            }
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator["return"] != null) {
              _iterator["return"]();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }

        stack.pop();
      }
    }, {
      key: "renderScenePick",
      value: function renderScenePick(viewport) {
        for (var i = 0; i < this.scene.entities.length; i++) {
          // Render entity to viewport
          this.scene.entities[i].renderPick(viewport, this, i);
        }
      }
    }, {
      key: "update",
      value: function update(deltaTime, scene) {
        if (this.followEntity) {
          var newX = this.transform.x - this.followOffset[0];
          var newY = this.transform.y - this.followOffset[1];
          var newZ = this.transform.z - this.followOffset[2];
          var destX = this.followEntity.transform.x;
          var destY = this.followEntity.transform.y;
          var destZ = this.followEntity.transform.z;

          switch (this.followType.toUpperCase()) {
            case "EASEIN":
              newX += Math.round((destX - newX) * Math.pow(this.stiffness[0], 2));
              newY += Math.round((destY - newY) * Math.pow(this.stiffness[1], 2));
              newZ += Math.round((destZ - newZ) * Math.pow(this.stiffness[2], 2));
              break;

            case "EASEOUT":
              // a + ((b-a) * %)
              newX += Math.round((destX - newX) * this.stiffness[0]);
              newY += Math.round((destY - newY) * this.stiffness[1]);
              newZ += Math.round((destZ - newZ) * this.stiffness[2]);
              break;

            case "SPRING":
              var vector = {
                x: destX - newX,
                y: destY - newY,
                z: destZ - newZ
              };
              var springConstantX = 5.5;
              var springConstantY = 6.5;
              var springConstantZ = 5.5; // if(Math.abs(vector.x) > targetWidth) {

              newX += springConstantX * vector.x; // }
              // if(Math.abs(vector.y) > targetWidth) {

              newY += springConstantY * vector.y; // }
              // if(Math.abs(vector.z) > targetWidth) {

              newZ += springConstantZ * vector.z; // }

              break;

            case "STATIC":
            default:
              newX = destX;
              newY = destY;
              newZ = destZ;
              break;
          }

          newX += this.followOffset[0];
          newY += this.followOffset[1];
          newZ += this.followOffset[2]; // Limit to bounds

          if (this.limit.minimum.x !== null && newX < this.limit.minimum.x) newX = this.limit.minimum.x;
          if (this.limit.minimum.y !== null && newY < this.limit.minimum.y) newY = this.limit.minimum.y;
          if (this.limit.minimum.z !== null && newZ < this.limit.minimum.z) newZ = this.limit.minimum.z;
          if (this.limit.maximum.x !== null && newX > this.limit.maximum.x) newX = this.limit.maximum.x;
          if (this.limit.maximum.y !== null && newY > this.limit.maximum.y) newY = this.limit.maximum.y;
          if (this.limit.maximum.z !== null && newZ > this.limit.maximum.z) newZ = this.limit.maximum.z;
          this.transform.xyz = [newX, newY, newZ];
        }

        if (this.lock[0] !== null) this.transform.x = this.lock[0];
        if (this.lock[1] !== null) this.transform.y = this.lock[1];
        if (this.lock[2] !== null) this.transform.z = this.lock[2];
        this.transform.x -= this.velocity[0];
        this.transform.y -= this.velocity[1];
        this.transform.z -= this.velocity[2]; // Dampening

        this.velocity[0] *= this.dampening[0];
        this.velocity[1] *= this.dampening[1];
        this.velocity[2] *= this.dampening[2]; // Limit to bounds
        // TODO: Take scaling (zoom) into account

        if (this.limit.minimum.x !== null && this.transform.x < this.limit.minimum.x) this.transform.x = this.limit.minimum.x;
        if (this.limit.minimum.y !== null && this.transform.y < this.limit.minimum.y) this.transform.y = this.limit.minimum.y;
        if (this.limit.minimum.z !== null && this.transform.z < this.limit.minimum.z) this.transform.z = this.limit.minimum.z;
        if (this.limit.maximum.x !== null && this.transform.x > this.limit.maximum.x) this.transform.x = this.limit.maximum.x;
        if (this.limit.maximum.y !== null && this.transform.y > this.limit.maximum.y) this.transform.y = this.limit.maximum.y;
        if (this.limit.maximum.z !== null && this.transform.z > this.limit.maximum.z) this.transform.z = this.limit.maximum.z;
      }
    }, {
      key: "addViewport",
      value: function addViewport(viewport) {
        this.viewports.push(viewport);
      }
    }, {
      key: "follow",
      value: function follow(entity) {
        var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [this.transform.x, this.transform.y, this.transform.z];
        var setInstant = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        this.followEntity = entity;
        this.followOffset = offset;

        if (setInstant) {
          this.transform.x = entity.transform.x + offset[0];
          this.transform.y = entity.transform.y + offset[1];
          this.transform.z = entity.transform.z + offset[2];
        }
      }
    }, {
      key: "lockX",
      value: function lockX() {
        var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.transform.x;
        this.lock[0] = x;
      }
    }, {
      key: "unlockX",
      value: function unlockX() {
        this.lock[0] = null;
      }
    }, {
      key: "lockY",
      value: function lockY() {
        var y = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.transform.y;
        this.lock[1] = y;
      }
    }, {
      key: "unlockY",
      value: function unlockY() {
        this.lock[1] = null;
      }
    }, {
      key: "lockZ",
      value: function lockZ() {
        var z = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.transform.z;
        this.lock[1] = z;
      }
    }, {
      key: "unlockZ",
      value: function unlockZ() {
        this.lock[0] = null;
      }
    }, {
      key: "getFrustum",
      value: function getFrustum(viewport) {
        var ndcPoints = [[-1, -1, -1, 1], [-1, -1, 1, 1], [-1, 1, -1, 1], [-1, 1, 1, 1], [1, -1, -1, 1], [1, -1, 1, 1], [1, 1, -1, 1], [1, 1, 1, 1]]; // Get inverse MVP

        var m = [];
        copy(m, viewport.projectionMatrix);
        multiply(m, m, this.transform.localMatrixInversed); // mat4.multiply(m, m, this.mvTransform.localMatrix);

        invert(m, m); // Get world space by multiplying corners (NDC cube points) by matrix

        for (var _i = 0, _ndcPoints = ndcPoints; _i < _ndcPoints.length; _i++) {
          var point = _ndcPoints[_i];
          transformMat4(point, point, m);
          point[0] /= point[3];
          point[1] /= point[3];
          point[2] /= point[3];
          point[3] /= point[3];
        }

        return ndcPoints;
      } // #based on https://github.com/sinisterchipmunk/jax/blob/5d392c9d67cb9ae5623dc03846027c473f625925/src/jax/webgl/camera.js#L568

    }, {
      key: "unproject",
      value: function unproject(viewport) {
        var winx = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        var winy = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
        var winz = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
        // Note: The basic idea here is to create an inverted matrix, then project the (normalized) coordinates with it
        // Note: Near plane should be minimum 0.1;
        var tFarPlane = this.farPlane;
        this._farPlane = this.transform.z;
        viewport.evaluate(false);
        var inf = create$3();
        var transformMatrix = this.parallax ? this.transform.getInverseParallax(this) : this.transform.localMatrixInversed;
        var mvTransformMatrix = this.mvTransform.localMatrix;
        var projectionMatrix = viewport.projectionMatrix;
        var view = [0, 0, viewport.contextElement.width, viewport.contextElement.height]; //Calculation for inverting a matrix, compute projection x modelview; then compute the inverse
        // Note: Typical shaders are using uPMatrix * uCMatrix * uMVMatrix

        var m = create$1();
        copy(m, projectionMatrix); // mat4.invert(m, m);

        multiply(m, m, transformMatrix);
        multiply(m, m, mvTransformMatrix);
        invert(m, m); // Transformation of normalized coordinates between -1 and 1

        inf[0] = (winx - view[0]) / view[2] * 2.0 - 1.0;
        inf[1] = (winy - view[1]) / view[3] * 2.0 - 1.0;
        inf[2] = 2.0 * winz - 1.0; // inf[2] = winz;

        inf[3] = 1.0; //			vec4.invert(inf, inf);
        //Objects coordinates

        var out = create$3();
        transformMat4(out, inf, m);
        this._farPlane = tFarPlane;
        viewport.evaluate(false);

        if (out[3] == 0.0) {
          return null;
        }

        out[3] = 1.0 / out[3];
        return [out[0] * out[3], out[1] * out[3], out[2] * out[3]]; // return [out[0] * viewport.contextElement.width, out[1] * viewport.contextElement.height];
      } // # http://webglfactory.blogspot.com/2011/05/how-to-convert-world-to-screen.html

    }, {
      key: "project",
      value: function project(viewport, point3D) {
        var transformMatrix = viewport.parallax ? this.transform.getInverseParallax(this) : this.transform.localMatrixInversed;
        var mvTransformMatrix = this.mvTransform.localMatrix;
        var projectionMatrix = viewport.projectionMatrix;
        var m = create$1();
        copy(m, projectionMatrix);
        multiply(m, m, transformMatrix);
        multiply(m, m, mvTransformMatrix);
        var v2d = [];
        var ix = point3D.xyz[0];
        var iy = point3D.xyz[1];
        var iz = point3D.xyz[2];
        var ox = m[0] * ix + m[4] * iy + m[8] * iz + m[12];
        var oy = m[1] * ix + m[5] * iy + m[9] * iz + m[13];
        var ow = m[3] * ix + m[7] * iy + m[11] * iz + m[15];
        v2d[0] = (ox / ow + 1) / 2;
        v2d[1] = 1 - (oy / ow + 1) / 2;
        v2d[0] = Math.round(v2d[0] * viewport.contextElement.width);
        v2d[1] = Math.round(v2d[1] * viewport.contextElement.height);
        return v2d;
      }
    }, {
      key: "getParallaxOffset",
      value: function getParallaxOffset(v3) {
        return this.transform.getParallaxOffset(v3.xyz ? v3.xyz : v3, this);
      }
    }]);

    return Camera;
  }(Entity);

  var performance;

  (function () {
    if (!window || "performance" in window == false) {
      performance = {};
    } else {
      performance = window.performance;
    }

    if ("now" in performance == false) {
      var nowOffset = new Date().getTime();

      if (performance.timing && performance.timing.navigationStart) {
        nowOffset = performance.timing.navigationStart;
      }

      performance.now = function now() {
        return new Date().getTime() - nowOffset;
      };
    }
  })();

  var requestAnimationFrame;

  (function () {
    if (window && window.requestAnimationFrame) {
      requestAnimationFrame = window.requestAnimationFrame;
    }

    var lastTime = 0;
    var vendors = ['ms', 'moz', 'webkit', 'o'];

    for (var x = 0; x < vendors.length && !requestAnimationFrame; ++x) {
      requestAnimationFrame = window[vendors[x] + 'RequestAnimationFrame'];
    }

    if (!requestAnimationFrame) requestAnimationFrame = function requestAnimationFrame(callback, element) {
      var currTime = new Date().getTime();
      var timeToCall = Math.max(0, 16 - (currTime - lastTime));
      var id = setTimeout(function () {
        callback(currTime + timeToCall);
      }, timeToCall);
      lastTime = currTime + timeToCall;
      return id;
    };
  })(); //Rounding numbers a little easier

  var Clock =
  /*#__PURE__*/
  function () {
    function Clock() {
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref$targetCyclesPerS = _ref.targetCyclesPerSecond,
          targetCyclesPerSecond = _ref$targetCyclesPerS === void 0 ? 60 : _ref$targetCyclesPerS,
          _ref$targetFramesPerS = _ref.targetFramesPerSecond,
          targetFramesPerSecond = _ref$targetFramesPerS === void 0 ? 60 : _ref$targetFramesPerS,
          _ref$autoRun = _ref.autoRun,
          autoRun = _ref$autoRun === void 0 ? true : _ref$autoRun;

      _classCallCheck(this, Clock);

      this._running = false;
      this.targetCyclesPerSecond = targetCyclesPerSecond;
      this.targetFramesPerSecond = targetFramesPerSecond;
      this.frameAccumulatorRemainderThreshold = 16;
      this.renderEnabled = true;
      this.stats = {
        fps: 0,
        cps: 0,
        framesThisSecond: 0,
        cyclesThisSecond: 0,
        droppedFramesThisSecond: 0,
        framesSkippedThisSecond: 0,
        renderExecutionTime: 0,
        updateExecutionTime: 0,
        currentGameTime: 0,
        lastUpdate: performance.now(),
        lastRender: performance.now(),
        lastFrame: performance.now()
      };
      this._r = {
        i: null,
        newTime: performance.now(),
        deltaTime: 1 / this.targetCyclesPerSecond * 1000,
        // In milliseconds
        renderDeltaTime: 1 / this.targetFramesPerSecond * 1000,
        // In milliseconds
        frameAccumulator: 0
      };
      this.scenes = [];
      this.viewports = []; // Start main loop

      if (autoRun) {
        this.start();
      }
    }
    /**
     * Starts the engine
     */


    _createClass(Clock, [{
      key: "start",
      value: function start() {
        if (this._running) return;
        this._running = true;
        this.update();
      }
      /**
       * Stops the engine
       */

    }, {
      key: "stop",
      value: function stop() {
        this._running = false;
      }
    }, {
      key: "resetAccumulator",
      value: function resetAccumulator() {
        this.stats.lastFrame = performance.now();
        this._r.frameAccumulator = 0;
      }
      /**
       * Main loop
       */

    }, {
      key: "update",
      value: function update() {
        if (!this._running) return; // Calculate delta time #http://gafferongames.com/game-physics/fix-your-timestep/

        this._r.newTime = performance.now(); // Milliseconds with microsecond precision

        this._r.frameTime = this._r.newTime - this.stats.lastFrame; // Frametime will always be 16ms or higher with requestAnimationFrame()

        if (this._r.frameTime > 1000) this._r.frameTime = 1000; // note: max frame time to avoid spiral of death -- 1FPS

        this.stats.lastFrame = this._r.newTime;
        this._r.frameAccumulator += this._r.frameTime; // Logic path

        this.stats.cyclesThisFrame = 0;
        this._r.i = Math.floor(this._r.frameAccumulator / this._r.deltaTime);
        var preexecutionTime = performance.now();

        while (this._r.i-- >= 0) {
          //			previousState = currentState;
          //			integrate( currentState, t, dt );
          var _iteratorNormalCompletion = true;
          var _didIteratorError = false;
          var _iteratorError = undefined;

          try {
            for (var _iterator = this.scenes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
              var scene = _step.value;

              if (scene.enabled) {
                scene.update(this._r.deltaTime);
              }
            }
          } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion && _iterator["return"] != null) {
                _iterator["return"]();
              }
            } finally {
              if (_didIteratorError) {
                throw _iteratorError;
              }
            }
          }

          this.stats.currentGameTime += this._r.deltaTime * 100;
          this.stats.cyclesThisFrame++; // In case an update wants to stop everything (e.g. switching to a new scene)

          if (!this._running) return;
        }

        this.stats.updateExecutionTime = performance.now() - preexecutionTime;
        this.stats.cyclesThisSecond += this.stats.cyclesThisFrame; // if(this.stats.cyclesThisFrame) this._r.frameAccumulator -= 1 / this.stats.cyclesThisFrame;

        this._r.frameAccumulator -= this.stats.cyclesThisFrame * this._r.deltaTime;
        this.stats.droppedFramesThisSecond += this.stats.cyclesThisSecond - 1; // Remove remainder
        // if(this._r.frameAccumulator > 1) this._r.frameAccumulator = 0;

        this.stats.frameAccumulatorRemainder = this._r.frameAccumulator; //		_processing = false;
        // Render path

        preexecutionTime = performance.now();

        if (this.renderEnabled && this.stats.cyclesThisFrame) {
          // && (this._r.newTime - this.stats.lastRender >= this._r.renderDeltaTime)){
          var _iteratorNormalCompletion2 = true;
          var _didIteratorError2 = false;
          var _iteratorError2 = undefined;

          try {
            for (var _iterator2 = this.scenes[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
              var _scene = _step2.value;

              _scene.render(performance.now() - this.stats.lastRender);
            }
          } catch (err) {
            _didIteratorError2 = true;
            _iteratorError2 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
                _iterator2["return"]();
              }
            } finally {
              if (_didIteratorError2) {
                throw _iteratorError2;
              }
            }
          }

          this.stats.lastRender = performance.now();
          this.stats.framesThisSecond++;
        } else {
          this.stats.framesSkippedThisSecond++;
        }
        this.stats.renderExecutionTime = performance.now() - preexecutionTime; // Update stats

        if (performance.now() - this.stats.lastUpdate > 1000) {
          this.stats.fps = this.stats.framesThisSecond;
          this.stats.cps = this.stats.cyclesThisSecond;
          this.stats.framesThisSecond = 0;
          this.stats.cyclesThisSecond = 0;
          this.stats.framesSkippedThisSecond = 0;
          this.stats.lastUpdate = performance.now();
        } // Debug
        // document.getElementById("debug").innerHTML = "FPS: " + this.stats.fps + " | CPS: " + this.stats.cps + "<br/>Render Time: " + Math.round(this.stats.renderExecutionTime) + "ms" + "<br/>Update Time: " + Math.round(this.stats.updateExecutionTime) + "ms" + "<br/>Current Gametime: " + Math.round(this.stats.currentGameTime);
        // this.stats.lastFrame = performance.now();    


        requestAnimationFrame(this.update.bind(this));
      }
    }, {
      key: "cyclesToMilliseconds",
      value: function cyclesToMilliseconds(cycles) {
        return cycles * this._r.deltaTime;
      }
    }, {
      key: "millisecondsToCycles",
      value: function millisecondsToCycles(milliseconds) {
        return milliseconds / this._r.deltaTime;
      }
    }, {
      key: "add",
      value: function add(obj) {
        this.scenes.push(obj); // obj.onload();
      }
    }, {
      key: "remove",
      value: function remove(obj) {
        this.scenes.splice(this.scenes.indexOf(obj), 1); // obj.onunload();
      }
    }]);

    return Clock;
  }();

  var Color =
  /*#__PURE__*/
  function () {
    _createClass(Color, [{
      key: "red",
      get: function get() {
        return this.color[0];
      },
      set: function set(val) {
        return this.color[0] = val;
      }
    }, {
      key: "green",
      get: function get() {
        return this.color[1];
      },
      set: function set(val) {
        return this.color[1] = val;
      }
    }, {
      key: "blue",
      get: function get() {
        return this.color[2];
      },
      set: function set(val) {
        return this.color[2] = val;
      }
    }, {
      key: "alpha",
      get: function get() {
        return this.color[3];
      },
      set: function set(val) {
        return this.color[3] = val;
      }
    }]);

    function Color() {

      _classCallCheck(this, Color);

      this.set.apply(this, arguments);
      this._color3Float32Array = new Float32Array(3);
      this._color4Float32Array = new Float32Array(4);
    }

    _createClass(Color, [{
      key: "set",
      value: function set() {
        var red = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0.0;
        var green = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.0;
        var blue = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0.0;
        var alpha = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1.0;

        if (typeof red === "string") {
          var rgba = this.parseHex(red);
          this.color = new Float32Array([rgba[0], rgba[1], rgba[2], rgba[3]]);
        } else if (red instanceof Array) {
          if (red[3] === undefined) red[3] = 1.0;
          this.color = new Float32Array([red[0], red[1], red[2], red[3]]);
        } else {
          this.color = new Float32Array([red, green, blue, alpha]);
        }
      }
    }, {
      key: "toArray",
      value: function toArray() {
        return this.color;
      }
    }, {
      key: "toVec3Array",
      value: function toVec3Array() {
        this._color3Float32Array.set([this.color[0], this.color[1], this.color[2]]);

        return this._color3Float32Array;
      }
    }, {
      key: "toRGBAArray",
      value: function toRGBAArray() {
        this._color4Float32Array.set([this.color[0] * 255, this.color[1] * 255, this.color[2] * 255, this.color[3]]);

        return this._color4Float32Array;
      } // #http://stackoverflow.com/a/5624139

    }, {
      key: "parseHex",
      value: function parseHex(hex) {
        // Expand shorthand form (e.g. "03F") to full form (e.g. "0033FF")
        var shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
        hex = hex.replace(shorthandRegex, function (m, r, g, b) {
          return r + r + g + g + b + b;
        });
        var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);

        if (result) {
          this.color[0] = parseInt(result[1], 16) / 255;
          this.color[1] = parseInt(result[2], 16) / 255;
          this.color[2] = parseInt(result[3], 16) / 255;
        }

        return this;
      }
    }, {
      key: "adjustHSL",
      value: function adjustHSL(deltaH, deltaS, deltaL) {
        var hslColor = this.rgbToHsl();
        hslColor[0] += (deltaH || 0) / 100;
        hslColor[1] += (deltaS || 0) / 100;
        hslColor[2] += (deltaL || 0) / 100;
        if (hslColor[0] < 0) hslColor[0] = 0;
        if (hslColor[1] < 0) hslColor[1] = 0;
        if (hslColor[2] < 0) hslColor[2] = 0;
        if (hslColor[0] > 1) hslColor[0] = 1;
        if (hslColor[1] > 1) hslColor[1] = 1;
        if (hslColor[2] > 1) hslColor[2] = 1;
        hslColor = this.hslToRgb(hslColor[0], hslColor[1], hslColor[2]);
        this.set(hslColor[0], hslColor[1], hslColor[2], this.alpha);
        return this;
      }
    }, {
      key: "adjustHue",
      value: function adjustHue(delta) {
        var hslColor = this.rgbToHsl();
        hslColor[0] += (delta || 0) / 100;
        hslColor = this.hslToRgb(hslColor[0], hslColor[1], hslColor[2]);
        this.set(hslColor[0], hslColor[1], hslColor[2], this.alpha);
        return this;
      }
    }, {
      key: "adjustSaturation",
      value: function adjustSaturation(delta) {
        var hslColor = this.rgbToHsl();
        hslColor[1] += (delta || 0) / 100;
        hslColor = this.hslToRgb(hslColor[0], hslColor[1], hslColor[2]);
        this.set(hslColor[0], hslColor[1], hslColor[2], this.alpha);
        return this;
      }
    }, {
      key: "adjustLightness",
      value: function adjustLightness(delta) {
        var hslColor = this.rgbToHsl();
        hslColor[2] += (delta || 0) / 100;
        hslColor = this.hslToRgb(hslColor[0], hslColor[1], hslColor[2]);
        this.set(hslColor[0], hslColor[1], hslColor[2], this.alpha);
        return this;
      }
    }, {
      key: "rgbToHsl",
      value: function rgbToHsl(r, g, b) {
        if (r == undefined) {
          r = this.red;
          g = this.green;
          b = this.blue;
        } // r /= 255, g /= 255, b /= 255;


        var max = Math.max(r, g, b),
            min = Math.min(r, g, b);
        var h,
            s,
            l = (max + min) / 2;

        if (max == min) {
          h = s = 0; // achromatic
        } else {
          var d = max - min;
          s = l > 0.5 ? d / (2 - max - min) : d / (max + min);

          switch (max) {
            case r:
              h = (g - b) / d + (g < b ? 6 : 0);
              break;

            case g:
              h = (b - r) / d + 2;
              break;

            case b:
              h = (r - g) / d + 4;
              break;
          }

          h /= 6;
        }

        return [h, s, l];
      }
    }, {
      key: "hslToRgb",
      value: function hslToRgb(h, s, l) {
        var r, g, b;

        if (h == undefined) {
          return [this.red, this.green, this.blue];
        }

        if (s == 0) {
          r = g = b = l; // achromatic
        } else {
          var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
          var p = 2 * l - q;
          r = this.hue2rgb(p, q, h + 1 / 3);
          g = this.hue2rgb(p, q, h);
          b = this.hue2rgb(p, q, h - 1 / 3);
        }

        return [Math.round(r), Math.round(g), Math.round(b)];
      }
    }, {
      key: "hue2rgb",
      value: function hue2rgb(p, q, t) {
        if (t < 0) t += 1;
        if (t > 1) t -= 1;
        if (t < 1 / 6) return p + (q - p) * 6 * t;
        if (t < 1 / 2) return q;
        if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
        return p;
      }
    }]);

    return Color;
  }();

  var FrameBufferTexture2D =
  /*#__PURE__*/
  function (_Texture) {
    _inherits(FrameBufferTexture2D, _Texture);

    _createClass(FrameBufferTexture2D, [{
      key: "width",
      get: function get() {
        return this.framebufferWidth;
      },
      set: function set(val) {
        return this.framebufferWidth = val;
      }
    }, {
      key: "height",
      get: function get() {
        return this.framebufferHeight;
      },
      set: function set(val) {
        return this.framebufferHeight = val;
      }
    }]);

    function FrameBufferTexture2D() {
      var _this;

      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref$width = _ref.width,
          width = _ref$width === void 0 ? 1024 : _ref$width,
          _ref$height = _ref.height,
          height = _ref$height === void 0 ? 1024 : _ref$height,
          _ref$flipY = _ref.flipY,
          flipY = _ref$flipY === void 0 ? false : _ref$flipY,
          _ref$textureType = _ref.textureType,
          textureType = _ref$textureType === void 0 ? "TEXTURE_2D" : _ref$textureType,
          _ref$magFilter = _ref.magFilter,
          magFilter = _ref$magFilter === void 0 ? "LINEAR" : _ref$magFilter,
          _ref$minFilter = _ref.minFilter,
          minFilter = _ref$minFilter === void 0 ? "LINEAR" : _ref$minFilter,
          _ref$generateMipmap = _ref.generateMipmap,
          generateMipmap = _ref$generateMipmap === void 0 ? false : _ref$generateMipmap,
          _ref$wrap = _ref.wrap,
          wrap = _ref$wrap === void 0 ? {
        s: "CLAMP_TO_EDGE",
        t: "CLAMP_TO_EDGE"
      } : _ref$wrap;

      _classCallCheck(this, FrameBufferTexture2D);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(FrameBufferTexture2D).apply(this, arguments));
      _this.framebuffer = null;
      _this.framebufferWidth = width;
      _this.framebufferHeight = height;
      _this.flipY = flipY;
      _this.magFilter = magFilter;
      _this.minFilter = minFilter;
      _this.textureType = textureType;
      _this.wrap = wrap;
      _this.generateMipmap = generateMipmap;
      _this.useDepthBuffer = true;
      _this.loaded = true;
      return _this;
    }

    _createClass(FrameBufferTexture2D, [{
      key: "bind",
      value: function bind(viewport) {
        var textureNumber = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        var width = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.width;
        var height = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : this.height;
        var target = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : viewport.webgl[this.textureType];

        // Create the "texture"
        if (!this.texture[viewport.id] || width !== this.width || height !== this.height) {
          this.width = width;
          this.height = height; // console.log(width, height);

          if (this.texture[viewport.id]) this.unload(viewport);
          this.createTexture(viewport);
        }

        viewport.webgl.bindTexture(viewport.webgl[this.textureType], this.texture[viewport.id]); // Create and bind the framebuffer

        if (!this.framebuffer) {
          this.framebuffer = viewport.webgl.createFramebuffer();
          this.width = width;
          this.height = height;
        }

        this.img = this.framebuffer;
        viewport.webgl.bindFramebuffer(viewport.webgl.FRAMEBUFFER, this.framebuffer);
        viewport.webgl.framebufferRenderbuffer(viewport.webgl.FRAMEBUFFER, viewport.webgl.DEPTH_ATTACHMENT, viewport.webgl.RENDERBUFFER, this.depthBuffer); // Set the size of the viewport to be the same size as the frame buffer

        viewport.webgl.viewport(0, 0, this.width, this.height); // attach the texture as the first color attachment

        viewport.webgl.framebufferTexture2D(viewport.webgl.FRAMEBUFFER, viewport.webgl.COLOR_ATTACHMENT0, target, this.texture[viewport.id], 0); // 0 = level

        viewport._currentTexture[textureNumber] = this;
      }
    }, {
      key: "unbind",
      value: function unbind(viewport) {
        viewport.webgl.bindFramebuffer(viewport.webgl.FRAMEBUFFER, null); // Set the size of the viewport to be the same size as the frame buffer

        viewport.webgl.viewport(0, 0, viewport.width, viewport.height);
      }
    }, {
      key: "createTexture",
      value: function createTexture(viewport) {
        // Create the texture in GL
        this.texture[viewport.id] = viewport.webgl.createTexture();
        viewport.webgl.bindTexture(viewport.webgl[this.textureType], this.texture[viewport.id]);
        viewport.webgl.pixelStorei(viewport.webgl.UNPACK_FLIP_Y_WEBGL, this.flipY); // Initialize the texture
        // define size and format of level 0

        var targetTextureWidth = this.framebufferWidth;
        var targetTextureHeight = this.framebufferHeight;
        var level = 0;
        var internalFormat = viewport.webgl.RGBA;
        var border = 0;
        var format = viewport.webgl.RGBA;
        var type = viewport.webgl.UNSIGNED_BYTE;
        var data = null; // Just tell WebGL to allocate the texture

        if (this.textureType === "TEXTURE_CUBE_MAP") {
          for (var i = 0; i < 6; i++) {
            viewport.webgl.texImage2D(viewport.webgl.TEXTURE_CUBE_MAP_POSITIVE_X + i, level, internalFormat, targetTextureWidth, targetTextureHeight, border, format, type, data);
          }
        } else {
          viewport.webgl.texImage2D(viewport.webgl[this.textureType], level, internalFormat, targetTextureWidth, targetTextureHeight, border, format, type, data);
        } // If using a depth buffer, create one


        if (this.useDepthBuffer) {
          // create a depth renderbuffer
          this.depthBuffer = viewport.webgl.createRenderbuffer();
          viewport.webgl.bindRenderbuffer(viewport.webgl.RENDERBUFFER, this.depthBuffer); // make a depth buffer and the same size as the targetTexture

          viewport.webgl.renderbufferStorage(viewport.webgl.RENDERBUFFER, viewport.webgl.DEPTH_COMPONENT16, targetTextureWidth, targetTextureHeight);
        }
      }
    }, {
      key: "updateTexture",
      value: function updateTexture(viewport) {}
    }]);

    return FrameBufferTexture2D;
  }(Texture);

  var GLProgram =
  /*#__PURE__*/
  function () {
    function GLProgram(viewport) {
      _classCallCheck(this, GLProgram);

      this.program = viewport.webgl.createProgram();
      this.attribute = {};
      this.uniform = {};
      this.fragmentShader = "";
      this.vertexShader = ""; // TODO: Make this an option for materials
      // viewport.webgl.getExtension('OES_standard_derivatives');
    }

    _createClass(GLProgram, [{
      key: "addVertexShader",
      value: function addVertexShader(viewport, shader) {
        var vs = viewport.webgl.createShader(viewport.webgl.VERTEX_SHADER);
        viewport.webgl.shaderSource(vs, shader);
        viewport.webgl.compileShader(vs);
        viewport.webgl.attachShader(this.program, vs); // Maybe do this after, so that you can attach/detach shaders
        // If creating the shader program failed, alert

        if (!viewport.webgl.getShaderParameter(vs, viewport.webgl.COMPILE_STATUS)) {
          throw "An error occurred compiling the vertex shader: " + viewport.webgl.getShaderInfoLog(vs);
        }

        this.vertexShader = shader;
      }
    }, {
      key: "addFragmentShader",
      value: function addFragmentShader(viewport, shader) {
        var fs = viewport.webgl.createShader(viewport.webgl.FRAGMENT_SHADER);
        viewport.webgl.shaderSource(fs, shader);
        viewport.webgl.compileShader(fs);
        viewport.webgl.attachShader(this.program, fs); // If creating the shader program failed, alert

        if (!viewport.webgl.getShaderParameter(fs, viewport.webgl.COMPILE_STATUS)) {
          throw "An error occurred compiling the fragment shader: " + viewport.webgl.getShaderInfoLog(fs);
        }

        this.fragmentShader = shader;
      }
    }, {
      key: "getAttributesFromShaders",
      value: function getAttributesFromShaders(viewport) {
        var attributeCount = viewport.webgl.getProgramParameter(this.program, viewport.webgl.ACTIVE_ATTRIBUTES);

        for (var i = 0; i < attributeCount; i++) {
          var attributeInfo = viewport.webgl.getActiveAttrib(this.program, i);
          this.attribute[attributeInfo.name] = viewport.webgl.getAttribLocation(this.program, attributeInfo.name);
          if (this.attribute[attributeInfo.name] < 0) delete this.attribute[attributeInfo.name];
        }
      }
    }, {
      key: "getUniformLocations",
      value: function getUniformLocations(viewport) {
        var uniformCount = viewport.webgl.getProgramParameter(this.program, viewport.webgl.ACTIVE_UNIFORMS);

        for (var i = 0; i < uniformCount; i++) {
          var uniformInfo = viewport.webgl.getActiveUniform(this.program, i);
          this.uniform[uniformInfo.name] = viewport.webgl.getUniformLocation(this.program, uniformInfo.name);
          if (this.uniform[uniformInfo.name] < 0) delete this.uniform[uniformInfo.name];
        }
      }
    }, {
      key: "use",
      value: function use(viewport) {
        viewport.webgl.useProgram(this.program);
      }
    }]);

    return GLProgram;
  }();

  var tMVPMatrix = create$1();
  var Light =
  /*#__PURE__*/
  function (_Entity) {
    _inherits(Light, _Entity);

    function Light() {
      var _this;

      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref$id = _ref.id,
          _ref$transform = _ref.transform,
          transform = _ref$transform === void 0 ? new Transform() : _ref$transform,
          _ref$ambientColor = _ref.ambientColor,
          ambientColor = _ref$ambientColor === void 0 ? new Color(0, 0, 0, 1) : _ref$ambientColor,
          _ref$diffuseColor = _ref.diffuseColor,
          diffuseColor = _ref$diffuseColor === void 0 ? new Color(1, 1, 1, 1) : _ref$diffuseColor,
          _ref$specularColor = _ref.specularColor,
          specularColor = _ref$specularColor === void 0 ? new Color(1, 1, 1, 1) : _ref$specularColor,
          _ref$intensity = _ref.intensity,
          intensity = _ref$intensity === void 0 ? 1.0 : _ref$intensity,
          _ref$maxDistance = _ref.maxDistance,
          maxDistance = _ref$maxDistance === void 0 ? 128.0 : _ref$maxDistance;

      _classCallCheck(this, Light);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(Light).apply(this, arguments));
      _this.ambientColor = ambientColor;
      _this.diffuseColor = diffuseColor;
      _this.specularColor = specularColor;
      _this.intensity = intensity;
      _this.maxDistance = maxDistance;
      _this.projectionMatrix = create$1();
      identity(_this.projectionMatrix); // mat4.ortho(this.projectionMatrix, -40, 40, -40, 40, -this.maxDistance, this.maxDistance);
      // mat4.ortho(this.projectionMatrix, -40, 40, -40, 40, -40.0, 80);
      // mat4.ortho(this.projectionMatrix, -10, 10, -10, 10, -10.0, 80);

      return _this;
    }

    _createClass(Light, [{
      key: "getMVPMatrix",
      value: function getMVPMatrix(modelMatrix, viewMatrix) {
        perspective(this.projectionMatrix, 1.5708, 1, 0.01, this.maxDistance); // mat4.lookAt(tMVPMatrix, this.transform.xyz, [this.transform.x, this.transform.y, this.transform.z - 100], [0,1,0]);
        // mat4.mul(tMVPMatrix, this.projectionMatrix, this.transform.localMatrix);

        copy(tMVPMatrix, this.projectionMatrix);

        if (viewMatrix) {
          // Cube map direction
          mul(tMVPMatrix, tMVPMatrix, viewMatrix);
        } // This position


        mul(tMVPMatrix, tMVPMatrix, this.transform.localMatrixInversed);

        if (modelMatrix) {
          mul(tMVPMatrix, tMVPMatrix, modelMatrix);
        } // mat4.targetTo(tMVPMatrix, this.transform.xyz, [this.transform.x, this.transform.y, this.transform.z - 100], [0,1,0]);


        return tMVPMatrix;
      }
    }]);

    return Light;
  }(Entity);

  var tMVPMatrix$1 = create$1();
  var tLVMatrix = create$1();
  var tLPMatrix = create$1();
  var tCropMatrix = create$1();
  var DirectionalLight =
  /*#__PURE__*/
  function (_Light) {
    _inherits(DirectionalLight, _Light);

    function DirectionalLight() {
      var _this;

      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref$id = _ref.id,
          _ref$vector = _ref.vector,
          vector = _ref$vector === void 0 ? [0, -1, 0] : _ref$vector;

      _classCallCheck(this, DirectionalLight);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(DirectionalLight).apply(this, arguments));
      _this.vector = vector;
      _this.maxShadowDistance = 50;
      return _this;
    }

    _createClass(DirectionalLight, [{
      key: "getMVPMatrix",
      value: function getMVPMatrix(modelMatrix, viewport) {
        var minX = Infinity;
        var maxX = -Infinity;
        var minY = Infinity;
        var maxY = -Infinity;
        var minZ = Infinity;
        var maxZ = -Infinity; // Get view frustum
        // let t = viewport.camera.farPlane;
        // viewport.camera.farPlane = this.maxShadowDistance;
        // viewport.evaluate();

        var frustum = viewport.camera.getFrustum(viewport); // viewport.camera.farPlane = t;
        // viewport.evaluate();
        // Get max distance scale

        var scaleX = Math.abs(frustum[7][0] - frustum[0][0]) / this.maxShadowDistance;
        var scaleY = Math.abs(frustum[7][1] - frustum[0][1]) / this.maxShadowDistance;
        var scaleZ = Math.abs(frustum[7][2] - frustum[0][2]) / this.maxShadowDistance;

        var frustumCenter = [0, 0, 0];
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = frustum[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var point = _step.value;
            frustumCenter[0] += point[0];
            frustumCenter[1] += point[1];
            frustumCenter[2] += point[2];
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator["return"] != null) {
              _iterator["return"]();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }

        for (var i = 0; i < 3; i++) {
          frustumCenter[i] /= 8;
        } // Rotate light view to direction
        //  - Get light view direction matrix


        var normalized = [];
        normalize(normalized, this.vector);
        normalized[0] += frustumCenter[0];
        normalized[1] += frustumCenter[1];
        normalized[2] += frustumCenter[2];
        lookAt(tLVMatrix, frustumCenter, normalized, [0, 1, 0]); //  - Rotate

        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
          for (var _iterator2 = frustum[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var _point = _step2.value;
            transformMat4(_point, _point, tLVMatrix);
            minX = Math.min(minX, _point[0]);
            maxX = Math.max(maxX, _point[0]);
            minY = Math.min(minY, _point[1]);
            maxY = Math.max(maxY, _point[1]);
            minZ = Math.min(minZ, _point[2]);
            maxZ = Math.max(maxZ, _point[2]);
          } // Get units per texel

        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
              _iterator2["return"]();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }

        var bufferSize = viewport._currentTexture[0] ? viewport._currentTexture[0].width : 512; // TODO: Is this hacky to grab the texture from here?
        // minX /= unitsPerTexelX;
        // minX = Math.floor(minX);
        // minX *= unitsPerTexelX;
        // maxX /= unitsPerTexelX;
        // maxX = Math.floor(maxX);
        // maxX *= unitsPerTexelX;
        // minY /= unitsPerTexelY;
        // minY = Math.floor(minY);
        // minY *= unitsPerTexelY;
        // maxY /= unitsPerTexelY;
        // maxY = Math.floor(maxY);
        // maxY *= unitsPerTexelY;
        // minZ /= unitsPerTexelZ;
        // minZ = Math.floor(minZ);
        // minZ *= unitsPerTexelZ;
        // maxZ /= unitsPerTexelZ;
        // maxZ = Math.floor(maxZ);
        // maxZ *= unitsPerTexelZ;
        // console.log(frustum, frustumCenter);
        // console.log( minX, maxX, minY, maxY, minZ, maxZ);
        // Generate orthographic matrix

        ortho(tLPMatrix, -1, 1, -1, 1, minZ, maxZ); // mat4.ortho(tLPMatrix, minX, maxX, minY, maxY, minZ, maxZ);
        // Crop

        scaleX = Math.min(2 / (maxX - minX), 2 / this.maxShadowDistance);
        scaleY = Math.min(2 / (maxY - minY), 2 / this.maxShadowDistance);
        scaleZ = Math.min(1 / (maxZ - minZ), 1 / this.maxShadowDistance);
        var offsetX = -0.5 * (minX + maxX) * scaleX;
        var offsetY = -0.5 * (minY + maxY) * scaleY;
        var offsetZ = -minZ * scaleZ;
        tCropMatrix[0] = scaleX;
        tCropMatrix[5] = scaleY;
        tCropMatrix[10] = scaleZ;
        tCropMatrix[12] = offsetX;
        tCropMatrix[13] = offsetY;
        tCropMatrix[14] = offsetZ; // cropMatrix * lpMatrix * lvMatrix;

        mul(tMVPMatrix$1, tCropMatrix, tLPMatrix);
        mul(tMVPMatrix$1, tMVPMatrix$1, tLVMatrix); // lpMatrix * lvMatrix * cropMatrix;
        // mat4.mul(tMVPMatrix, tLPMatrix, tLVMatrix);
        // mat4.mul(tMVPMatrix, tMVPMatrix, tCropMatrix);
        // ... * Model

        if (modelMatrix) {
          mul(tMVPMatrix$1, tMVPMatrix$1, modelMatrix);
        } // debugger;


        return tMVPMatrix$1;
      }
    }]);

    return DirectionalLight;
  }(Light);

  var tMVPMatrix$2 = create$1();
  var PointLight =
  /*#__PURE__*/
  function (_Light) {
    _inherits(PointLight, _Light);

    function PointLight() {
      var _this;

      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref$id = _ref.id,
          _ref$intensity = _ref.intensity,
          _ref$maxDistance = _ref.maxDistance;

      _classCallCheck(this, PointLight);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(PointLight).apply(this, arguments));
      _this.constantAttenuation = 1;
      _this.linearAttenuation = 1;
      _this.quadraticAttenuation = 1;
      return _this;
    }

    _createClass(PointLight, [{
      key: "getMVPMatrix",
      value: function getMVPMatrix(modelMatrix, viewport, viewMatrix) {
        perspective(this.projectionMatrix, 1.5708, 1, 0.01, this.maxDistance); // mat4.lookAt(tMVPMatrix, this.transform.xyz, [this.transform.x, this.transform.y, this.transform.z - 100], [0,1,0]);
        // mat4.mul(tMVPMatrix, this.projectionMatrix, this.transform.localMatrix);

        copy(tMVPMatrix$2, this.projectionMatrix);

        if (viewMatrix) {
          // Cube map direction
          mul(tMVPMatrix$2, tMVPMatrix$2, viewMatrix);
        } // This position


        mul(tMVPMatrix$2, tMVPMatrix$2, this.transform.localMatrixInversed);

        if (modelMatrix) {
          mul(tMVPMatrix$2, tMVPMatrix$2, modelMatrix);
        } // mat4.targetTo(tMVPMatrix, this.transform.xyz, [this.transform.x, this.transform.y, this.transform.z - 100], [0,1,0]);


        return tMVPMatrix$2;
      }
    }]);

    return PointLight;
  }(Light);

  var tMVPMatrix$3 = create$1();
  var SpotLight =
  /*#__PURE__*/
  function (_Light) {
    _inherits(SpotLight, _Light);

    function SpotLight() {
      var _this;

      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref$id = _ref.id,
          _ref$intensity = _ref.intensity,
          _ref$maxDistance = _ref.maxDistance;

      _classCallCheck(this, SpotLight);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(SpotLight).apply(this, arguments));
      _this.spotDirection = [0, -1, 0];
      _this.spotExponent = 1;
      _this.spotCutoff = 1;
      _this.constantAttenuation = 1;
      _this.linearAttenuation = 1;
      _this.quadraticAttenuation = 1;
      return _this;
    }

    _createClass(SpotLight, [{
      key: "getMVPMatrix",
      value: function getMVPMatrix(modelMatrix, viewMatrix) {
        perspective(this.projectionMatrix, 1.5708, 1, 0.01, this.maxDistance); // mat4.lookAt(tMVPMatrix, this.transform.xyz, [this.transform.x, this.transform.y, this.transform.z - 100], [0,1,0]);
        // mat4.mul(tMVPMatrix, this.projectionMatrix, this.transform.localMatrix);

        copy(tMVPMatrix$3, this.projectionMatrix);

        if (viewMatrix) {
          // Cube map direction
          mul(tMVPMatrix$3, tMVPMatrix$3, viewMatrix);
        } // This position


        mul(tMVPMatrix$3, tMVPMatrix$3, this.transform.localMatrixInversed);

        if (modelMatrix) {
          mul(tMVPMatrix$3, tMVPMatrix$3, modelMatrix);
        } // mat4.targetTo(tMVPMatrix, this.transform.xyz, [this.transform.x, this.transform.y, this.transform.z - 100], [0,1,0]);


        return tMVPMatrix$3;
      }
    }]);

    return SpotLight;
  }(Light);

  var SCREEN_VERTEX_POSITION = [-1, -1, 0, 1, -1, 0, 1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0];
  var tMatrix$2 = create$1();
  var Material =
  /*#__PURE__*/
  function () {
    // TODO: depthFunc should be LESS by default
    function Material() {
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref$name = _ref.name,
          name = _ref$name === void 0 ? "" : _ref$name,
          _ref$depthTest = _ref.depthTest,
          depthTest = _ref$depthTest === void 0 ? true : _ref$depthTest,
          _ref$depthFunc = _ref.depthFunc,
          depthFunc = _ref$depthFunc === void 0 ? 'LEQUAL' : _ref$depthFunc,
          _ref$depthMask = _ref.depthMask,
          depthMask = _ref$depthMask === void 0 ? true : _ref$depthMask,
          _ref$depthRangeNear = _ref.depthRangeNear,
          depthRangeNear = _ref$depthRangeNear === void 0 ? 0 : _ref$depthRangeNear,
          _ref$depthRangeFar = _ref.depthRangeFar,
          depthRangeFar = _ref$depthRangeFar === void 0 ? 1 : _ref$depthRangeFar,
          _ref$cullFace = _ref.cullFace,
          cullFace = _ref$cullFace === void 0 ? true : _ref$cullFace,
          _ref$cullFaceMode = _ref.cullFaceMode,
          cullFaceMode = _ref$cullFaceMode === void 0 ? "BACK" : _ref$cullFaceMode,
          _ref$frontFace = _ref.frontFace,
          frontFace = _ref$frontFace === void 0 ? "CCW" : _ref$frontFace;

      _classCallCheck(this, Material);

      this.name = name;
      this.program = [];
      this.vbuffer = null;
      this.blend = true;
      this.depthTest = depthTest; // this.depthWrite = true;

      this.depthFunc = depthFunc;
      this.depthMask = depthMask;
      this.depthRangeNear = depthRangeNear;
      this.depthRangeFar = depthRangeFar;
      this.cullFace = cullFace;
      this.cullFaceMode = cullFaceMode;
      this.frontFace = frontFace;
      this.timeOffset = 0;
      this.buffers = {
        screenVertices: []
      };
    }

    _createClass(Material, [{
      key: "render",
      value: function render(dt, scene, viewport, camera, stack, viewMatrix, modelMatrix, frameBufferTextureStack) {
        // TODO: We should compile a shader cache, so that way we aren't unnecessarily swapping shaders
        // TODO: Compile per viewport
        if (!this.program[viewport.id]) {
          this.program[viewport.id] = viewport.createProgram(this);
        }

        viewport.useProgram(this.program[viewport.id]);

        if (this.blend) {
          viewport.webgl.enable(viewport.webgl.BLEND);
          viewport.webgl.blendFuncSeparate(viewport.webgl.SRC_ALPHA, viewport.webgl.ONE_MINUS_SRC_ALPHA, viewport.webgl.ZERO, viewport.webgl.ONE); // viewport.webgl.blendFuncSeparate(viewport.webgl.BLEND_DST_ALPHA, viewport.webgl.ONE_MINUS_SRC_ALPHA, viewport.webgl.ZERO, viewport.webgl.ONE);
          // viewport.webgl.blendFuncSeparate(viewport.webgl.BLEND_SRC_ALPHA, viewport.webgl.SRC_ALPHA, viewport.webgl.ZERO, viewport.webgl.ONE);
        } else {
          viewport.webgl.disable(viewport.webgl.BLEND);
        } // Enable depth testing


        if (this.depthTest) {
          viewport.webgl.enable(viewport.webgl.DEPTH_TEST);
          viewport.webgl.depthMask(this.depthMask);
          viewport.webgl.depthFunc(viewport.webgl[this.depthFunc]);
          viewport.webgl.depthRange(this.depthRangeNear, this.depthRangeFar);
        } else {
          viewport.webgl.disable(viewport.webgl.DEPTH_TEST);
        }

        if (this.cullFace) {
          viewport.webgl.enable(viewport.webgl.CULL_FACE);
          viewport.webgl.cullFace(viewport.webgl[this.cullFaceMode]);
          viewport.webgl.frontFace(viewport.webgl[this.frontFace]);
        } else {
          viewport.webgl.disable(viewport.webgl.CULL_FACE);
        } // Set screen vertices


        if (viewport.program.attribute.aVertexScreenPosition !== undefined) {
          // Buffer mesh verts
          if (!this.buffers.screenVertices[viewport.id]) {
            this.buffers.screenVertices[viewport.id] = viewport.webgl.createBuffer(); // Pass vertices to buffer
            // TODO: Do this once per vertices being updated (but bind on every frame)

            viewport.webgl.bindBuffer(viewport.webgl.ARRAY_BUFFER, this.buffers.screenVertices[viewport.id]);
            viewport.webgl.bufferData(viewport.webgl.ARRAY_BUFFER, new Float32Array(SCREEN_VERTEX_POSITION), viewport.webgl.STATIC_DRAW);
          }

          viewport.webgl.bindBuffer(viewport.webgl.ARRAY_BUFFER, this.buffers.screenVertices[viewport.id]); // Tell the vertex shader how to read the array

          viewport.webgl.vertexAttribPointer(viewport.program.attribute.aVertexScreenPosition, 3, viewport.webgl.FLOAT, false, 0, 0);
          viewport.webgl.enableVertexAttribArray(viewport.program.attribute.aVertexScreenPosition);
        } // Model View Camera Projection Matrix


        if (viewport.program.uniform.uMVCPMatrix !== undefined) {
          mul(tMatrix$2, viewMatrix, modelMatrix);
          viewport.webgl.uniformMatrix4fv(viewport.program.uniform.uMVCPMatrix, false, tMatrix$2);
        } // Set the camera position matrix


        if (viewport.program.uniform.uCMatrix !== undefined) {
          viewport.webgl.uniformMatrix4fv(viewport.program.uniform.uCMatrix, false, camera.transform.localMatrixInversed);
        } // Set the model view matrix (Inverse of camera position)


        if (viewport.program.uniform.uMVMatrix !== undefined) {
          viewport.webgl.uniformMatrix4fv(viewport.program.uniform.uMVMatrix, false, camera.mvTransform.localMatrix);
        } // Set the view matrix (Inverse of camera position)


        if (viewport.program.uniform.uVMatrix !== undefined) {
          viewport.webgl.uniformMatrix4fv(viewport.program.uniform.uVMatrix, false, viewMatrix);
        } // Set the model matrix


        if (viewport.program.uniform.uMMatrix !== undefined) {
          viewport.webgl.uniformMatrix4fv(viewport.program.uniform.uMMatrix, false, modelMatrix);
        } // Set the camera position


        if (viewport.program.uniform.uCameraPosition !== undefined) {
          viewport.webgl.uniform3fv(viewport.program.uniform.uCameraPosition, camera.transform.xyz);
        } // Set the time


        if (viewport.program.uniform.iTime !== undefined) {
          viewport.webgl.uniform1f(viewport.program.uniform.iTime, (scene.clock.stats.currentGameTime + this.timeOffset) / 100000); // Divide by 1000 to help with intigers on lowp
        }

        if (viewport.program.uniform.uNormalMatrix !== undefined) {
          invert(tMatrix$2, modelMatrix);
          transpose(tMatrix$2, tMatrix$2); // TODO: Can this be optimized?
          // Note: The second argument (transpose) MUST be false according to WebGL spec

          viewport.webgl.uniformMatrix4fv(viewport.program.uniform.uNormalMatrix, false, tMatrix$2);
        } // Set the entity position matrix


        if (viewport.program.uniform.uTMatrix !== undefined) {
          if (viewport.parallax) {
            viewport.webgl.uniformMatrix4fv(viewport.program.uniform.uTMatrix, false, entity.transform.getParallaxMat4(camera));
          } else {
            viewport.webgl.uniformMatrix4fv(viewport.program.uniform.uTMatrix, false, entity.transform.localMatrix);
          }
        }
      }
    }, {
      key: "setValues",
      value: function setValues(obj) {
        return;
      }
    }, {
      key: "buildProgram",
      value: function buildProgram() {}
    }]);

    return Material;
  }();

  var tMatrix$3 = create$1();
  var Mesh =
  /*#__PURE__*/
  function (_Component) {
    _inherits(Mesh, _Component);

    function Mesh() {
      var _this;

      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref$id = _ref.id,
          _ref$material = _ref.material,
          material = _ref$material === void 0 ? new MaterialPhong() : _ref$material,
          _ref$vertices = _ref.vertices,
          vertices = _ref$vertices === void 0 ? new Float32Array(0) : _ref$vertices,
          _ref$uvs = _ref.uvs,
          uvs = _ref$uvs === void 0 ? new Float32Array(0) : _ref$uvs,
          _ref$normals = _ref.normals,
          normals = _ref$normals === void 0 ? new Float32Array(0) : _ref$normals,
          _ref$weights = _ref.weights,
          weights = _ref$weights === void 0 ? new Float32Array(0) : _ref$weights,
          _ref$weightIndices = _ref.weightIndices,
          weightIndices = _ref$weightIndices === void 0 ? new Float32Array(0) : _ref$weightIndices,
          _ref$parameters = _ref.parameters,
          _ref$faces = _ref.faces,
          _ref$bufferUsage = _ref.bufferUsage,
          bufferUsage = _ref$bufferUsage === void 0 ? {
        vertices: "STATIC_DRAW",
        uvs: "STATIC_DRAW",
        normals: "STATIC_DRAW",
        weights: "STATIC_DRAW",
        weightIndices: "STATIC_DRAW"
      } : _ref$bufferUsage,
          _ref$drawMode = _ref.drawMode,
          drawMode = _ref$drawMode === void 0 ? "TRIANGLES" : _ref$drawMode;

      _classCallCheck(this, Mesh);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(Mesh).apply(this, arguments));
      _this.material = material; // TODO: Should we have multiple materials?

      _this.vertices = vertices;
      _this.uvs = uvs;
      _this.normals = normals; // this.parameters = parameters;
      // this.faces = faces;

      _this.weights = weights;
      _this.weightIndices = weightIndices;
      _this.castShadow = true;
      _this.receiveShadow = true;
      _this.buffers = {
        vertices: [],
        uvs: [],
        normals: [],
        weights: [],
        weightIndices: []
      };
      _this.valid = {
        vertices: [],
        uvs: [],
        normals: [],
        weights: [],
        weightIndices: []
      }; // TODO: Make this argument more optional

      _this.bufferUsage = bufferUsage;
      _this.drawMode = drawMode;
      return _this;
    }

    _createClass(Mesh, [{
      key: "update",
      value: function update() {// Anything?
      }
    }, {
      key: "render",
      value: function render(dt, scene, viewport, camera, stack, viewMatrix, modelMatrix) {
        var material = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : this.material;
        var frameBufferTextureStack = arguments.length > 8 ? arguments[8] : undefined;
        if (!material || !this.vertices.length) return;
        stack.push(this); // Calculate view matrix

        mul(tMatrix$3, modelMatrix, this.transform.localMatrix);
        if (material.render(dt, scene, viewport, camera, stack, viewMatrix, tMatrix$3, frameBufferTextureStack) === false) return;

        if (viewport.program.attribute.aVertexPosition !== undefined) {
          // Buffer mesh verts
          if (!this.buffers.vertices[viewport.id]) {
            this.buffers.vertices[viewport.id] = viewport.webgl.createBuffer();
          }

          viewport.webgl.bindBuffer(viewport.webgl.ARRAY_BUFFER, this.buffers.vertices[viewport.id]);

          if (!this.valid.vertices[viewport.id]) {
            // Pass vertices to buffer
            viewport.webgl.bufferData(viewport.webgl.ARRAY_BUFFER, this.vertices, viewport.webgl[this.bufferUsage.vertices]);
            this.valid.vertices[viewport.id] = true;
          } // Tell the vertex shader how to read the array


          viewport.webgl.vertexAttribPointer(viewport.program.attribute.aVertexPosition, 3, viewport.webgl.FLOAT, false, 0, 0);
          viewport.webgl.enableVertexAttribArray(viewport.program.attribute.aVertexPosition);
        } // UVs


        if (viewport.program.attribute.aTextureCoord !== undefined) {
          // Buffer uvs
          if (!this.buffers.uvs[viewport.id]) {
            this.buffers.uvs[viewport.id] = viewport.webgl.createBuffer();
          }

          viewport.webgl.bindBuffer(viewport.webgl.ARRAY_BUFFER, this.buffers.uvs[viewport.id]);

          if (!this.valid.uvs[viewport.id]) {
            // Pass uvs to buffer
            viewport.webgl.bufferData(viewport.webgl.ARRAY_BUFFER, this.uvs, viewport.webgl[this.bufferUsage.uvs]);
            this.valid.uvs[viewport.id] = true;
          } // Tell the vertex shader how to read the array


          viewport.webgl.vertexAttribPointer(viewport.program.attribute.aTextureCoord, 2, viewport.webgl.FLOAT, false, 0, 0);
          viewport.webgl.enableVertexAttribArray(viewport.program.attribute.aTextureCoord);
        } // Normals


        if (viewport.program.attribute.aVertexNormal !== undefined) {
          // Buffer uvs
          if (!this.buffers.normals[viewport.id]) {
            this.buffers.normals[viewport.id] = viewport.webgl.createBuffer();
          }

          viewport.webgl.bindBuffer(viewport.webgl.ARRAY_BUFFER, this.buffers.normals[viewport.id]);

          if (!this.valid.normals[viewport.id]) {
            // Pass normals to buffer
            viewport.webgl.bufferData(viewport.webgl.ARRAY_BUFFER, this.normals, viewport.webgl[this.bufferUsage.normals]);
            this.valid.normals[viewport.id] = true;
          } // Tell the vertex shader how to read the array


          viewport.webgl.vertexAttribPointer(viewport.program.attribute.aVertexNormal, 3, viewport.webgl.FLOAT, false, 0, 0);
          viewport.webgl.enableVertexAttribArray(viewport.program.attribute.aVertexNormal);
        } // Weights


        if (viewport.program.attribute.aVertexWeights !== undefined) {
          // Buffer weights
          if (!this.buffers.weights[viewport.id]) {
            this.buffers.weights[viewport.id] = viewport.webgl.createBuffer();
          }

          viewport.webgl.bindBuffer(viewport.webgl.ARRAY_BUFFER, this.buffers.weights[viewport.id]);

          if (!this.valid.weights[viewport.id]) {
            // Pass weights to buffer
            viewport.webgl.bufferData(viewport.webgl.ARRAY_BUFFER, this.weights, viewport.webgl[this.bufferUsage.weights]);
            this.valid.weights[viewport.id] = true;
          } // Tell the vertex shader how to read the array


          viewport.webgl.vertexAttribPointer(viewport.program.attribute.aVertexWeights, 4, viewport.webgl.FLOAT, false, 0, 0);
          viewport.webgl.enableVertexAttribArray(viewport.program.attribute.aVertexWeights);
        } // Weights Indices


        if (viewport.program.attribute.aVertexWeightIndices !== undefined) {
          // Buffer weightIndices
          if (!this.buffers.weightIndices[viewport.id]) {
            this.buffers.weightIndices[viewport.id] = viewport.webgl.createBuffer();
          }

          viewport.webgl.bindBuffer(viewport.webgl.ARRAY_BUFFER, this.buffers.weightIndices[viewport.id]);

          if (!this.valid.weightIndices[viewport.id]) {
            // Pass weightIndices to buffer
            viewport.webgl.bufferData(viewport.webgl.ARRAY_BUFFER, this.weightIndices, viewport.webgl[this.bufferUsage.weightIndices]);
            this.valid.weightIndices[viewport.id] = true;
          } // Tell the vertex shader how to read the array


          viewport.webgl.vertexAttribPointer(viewport.program.attribute.aVertexWeightIndices, 4, viewport.webgl.FLOAT, false, 0, 0);
          viewport.webgl.enableVertexAttribArray(viewport.program.attribute.aVertexWeightIndices);
        } // Joint transforms


        if (viewport.program.uniform["uDeformMatrix[0]"] !== undefined) {
          // TODO: Select model and entity properly
          viewport.webgl.uniformMatrix4fv(viewport.program.uniform["uDeformMatrix[0]"], false, stack[stack.length - 2].skeleton.getFlatMatrix(stack[stack.length - 3].transform.localMatrix));
        } // Draw


        viewport.webgl.drawArrays(viewport.webgl[this.drawMode], 0, this.vertices.length / 3);
        stack.pop();
      }
    }, {
      key: "invalidate",
      value: function invalidate() {
        var vertices = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
        var uvs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
        var normals = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
        var weights = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
        var weightIndices = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;
        //TODO: make each one optional (and default to what the current value is)
        this.valid = {
          vertices: vertices ? [] : this.valid.vertices,
          uvs: uvs ? [] : this.valid.uvs,
          normals: normals ? [] : this.valid.normals,
          weights: weights ? [] : this.valid.weights,
          weightIndices: weightIndices ? [] : this.valid.weightIndices
        };
      } //TODO: Should this be a geometry class?

    }, {
      key: "addPlane",
      value: function addPlane(width, height) {
        //TODO: Generalize this concept
        function Float32Concat(first, second) {
          var firstLength = first.length,
              result = new Float32Array(firstLength + second.length);
          result.set(first);
          result.set(second, firstLength);
          return result;
        }

        this.vertices = Float32Concat(this.vertices, [0.0, 0.0, 0.0, 1.0 * width, 0.0, 0.0, 1.0 * width, 1.0 * height, 0.0, 0.0, 1.0 * height, 0.0, 0.0, 0.0, 0.0, 1.0 * width, 1.0 * height, 0.0]);
        this.uvs = Float32Concat(this.uvs, [0.0, 1.0, //  left,    top, 
        1.0, 1.0, // right,    top, 
        1.0, 0.0, // right, bottom, 
        0.0, 0.0, //  left, bottom, 
        0.0, 1.0, //  left,    top, 
        1.0, 0.0 // right, bottom, 
        ]);
        this.normals = Float32Concat(this.normals, [0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0]);
        this.invalidate();
        return this;
      }
    }, {
      key: "addCube",
      value: function addCube() {
        //TODO: Generalize this concept
        function Float32Concat(first, second) {
          var firstLength = first.length,
              result = new Float32Array(firstLength + second.length);
          result.set(first);
          result.set(second, firstLength);
          return result;
        }

        this.vertices = Float32Concat(this.vertices, [-0.5, -0.5, 0.5, 0.5, -0.5, 0.5, -0.5, 0.5, 0.5, -0.5, 0.5, 0.5, 0.5, -0.5, 0.5, 0.5, 0.5, 0.5, -0.5, 0.5, 0.5, 0.5, 0.5, 0.5, -0.5, 0.5, -0.5, -0.5, 0.5, -0.5, 0.5, 0.5, 0.5, 0.5, 0.5, -0.5, -0.5, 0.5, -0.5, 0.5, 0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, 0.5, 0.5, -0.5, 0.5, -0.5, -0.5, -0.5, -0.5, -0.5, 0.5, -0.5, -0.5, -0.5, -0.5, 0.5, -0.5, -0.5, 0.5, 0.5, -0.5, -0.5, 0.5, -0.5, 0.5, 0.5, -0.5, 0.5, 0.5, -0.5, -0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, -0.5, -0.5, 0.5, 0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, 0.5, -0.5, 0.5, -0.5, -0.5, 0.5, -0.5, -0.5, -0.5, 0.5, -0.5, 0.5, 0.5]);
        this.uvs = Float32Concat(this.vertices, [0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1]);
        this.normals = Float32Concat(this.vertices, [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0]);
        this.invalidate();
        return this;
      }
    }]);

    return Mesh;
  }(Component);

  var tMatrix$4 = create$1();
   // REFERENCE: Model or Mesh? https://books.google.com/books?id=0bUJAgAAQBAJ&pg=PA38&lpg=PA38&dq=model+or+mesh&source=bl&ots=YHaPzACkgG&sig=ZGRp7qyCQbVlqZECbm0Hx-oZTYc&hl=en&sa=X&ved=0ahUKEwjNsYK59-nWAhUN8YMKHZ5UAoc4ChDoAQg8MAA#v=onepage&q&f=false

  var Preloader =
  /*#__PURE__*/
  function () {
    function Preloader() {// TODO, keep track of pending textures and/or count for progress reports.

      _classCallCheck(this, Preloader);
    }

    _createClass(Preloader, [{
      key: "preloadTextures",
      value: function preloadTextures() {
        var srcList = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
        var progressCallback = arguments.length > 1 ? arguments[1] : undefined;
        var viewports = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
        var textureOptions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
        var pending = srcList.length;
        var loadedAssets = [];
        return new Promise(
        /*#__PURE__*/
        function () {
          var _ref = _asyncToGenerator(
          /*#__PURE__*/
          regeneratorRuntime.mark(function _callee(resolve, reject) {
            var _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, src, newTexture, percent;

            return regeneratorRuntime.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    if (!pending) resolve();
                    _context.prev = 1;
                    _iteratorNormalCompletion = true;
                    _didIteratorError = false;
                    _iteratorError = undefined;
                    _context.prev = 5;
                    _iterator = srcList[Symbol.iterator]();

                  case 7:
                    if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {
                      _context.next = 20;
                      break;
                    }

                    src = _step.value;
                    textureOptions.src = src;
                    newTexture = new Texture(textureOptions); // if(Array.isArray(viewports)){
                    //     for(let viewport of viewports){
                    //         await newTexture.load(viewport);
                    //     }
                    // }else{

                    _context.next = 13;
                    return newTexture.load(viewports);

                  case 13:
                    // }
                    loadedAssets.push(newTexture);
                    pending--;

                    if (progressCallback) {
                      percent = (srcList.length - pending) / srcList.length;
                      progressCallback(percent, srcList.length - pending);
                    }

                    if (!pending) {
                      resolve(loadedAssets);
                    }

                  case 17:
                    _iteratorNormalCompletion = true;
                    _context.next = 7;
                    break;

                  case 20:
                    _context.next = 26;
                    break;

                  case 22:
                    _context.prev = 22;
                    _context.t0 = _context["catch"](5);
                    _didIteratorError = true;
                    _iteratorError = _context.t0;

                  case 26:
                    _context.prev = 26;
                    _context.prev = 27;

                    if (!_iteratorNormalCompletion && _iterator["return"] != null) {
                      _iterator["return"]();
                    }

                  case 29:
                    _context.prev = 29;

                    if (!_didIteratorError) {
                      _context.next = 32;
                      break;
                    }

                    throw _iteratorError;

                  case 32:
                    return _context.finish(29);

                  case 33:
                    return _context.finish(26);

                  case 34:
                    _context.next = 39;
                    break;

                  case 36:
                    _context.prev = 36;
                    _context.t1 = _context["catch"](1);
                    reject.apply(void 0, _toConsumableArray(_context.t1));

                  case 39:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, null, [[1, 36], [5, 22, 26, 34], [27,, 29, 33]]);
          }));

          return function (_x, _x2) {
            return _ref.apply(this, arguments);
          };
        }());
      } // preloadModels(srcList = [], progressCallback) {
      // 	let pending = srcList.length;
      //     return new Promise((resolve, reject) => {
      //         if(!pending) resolve();
      //         for(let src of srcList){
      //             ModelCache.load(src).then(() => {
      //                 pending--;
      //                 if(progressCallback){
      //                     let percent = (srcList.length - pending) / srcList.length;
      //                     progressCallback(percent, srcList.length - pending);
      //                 }
      //                 if(!pending) resolve();
      //             }).catch((...args) => {
      //                 reject(...args);
      //             });
      //         }
      //     });
      // }
      //      preloadAudio(srcList = []) {
      // 		let pending = 0;
      //         return new Promise(function(resolve, reject) {
      //             if(srcList.length <= 0) resolve();
      //             for(let modelSrc of srcList){
      //                 AudioCache.load(modelSrc).then(() => {
      //                     pending--;
      //                     if(!pending) resolve();
      //                 });
      //             }
      //         });
      //     }

    }]);

    return Preloader;
  }();

  var RenderPass =
  /*#__PURE__*/
  function () {
    function RenderPass() {
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref$renderPasses = _ref.renderPasses,
          renderPasses = _ref$renderPasses === void 0 ? [] : _ref$renderPasses,
          _ref$frameBufferTextu = _ref.frameBufferTexture,
          frameBufferTexture = _ref$frameBufferTextu === void 0 ? null : _ref$frameBufferTextu,
          _ref$viewportClear = _ref.viewportClear,
          viewportClear = _ref$viewportClear === void 0 ? true : _ref$viewportClear;

      _classCallCheck(this, RenderPass);

      this.renderPasses = renderPasses;
      this.frameBufferTexture = frameBufferTexture;
      this.viewportClear = viewportClear;
    }

    _createClass(RenderPass, [{
      key: "render",
      value: function render(dt, scene, viewport, stack, matrix, materialOverride) {
        var frameBufferTextureStack = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : [];

        if (this.frameBufferTexture) {
          frameBufferTextureStack.push(this.frameBufferTexture); // Bind frameBufferTexture

          this.frameBufferTexture.bind(viewport, 0, viewport.width, viewport.height); // TODO: Clear instead of viewport.clear()?

          if (this.viewportClear) viewport.clear();
          viewport.render(dt, scene, stack, matrix, undefined, frameBufferTextureStack); // Unbind frameBufferTexture

          this.frameBufferTexture.unbind(viewport);
        } else {
          // TODO: Clear instead of viewport.clear()?
          if (this.viewportClear) viewport.clear();
          viewport.render(dt, scene, stack, matrix, undefined, frameBufferTextureStack);
        }

        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = this.renderPasses[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var renderPass = _step.value;
            renderPass.render(dt, scene, viewport, stack, matrix, undefined, frameBufferTextureStack);
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator["return"] != null) {
              _iterator["return"]();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }

        if (this.frameBufferTexture) frameBufferTextureStack.pop();
      }
    }]);

    return RenderPass;
  }();

  var Router =
  /*#__PURE__*/
  function () {
    function Router() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
        map: [],
        clock: null
      };

      _classCallCheck(this, Router);

      this.map = options.map;
      this.currentController = [];
      this.clock = options.clock;
      this.routeViews = []; // this.viewports = []; // this should be at the stage level

      this.scenes = [];
      this.queryDOM();
    }

    _createClass(Router, [{
      key: "navigate",
      value: function navigate(routeName, params) {
        var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
            _ref$view = _ref.view,
            view = _ref$view === void 0 ? "main" : _ref$view;

        // Unload previous route
        this.routeUnload(this.currentController[view], view); // Load new route

        var route = this.map[routeName];
        if (!route) return false; // Load new route

        this.queryDOM(); // console.log("route view loop " + this.routeViews.length);

        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = this.routeViews[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var v = _step.value;

            if (!view || view == v.id || view.id == v) {
              route.module.populateDOM(v);
            }
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator["return"] != null) {
              _iterator["return"]();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }

        route.module.onload(params);
        route.module.start();
        this.currentController[view] = route.module; // TODO: Inject params?

        this.currentRoute = route;

        if (this.clock && !route.module.clock) {
          this.clock.add(route.module);
          this.clock.resetAccumulator();
        } // console.log(`[Onyx] Navigation to "${route}" complete.`);


        return true;
      }
    }, {
      key: "modal",
      value: function modal(routeName) {
        var onResolve = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {};
        var onReject = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function () {};
        var params = arguments.length > 3 ? arguments[3] : undefined;

        var _ref2 = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {},
            _ref2$view = _ref2.view,
            view = _ref2$view === void 0 ? "main" : _ref2$view;

        // Load new route
        var route = this.map[routeName];
        if (!route) return false; // Load new route

        this.queryDOM();
        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
          for (var _iterator2 = this.routeViews[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var v = _step2.value;

            if (!view || view == v.id || view.id == v) {
              route.module.populateDOM(v);
            }
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
              _iterator2["return"]();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }

        route.module.onload(params);
        route.module.start();
        route.module._modal = {
          callee: this,
          module: route.module,
          view: view,
          onResolve: onResolve,
          onReject: onReject
        };
        this.currentController[view] = route.module; // TODO: Inject params?

        this.currentRoute = route;

        if (this.clock) {
          this.clock.add(route.module);
          this.clock.resetAccumulator();
        }

        return route.module._modal;
      }
    }, {
      key: "modalResult",
      value: function modalResult(result, modal) {
        var unload = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
        if (!modal) return;
        if (unload) this.routeUnload(modal.module, modal.view);

        if (result) {
          modal.onResolve();
        } else {
          modal.onReject();
        }
      }
    }, {
      key: "modalUnload",
      value: function modalUnload(modal) {
        if (!modal) return;
        this.routeUnload(modal.module, modal.view);
      } // query for <onyx-route-view> tags

    }, {
      key: "queryDOM",
      value: function queryDOM() {
        this.routeViews = []; // Note: CocoonJS doesn't fully support querySelectorAll, so we're doing this manually, rather than querySelectorAll
        // Any <onyx-route-view> tags

        var nodes = document.getElementsByTagName("onyx-route-view");

        for (var i = 0; i < nodes.length; i++) {
          this.routeViews.push(nodes[i]);
        } // Workaround for CocoonJS


        if (!this.routeViews.length && document.getElementById("onyx-route-view")) {
          this.routeViews.push(document.getElementById("onyx-route-view"));
        }
      }
    }, {
      key: "routeUnload",
      value: function routeUnload() {
        var controller = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
        var view = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
        if (!controller) return;
        controller.stop();

        if (this.clock) {
          this.clock.remove(controller);
        }

        var _iteratorNormalCompletion3 = true;
        var _didIteratorError3 = false;
        var _iteratorError3 = undefined;

        try {
          for (var _iterator3 = this.routeViews[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
            var v = _step3.value;

            // view.innerHTML = response;
            if (!view || view == v.id || view.id == v) {
              controller.onunload(v);
              controller.clearDom(v);
            }
          }
        } catch (err) {
          _didIteratorError3 = true;
          _iteratorError3 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
              _iterator3["return"]();
            }
          } finally {
            if (_didIteratorError3) {
              throw _iteratorError3;
            }
          }
        }
      }
    }]);

    return Router;
  }();

  var Scene =
  /*#__PURE__*/
  function (_Entity) {
    _inherits(Scene, _Entity);

    function Scene() {
      var _this;

      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref$template = _ref.template,
          template = _ref$template === void 0 ? null : _ref$template,
          _ref$templateURL = _ref.templateURL,
          templateURL = _ref$templateURL === void 0 ? null : _ref$templateURL,
          _ref$sceneURL = _ref.sceneURL,
          sceneURL = _ref$sceneURL === void 0 ? null : _ref$sceneURL,
          _ref$element = _ref.element,
          element = _ref$element === void 0 ? "" : _ref$element,
          _ref$clock = _ref.clock,
          clock = _ref$clock === void 0 ? null : _ref$clock;

      _classCallCheck(this, Scene);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(Scene).call(this));
      _this.viewports = [];
      _this.viewportElements = [];
      _this.entities = [];
      _this.removeEntities = []; // For deferred removal

      _this.cameras = [];
      _this.lights = [];
      _this.renderPasses = [new RenderPassShadow({
        renderPasses: [new RenderPass()]
      })]; // this.renderPasses = [new RenderPass()];

      _this.templateURL = templateURL; // TODO: Should this whole "template" thing be in a "Route" class?

      _this.sceneURL = sceneURL;
      _this.template = template;
      _this.clock = clock;
      _this.ambientLightColor = new Color(0.05, 0.05, 0.05, 1.0);
      _this.directionalLight = new DirectionalLight({
        id: "DirectionalLight_Default",
        diffuseColor: new Color(0.5, 0.5, 0.5, 1),
        intensity: 2,
        vector: [-0.85, -0.8, -0.75]
      });
      _this.fogColor = new Color(1.0, 1.0, 1.0, 1.0);
      _this.fogDensity = 0.0;

      if (element) {
        _this.element = document.querySelector(element);

        if (!_this.element) {
          console.warn("[Onyx] Element '".concat(element, "' not found"));
        }
      }

      if (clock) {
        clock.add(_assertThisInitialized(_this));
      }

      _this.queryDOM(_this.element);

      _this.loadSceneURL();

      _this.loadTemplateURL();

      return _this;
    }

    _createClass(Scene, [{
      key: "registerHandler",
      value: function registerHandler(event) {
        var _this2 = this;

        // Get element
        var element = event.elementId ? document.getElementById(event.elementId) : document.body;

        if (!element) {
          console.warn("[Onyx] Element \"".concat(event.elementId, "\" not found"));
          return;
        } // Assign event to element
        //TODO Error checking / Remove need for setTimeout


        window.setTimeout(function () {
          event.callback = event.target[event.property].bind(_this2);

          if (element.addEventListener) {
            element.addEventListener(event.event, event.callback);
          } else {
            element[event.event] = event.callback;
          }
        }, 0);
      }
    }, {
      key: "unregisterHandler",
      value: function unregisterHandler(event) {
        // Get element
        var element = event.elementId ? document.getElementById(event.elementId) : document.body;

        if (!element) {
          console.warn("[Onyx] Element \"".concat(event.elementId, "\" not found"));
          return;
        } // Unassign event to element


        if (element.addEventListener) {
          element.removeEventListener(event.event, event.callback);
        } else {
          element[event.event] = null;
        }
      }
    }, {
      key: "modalResult",
      value: function modalResult(result, unload) {
        if (this._modal) {
          this._modal.callee.modalResult(result, this._modal, unload);
        }
      }
    }, {
      key: "modalUnload",
      value: function modalUnload() {
        if (this._modal) {
          this._modal.callee.modalUnload(this._modal);
        }
      }
    }, {
      key: "loadSceneURL",
      value: function loadSceneURL() {
        var _this3 = this;

        var url = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.sceneURL;
        if (!url) return false;
        this.fetchTemplate(url).then(function (response) {
          _this3.scene = response;
        });
      }
    }, {
      key: "loadTemplateURL",
      value: function loadTemplateURL() {
        var _this4 = this;

        var url = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.templateURL;
        if (!url) return false;
        this.fetchTemplate(url).then(function (response) {
          _this4.template = response;
        });
      } // TODO: rename to onLoad

    }, {
      key: "onload",
      value: function onload() {
        var _get2;

        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        (_get2 = _get(_getPrototypeOf(Scene.prototype), "onload", this)).call.apply(_get2, [this].concat(args));

        if (this.element) this.queryDOM(this.element);
      }
    }, {
      key: "onunload",
      value: function onunload() {
        var _get3;

        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }

        (_get3 = _get(_getPrototypeOf(Scene.prototype), "onunload", this)).call.apply(_get3, [this].concat(args)); // TODO Call onDestroy for everything


        this.entities = [];
        this.viewports = [];
        this.viewportElements = [];
        this.components = [];

        if (this.element) {
          this.element.innerHTML = "";
          this.element.style.display = "none";
        }
      }
    }, {
      key: "populateDOM",
      value: function populateDOM(elem) {
        if (this.template !== null && this.template !== undefined) elem.innerHTML = this.template;
        if (this.element) this.element.style.display = "block";
        this.queryDOM(this.element);
      }
    }, {
      key: "clearDom",
      value: function clearDom(elem) {
        if (elem) elem.innerHTML = "";
      }
    }, {
      key: "queryDOM",
      value: function queryDOM() {
        var elem = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : document.body;
        // if(elem)
        if (this.viewports.length) return; // TODO?
        // Grab all viewports

        this.viewportElements = []; // Note: CocoonJS doesn't fully support querySelectorAll, so we're doing this manually, rather than querySelectorAll
        // Any <onyx-viewport> tags

        var nodes = elem.getElementsByTagName("onyx-viewport");

        for (var i = 0; i < nodes.length; i++) {
          // TODO(?): use this element to create a canvas inside of it
          this.viewportElements.push(nodes[i]);
        } // Any <ANY onyx-viewport> tags


        if (typeof document.querySelectorAll !== "undefined" && !navigator.isCocoonJS) {
          nodes = elem.querySelectorAll("[onyx-viewport]");

          for (var i = 0; i < nodes.length; i++) {
            this.viewportElements.push(nodes[i]);
          }
        } else {
          // Fallback for older browsers / CocoonJS
          nodes = elem.getElementsByTagName("*");

          for (var i = 0; i < nodes.length; i++) {
            var node = nodes[i];

            if (typeof node["onyx-viewport"] !== "undefined" || node.hasAttribute && node.hasAttribute("onyx-viewport")) {
              this.viewportElements.push(node);
            }
          }
        } // Assign a new viewport for each one


        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = this.viewportElements[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var _elem = _step.value;
            this.viewports.push(new Viewport(_elem));
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator["return"] != null) {
              _iterator["return"]();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
      }
    }, {
      key: "render",
      value: function render(dt) {
        if (!this.visible) return; // TODO: Update DOM elements

        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
          for (var _iterator2 = this.renderPasses[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var renderPass = _step2.value;
            var _iteratorNormalCompletion3 = true;
            var _didIteratorError3 = false;
            var _iteratorError3 = undefined;

            try {
              for (var _iterator3 = this.viewports[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                var viewport = _step3.value;
                renderPass.render(dt, this, viewport, [this], this.transform.localMatrix);
              }
            } catch (err) {
              _didIteratorError3 = true;
              _iteratorError3 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
                  _iterator3["return"]();
                }
              } finally {
                if (_didIteratorError3) {
                  throw _iteratorError3;
                }
              }
            }
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
              _iterator2["return"]();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }
      }
      /**
       * Called every logic cycle
       */

    }, {
      key: "update",
      value: function update(deltaTime) {
        _get(_getPrototypeOf(Scene.prototype), "update", this).call(this, deltaTime, this);

        if (!this.enabled) return;
        var _iteratorNormalCompletion4 = true;
        var _didIteratorError4 = false;
        var _iteratorError4 = undefined;

        try {
          for (var _iterator4 = this.entities[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
            var entity = _step4.value;
            entity.update(deltaTime, this);
          }
        } catch (err) {
          _didIteratorError4 = true;
          _iteratorError4 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion4 && _iterator4["return"] != null) {
              _iterator4["return"]();
            }
          } finally {
            if (_didIteratorError4) {
              throw _iteratorError4;
            }
          }
        }

        var _iteratorNormalCompletion5 = true;
        var _didIteratorError5 = false;
        var _iteratorError5 = undefined;

        try {
          for (var _iterator5 = this.removeEntities[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
            var _entity = _step5.value;
            this.remove(_entity, false);
          }
        } catch (err) {
          _didIteratorError5 = true;
          _iteratorError5 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion5 && _iterator5["return"] != null) {
              _iterator5["return"]();
            }
          } finally {
            if (_didIteratorError5) {
              throw _iteratorError5;
            }
          }
        }

        this.removeEntities = [];
      }
    }, {
      key: "add",
      value: function add(entity) {
        this.entities.push(entity);
        if (entity.onSpawn) entity.onSpawn(this);
        if (entity instanceof Camera) this.cameras.push(entity);

        if (entity instanceof Light || entity instanceof PointLight || entity instanceof SpotLight) {
          this.lights.push(entity);
          if (this.lights.length > CONST.MAX_LIGHTS) console.warn("[Onyx] Warning: Light count greater than MAX_LIGHTS.");
        }
      }
    }, {
      key: "addRenderPass",
      value: function addRenderPass(pass) {
        this.renderPasses.push(pass);
      }
    }, {
      key: "remove",
      value: function remove(entity, defer) {
        //TODO: make defer an option object?
        if (defer) {
          this.removeEntities.push(entity);
        } else {
          if (this.entities.indexOf(entity) > -1) {
            this.entities.splice(this.entities.indexOf(entity), 1);
            if (entity.onDestroy) entity.onDestroy(this);
            if (entity instanceof Camera) this.cameras.splice(this.cameras.indexOf(entity), 1);
          }
        }
      }
    }, {
      key: "findByIndex",
      value: function findByIndex(index) {
        _get(_getPrototypeOf(Scene.prototype), "findByIndex", this).call(this, index);

        for (var i = 0; i < this.entities.length; i++) {
          if (this.entities[i].index === index) return this.entities[i]; // TODO: Optimize

          if (this.entities[i].findByIndex(index)) return this.entities[i].findByIndex(index);
        }
      }
    }, {
      key: "start",
      value: function start() {
        if (!this.clock) return;
        this.clock.start(); // this.onload();
      }
    }, {
      key: "stop",
      value: function stop() {
        if (!this.clock) return;
        this.clock.stop(); // this.onunload();
      }
    }, {
      key: "sortEntitiesByZ",
      value: function sortEntitiesByZ(inverse) {
        if (inverse) {
          this.entities.sort(function (a, b) {
            return a.transform && b.transform && a.transform.z - b.transform.z;
          });
        } else {
          this.entities.sort(function (a, b) {
            return !a.transform || !b.transform || b.transform.z - a.transform.z;
          });
        }
      } // Fetch Template

    }, {
      key: "fetchTemplate",
      value: function fetchTemplate(url) {
        return fetch(url, {
          "Content-Type": "text/html"
        }).then(function (response) {
          // Read response
          if (!response.ok) {
            throw Error(response.statusText, response.url);
          }

          return response.text();
        }).then( // Return contents
        function (contents) {
          return contents;
        })["catch"](function (e) {
          console.error("Error fetching template '".concat(url, "'."), e); // this.loadView('__loadingFailure__');
        });
      }
    }]);

    return Scene;
  }(Entity);

  var tMatrix$5 = create$1();
  var FACE = [0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 0.0];
  var FACE_UVS = [0.0, 1.0, //  left,    top, 
  1.0, 1.0, // right,    top, 
  1.0, 0.0, // right, bottom, 
  0.0, 0.0, //  left, bottom, 
  0.0, 1.0, //  left,    top, 
  1.0, 0.0 // right, bottom, 
  ];
  var FACE_NORMALS = [0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0];
  var Sprite =
  /*#__PURE__*/
  function (_Component) {
    _inherits(Sprite, _Component);

    _createClass(Sprite, [{
      key: "src",
      get: function get() {
        return this._src;
      },
      set: function set(val) {
        var _this2 = this;

        if (!val) {
          this.textures = [];
          this.mesh.material.diffuseTexture = this.textures[0];
          this._src = val;
          return;
        }

        if (!Array.isArray(val)) val = [val];

        var _loop = function _loop(index) {
          var _iteratorNormalCompletion = true;
          var _didIteratorError = false;
          var _iteratorError = undefined;

          try {
            for (var _iterator = _this2.textures[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
              var texture = _step.value;
              if (texture.src == val) return {
                v: void 0
              };
            }
          } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion && _iterator["return"] != null) {
                _iterator["return"]();
              }
            } finally {
              if (_didIteratorError) {
                throw _iteratorError;
              }
            }
          }

          _this2.textures[index] = new Texture({
            src: val[index],
            flipY: false,
            magFilter: _this2._magFilter,
            minFilter: _this2._minFilter
          });
          _this2.mesh.material.diffuseTexture = _this2.textures[index]; // Note: this is just to tell shader that we're using textures

          _this2.mesh.material.buildProgram();

          _this2.textures[index].load().then(function () {
            _this2.fitToTexture(index); // TODO(?): Should select full frame by default?

          });
        };

        for (var index in val) {
          var _ret = _loop(index);

          if (_typeof(_ret) === "object") return _ret.v;
        }

        this._src = val;
        return val;
      }
    }, {
      key: "minFilter",
      get: function get() {
        return this._minFilter;
      },
      set: function set(val) {
        this._minFilter = val;
        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
          for (var _iterator2 = this.textures[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var texture = _step2.value;
            texture.minFilter = val;
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
              _iterator2["return"]();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }
      }
    }, {
      key: "magFilter",
      get: function get() {
        return this._magFilter;
      },
      set: function set(val) {
        this._magFilter = val;
        var _iteratorNormalCompletion3 = true;
        var _didIteratorError3 = false;
        var _iteratorError3 = undefined;

        try {
          for (var _iterator3 = this.textures[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
            var texture = _step3.value;
            texture.magFilter = val;
          }
        } catch (err) {
          _didIteratorError3 = true;
          _iteratorError3 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
              _iterator3["return"]();
            }
          } finally {
            if (_didIteratorError3) {
              throw _iteratorError3;
            }
          }
        }
      }
    }, {
      key: "pixelsPerUnit",
      get: function get() {
        return this._pixelsPerUnit;
      },
      set: function set(val) {
        if (!this.textures[0]) {
          this.mesh.vertices.set(new Float32Array(FACE));
          return;
        }

        var change = val / this._pixelsPerUnit;

        for (var i = 0; i < this.mesh.vertices.length; i++) {
          this.mesh.vertices[i] *= change;
        }

        this._pixelsPerUnit = val;
        this.mesh.invalidate(true);
        return this._pixelsPerUnit;
      }
    }]);

    function Sprite() {
      var _this;

      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref$src = _ref.src,
          src = _ref$src === void 0 ? "" : _ref$src,
          _ref$transform = _ref.transform,
          transform = _ref$transform === void 0 ? new Transform() : _ref$transform,
          _ref$textures = _ref.textures,
          textures = _ref$textures === void 0 ? [] : _ref$textures,
          _ref$material = _ref.material,
          material = _ref$material === void 0 ? null : _ref$material,
          _ref$magFilter = _ref.magFilter,
          magFilter = _ref$magFilter === void 0 ? "LINEAR" : _ref$magFilter,
          _ref$minFilter = _ref.minFilter,
          minFilter = _ref$minFilter === void 0 ? "LINEAR_MIPMAP_LINEAR" : _ref$minFilter,
          _ref$wrap = _ref.wrap,
          wrap = _ref$wrap === void 0 ? {
        s: "CLAMP_TO_EDGE",
        t: "CLAMP_TO_EDGE"
      } : _ref$wrap,
          _ref$flipX = _ref.flipX,
          flipX = _ref$flipX === void 0 ? false : _ref$flipX,
          _ref$flipY = _ref.flipY,
          flipY = _ref$flipY === void 0 ? false : _ref$flipY,
          _ref$pivot = _ref.pivot,
          pivot = _ref$pivot === void 0 ? [0, 0] : _ref$pivot,
          _ref$lighting = _ref.lighting,
          lighting = _ref$lighting === void 0 ? 0 : _ref$lighting,
          _ref$width = _ref.width,
          width = _ref$width === void 0 ? 0 : _ref$width,
          _ref$height = _ref.height,
          height = _ref$height === void 0 ? 0 : _ref$height,
          _ref$shadowCastingMod = _ref.shadowCastingMode,
          shadowCastingMode = _ref$shadowCastingMod === void 0 ? 1 : _ref$shadowCastingMod,
          _ref$pixelsPerUnit = _ref.pixelsPerUnit,
          pixelsPerUnit = _ref$pixelsPerUnit === void 0 ? 1 : _ref$pixelsPerUnit;

      _classCallCheck(this, Sprite);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(Sprite).apply(this, arguments));
      _this.transform = transform;
      _this._pixelsPerUnit = 1;
      _this.textures = textures;
      _this._minFilter = minFilter;
      _this._magFilter = magFilter;
      _this._wrap = wrap;
      _this._src = src;
      _this._materialIndex = 0;
      _this.flipX = flipX;
      _this.flipY = flipY;
      _this.pivot = pivot;
      _this.width = width;
      _this.height = height;
      _this.animations = {};

      if (!material) {
        material = new MaterialPhong({
          name: "SPRITE_" + src,
          lighting: lighting,
          shadowCastingMode: shadowCastingMode // diffuseTexture: this.texture

        });
      }

      _this.mesh = new Mesh({
        id: "MESH_SPRITE_" + _this.id,
        material: material,
        vertices: new Float32Array(FACE),
        uvs: new Float32Array(FACE_UVS),
        normals: new Float32Array(FACE_NORMALS),
        bufferUsage: {
          vertices: "DYNAMIC_DRAW",
          uvs: "DYNAMIC_DRAW",
          normals: "STATIC_DRAW",
          weights: "STATIC_DRAW",
          weightIndices: "STATIC_DRAW"
        }
      });

      if (!textures.length) {
        _this.src = src;
        _this.pixelsPerUnit = pixelsPerUnit;
      } else {
        _this.pixelsPerUnit = pixelsPerUnit;

        for (var index in textures) {
          _this.fitToTexture(index);
        }
      }

      return _this;
    }

    _createClass(Sprite, [{
      key: "loadTextures",
      value: function loadTextures(viewport) {
        var _this3 = this;

        var remaining = this.textures.length;
        return new Promise(function (resolve, reject) {
          var _iteratorNormalCompletion4 = true;
          var _didIteratorError4 = false;
          var _iteratorError4 = undefined;

          try {
            for (var _iterator4 = _this3.textures[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
              var texture = _step4.value;
              texture.load(viewport).then(function () {
                // If there are no remaining, resolve
                // Note: JS returns the previous value when doing ++ or --
                if (remaining-- === 1) resolve();
              });
            }
          } catch (err) {
            _didIteratorError4 = true;
            _iteratorError4 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion4 && _iterator4["return"] != null) {
                _iterator4["return"]();
              }
            } finally {
              if (_didIteratorError4) {
                throw _iteratorError4;
              }
            }
          }
        });
      }
    }, {
      key: "render",
      value: function render(dt, scene, viewport, camera, stack, viewMatrix, modelMatrix, materialOverride, frameBufferTextureStack) {
        stack.push(this); // Calculate view matrix

        mul(tMatrix$5, modelMatrix, this.transform.localMatrix);
        this.mesh.render(dt, scene, viewport, camera, stack, viewMatrix, tMatrix$5, materialOverride, frameBufferTextureStack);
        stack.pop();
      }
    }, {
      key: "update",
      value: function update(dt, scene, entity) {
        _get(_getPrototypeOf(Sprite.prototype), "update", this).call(this, dt, scene, entity);

        if (this.currentAnimation) this.currentAnimation.update(dt, scene, entity, this);
      }
    }, {
      key: "addAnimation",
      value: function addAnimation(animationId, animation) {
        this.animations[animationId] = animation;
        this.animations[animationId].id = animationId; //TODO: This part feels a little hacky

        animation.sprite = this;
      }
    }, {
      key: "playAnimation",
      value: function playAnimation(animationId, callback) {
        if (!this.animations[animationId]) return; //console.warn(`Animation '${animationId}' not found`);

        this.currentAnimation = this.animations[animationId];
        this.currentAnimation.play(callback);
      }
    }, {
      key: "selectAnimation",
      value: function selectAnimation(animationId) {
        var frame = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        if (!this.animations[animationId]) return; //console.warn(`Animation '${animationId}' not found`);

        this.currentAnimation = this.animations[animationId];
        this.currentAnimation.setFrame(frame);
      }
    }, {
      key: "fitToTexture",
      value: function fitToTexture() {
        var textureIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
        this.selectFrame(0, 0, this.textures[textureIndex].width, this.textures[textureIndex].height, this.pivot[0], this.pivot[1], textureIndex, true);
      }
    }, {
      key: "selectFrame",
      value: function selectFrame() {
        var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
        var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
        var width = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
        var height = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
        var pivotX = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : this.pivot[0];
        var pivotY = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : this.pivot[1];
        var materialIndex = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : 0;
        var forceVertexUpdate = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : false;
        this._materialIndex = materialIndex;
        this.mesh.material.diffuseTexture = this.textures[materialIndex];
        var texture = this.mesh.material.diffuseTexture;
        if (!texture) return;
        var left = x / texture.width;
        var right = (x + width) / texture.width;
        var bottom = y / texture.height;
        var top = (y + height) / texture.height;

        if (this.flipX) {
          var _ref2 = [right, left];
          left = _ref2[0];
          right = _ref2[1];
        }

        if (this.flipY) {
          var _ref3 = [bottom, top];
          top = _ref3[0];
          bottom = _ref3[1];
        }

        this.mesh.uvs.set([left, top, right, top, right, bottom, left, bottom, left, top, right, bottom]); // Set vertices
        // if(pivotX !== this.pivot[0] || pivotX !== this.pivot[1]){
        // 	let offsetX = width * pivotX;
        // 	let offsetY = height * pivotY;
        // 	this.mesh.vertices[0] = -offsetX;
        // 	this.mesh.vertices[3] =  offsetX;
        // 	this.mesh.vertices[6] =  offsetX;
        // 	this.mesh.vertices[9] = -offsetX;
        // 	this.mesh.vertices[12] = -offsetX;
        // 	this.mesh.vertices[15] =  offsetX;
        // 	this.mesh.vertices[1] = -offsetY;
        // 	this.mesh.vertices[4] = -offsetY;
        // 	this.mesh.vertices[7] =  offsetY;
        // 	this.mesh.vertices[10] =  offsetY;
        // 	this.mesh.vertices[13] = -offsetY;
        // 	this.mesh.vertices[16] =  offsetY;
        // 	this.mesh.invalidate(true, true);

        width = width * this._pixelsPerUnit;
        height = height * this._pixelsPerUnit;

        if (width != this.width || height != this.height || forceVertexUpdate) {
          this.mesh.vertices[0] = FACE[0] * width + -pivotX * width; // - (offsetX * this._pixelsPerUnit);

          this.mesh.vertices[3] = FACE[3] * width + -pivotX * width; // - (offsetX * this._pixelsPerUnit);

          this.mesh.vertices[6] = FACE[6] * width + -pivotX * width; // - (offsetX * this._pixelsPerUnit);

          this.mesh.vertices[9] = FACE[9] * width + -pivotX * width; // - (offsetX * this._pixelsPerUnit);

          this.mesh.vertices[12] = FACE[12] * width + -pivotX * width; // - (offsetX * this._pixelsPerUnit);

          this.mesh.vertices[15] = FACE[15] * width + -pivotX * width; // - (offsetX * this._pixelsPerUnit);

          this.mesh.vertices[1] = FACE[1] * height + -pivotY * height;
          this.mesh.vertices[4] = FACE[4] * height + -pivotY * height;
          this.mesh.vertices[7] = FACE[7] * height + -pivotY * height;
          this.mesh.vertices[10] = FACE[10] * height + -pivotY * height;
          this.mesh.vertices[13] = FACE[13] * height + -pivotY * height;
          this.mesh.vertices[16] = FACE[16] * height + -pivotY * height;
          this.mesh.invalidate(true, true, false, false, false);
        } else {
          this.mesh.invalidate(false, true, false, false, false);
        }

        this.width = width;
        this.height = height;
        this.pivot = [pivotX, pivotY];
      }
    }]);

    return Sprite;
  }(Component);

  var SpriteAnimation =
  /*#__PURE__*/
  function () {
    function SpriteAnimation() {
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref$id = _ref.id,
          id = _ref$id === void 0 ? "" : _ref$id,
          _ref$loop = _ref.loop,
          loop = _ref$loop === void 0 ? true : _ref$loop,
          _ref$frames = _ref.frames,
          frames = _ref$frames === void 0 ? [] : _ref$frames;

      var sprite = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      _classCallCheck(this, SpriteAnimation);

      this.id = id;
      this.sprite = sprite;
      this.frames = [];
      this.state = 0;
      this.loop = loop;
      this.currentTime = 0;
      this.currentFrame = null;
      this.currentFrameIndex = 0;
      this.callback = null;
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = frames[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var frame = _step.value;
          this.addFrame(frame);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
            _iterator["return"]();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }

    _createClass(SpriteAnimation, [{
      key: "update",
      value: function update(dt, scene, entity, sprite) {
        if (!this.state) return;
        var speed = this.currentFrame.speed || 0;

        if (this.currentTime + dt > speed) {
          var prevFrame = this.currentFrame; // Advance frame index

          this.currentFrameIndex++;

          if (!this.frames[this.currentFrameIndex]) {
            if (this.callback) this.callback();
            if (this.onComplete) this.onComplete();

            if (this.loop) {
              this.currentFrameIndex = 0;
            } else {
              this.state = 0;
              if (prevFrame.onComplete) prevFrame.onComplete();
              return;
            }
          } // Assign frame


          this.setFrame();
          if (prevFrame.onComplete) prevFrame.onComplete();
          if (this.currentFrame.onStart) this.currentFrame.onStart(); // Clear

          this.currentTime = 0;
        }

        this.currentTime += dt;
      }
    }, {
      key: "pause",
      value: function pause() {
        var val = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.state ? 0 : 1;
        this.state = val;
      }
    }, {
      key: "play",
      value: function play() {
        var callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
        var loop = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.loop;
        this.state = 1;
        this.loop = loop;
        this.callback = callback;
        this.reset();
        this.setFrame();
      }
    }, {
      key: "reset",
      value: function reset() {
        var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
        this.currentTime = 0;
        this.currentFrame = this.frames[frameIndex];
        this.currentFrameIndex = frameIndex;
      }
    }, {
      key: "addFrame",
      value: function addFrame() {
        var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
            _ref2$name = _ref2.name,
            name = _ref2$name === void 0 ? "" : _ref2$name,
            _ref2$x = _ref2.x,
            x = _ref2$x === void 0 ? 0 : _ref2$x,
            _ref2$y = _ref2.y,
            y = _ref2$y === void 0 ? 0 : _ref2$y,
            _ref2$width = _ref2.width,
            width = _ref2$width === void 0 ? 0 : _ref2$width,
            _ref2$height = _ref2.height,
            height = _ref2$height === void 0 ? 0 : _ref2$height,
            _ref2$offsetX = _ref2.offsetX,
            offsetX = _ref2$offsetX === void 0 ? 0 : _ref2$offsetX,
            _ref2$offsetY = _ref2.offsetY,
            offsetY = _ref2$offsetY === void 0 ? 0 : _ref2$offsetY,
            _ref2$pivotX = _ref2.pivotX,
            pivotX = _ref2$pivotX === void 0 ? 0 : _ref2$pivotX,
            _ref2$pivotY = _ref2.pivotY,
            pivotY = _ref2$pivotY === void 0 ? 0 : _ref2$pivotY,
            _ref2$speed = _ref2.speed,
            speed = _ref2$speed === void 0 ? 0 : _ref2$speed,
            _ref2$materialIndex = _ref2.materialIndex,
            materialIndex = _ref2$materialIndex === void 0 ? 0 : _ref2$materialIndex;

        this.frames.push({
          name: name,
          x: x,
          y: y,
          width: width,
          height: height,
          pivotX: pivotX,
          pivotY: pivotY,
          offsetX: offsetX,
          offsetY: offsetY,
          speed: speed,
          materialIndex: materialIndex
        });
      }
    }, {
      key: "setFrame",
      value: function setFrame() {
        var frameIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.currentFrameIndex;
        this.currentTime = 0;
        this.currentFrame = this.frames[frameIndex];
        this.currentFrameIndex = frameIndex; // TODO: "this.sprite" feels a little hacky

        this.sprite.selectFrame(this.currentFrame.x, this.currentFrame.y, this.currentFrame.width, this.currentFrame.height, this.currentFrame.pivotX, this.currentFrame.pivotY, this.currentFrame.offsetX, this.currentFrame.offsetY, this.currentFrame.materialIndex);
      }
    }]);

    return SpriteAnimation;
  }();

  var tMat4 = create$1(); // const POSITION_RELATIVE = 0;
  // const POSITION_ABSOLUTE = 1;
  // const POSITION_FIXED = 2;

  var Transform =
  /*#__PURE__*/
  function () {
    /**
     * A representation of position, rotation and scale in 3D space
     * @param {Object} options
     * @param {Array} options.position
     * @param {Array} options.rotation
     * @param {Array} options.scale
     */
    function Transform() {
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref$position = _ref.position,
          position = _ref$position === void 0 ? [0, 0, 0, 1] : _ref$position,
          _ref$rotation = _ref.rotation,
          rotation = _ref$rotation === void 0 ? [0, 0, 0, 1] : _ref$rotation,
          _ref$scale = _ref.scale,
          scale = _ref$scale === void 0 ? [1, 1, 1] : _ref$scale;

      _classCallCheck(this, Transform);

      this.valid = {
        mat4: false,
        translation: false,
        rotation: false,
        rotationQuat: false,
        scale: false,
        inverse: false,
        inverseTransposed: false
      };
      this._temp = {
        mat4: create$1(),
        inverseMat4: create$1(),
        inverseTransposeMat4: create$1(),
        translation: fromValues(position[0] || 0, position[1] || 0, position[2] || 0, position[3] === undefined ? 1 : position[3]),
        rotation: fromValues(rotation[0] || 0, rotation[1] || 0, rotation[2] || 0, rotation[3] === undefined ? 1 : rotation[3]),
        rotationQuat: create$4(),
        //quat.fromValues(rotation[0] || 0, rotation[1] || 0, rotation[2] || 0, (rotation[3] === undefined)?1:rotation[3]),
        scale: fromValues(scale[0] === undefined ? 1 : scale[0], scale[1] === undefined ? 1 : scale[1], scale[2] === undefined ? 1 : scale[2])
      };
    }
    /**
     * The transform's local matrix.
     */


    _createClass(Transform, [{
      key: "invalidate",
      value: function invalidate() {
        this.valid = {
          mat4: false,
          translation: false,
          rotation: false,
          rotationQuat: false,
          scale: false,
          inverse: false,
          inverseTransposed: false
        };
      }
      /**
       * 
       * @param {Array} target 3-Dimensional array representing the point in space to look at
       * @param {Array} up 3-Dimensional vector representing up
       */

    }, {
      key: "targetTo",
      value: function targetTo$1(target) {
        var up = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [0, 1, 0];
        targetTo(tMat4, this.xyz, target, up);
        getRotation(this._temp.rotationQuat, tMat4);
        var x = this._temp.rotationQuat[0];
        var y = this._temp.rotationQuat[1];
        var z = this._temp.rotationQuat[2];
        var w = this._temp.rotationQuat[3];
        this.yaw = Math.atan2(2 * y * w - 2 * x * z, 1 - 2 * y * y - 2 * z * z);
        this.pitch = Math.atan2(2 * x * w - 2 * y * z, 1 - 2 * x * x - 2 * z * z);
        this.roll = Math.asin(2 * x * y + 2 * z * w);
        this.valid.mat4 = false;
        this.valid.rotation = false;
        this.valid.rotationQuat = false;
      }
      /**
       * 
       * @param {Array} target 3-Dimensional array representing the point in space to look at
       * @param {Array} up 3-Dimensional vector representing up
       */

    }, {
      key: "lookAt",
      value: function lookAt$1(target) {
        var up = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [0, 1, 0];
        lookAt(tMat4, this.xyz, target, up);
        getRotation(this._temp.rotationQuat, tMat4);
        var x = this._temp.rotationQuat[0];
        var y = this._temp.rotationQuat[1];
        var z = this._temp.rotationQuat[2];
        var w = this._temp.rotationQuat[3];
        this.yaw = Math.atan2(2 * y * w - 2 * x * z, 1 - 2 * y * y - 2 * z * z);
        this.pitch = Math.atan2(2 * x * w - 2 * y * z, 1 - 2 * x * x - 2 * z * z);
        this.roll = Math.asin(2 * x * y + 2 * z * w);
        this.valid.mat4 = false;
        this.valid.rotation = false;
        this.valid.rotationQuat = false;
      }
    }, {
      key: "orbitX",
      value: function orbitX(angle) {
        var origin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [0, 0, 0];
        rotateX(this._temp.translation, this._temp.translation, origin, angle);
        this.valid.mat4 = false;
        this.valid.inverse = false;
        this.valid.translation = false;
        this.valid.rotation = false;
        this.valid.rotationQuat = false;
      }
    }, {
      key: "orbitY",
      value: function orbitY(angle) {
        var origin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [0, 0, 0];
        rotateY(this._temp.translation, this._temp.translation, origin, angle);
        this.valid.mat4 = false;
        this.valid.inverse = false;
        this.valid.translation = false;
        this.valid.rotation = false;
        this.valid.rotationQuat = false;
      }
    }, {
      key: "orbitZ",
      value: function orbitZ(angle) {
        var origin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [0, 0, 0];
        rotateZ(this._temp.translation, this._temp.translation, origin, angle);
        this.valid.mat4 = false;
        this.valid.inverse = false;
        this.valid.translation = false;
        this.valid.rotation = false;
        this.valid.rotationQuat = false;
      }
    }, {
      key: "localMatrix",
      get: function get() {
        if (!this.valid.mat4) {
          fromRotationTranslationScale(this._temp.mat4, this.rotationQuat, this._temp.translation, this._temp.scale);
          this.valid.mat4 = true;
        }

        return this._temp.mat4;
      },
      set: function set(value) {
        this._temp.mat4 = value;
        this.invalidate();
        this.valid.mat4 = true;
      }
      /**
       * The transform's local matrix inversed.
       */

    }, {
      key: "localMatrixInversed",
      get: function get() {
        if (!this.valid.inverse || !this.valid.mat4) {
          invert(this._temp.inverseMat4, this.localMatrix);
          this.valid.inverse = true;
        }

        return this._temp.inverseMat4;
      }
      /**
       * The transform's local matrix inversed and transposed.
       */

    }, {
      key: "localMatrixInversedTransposed",
      get: function get() {
        if (!this.valid.inverseTransposed || !this.valid.inverse || !this.valid.mat4) {
          transpose(this._temp.inverseTransposeMat4, this.localMatrixInversed);
          this.valid.inverseTransposed = true;
        }

        return this._temp.inverseTransposeMat4;
      }
    }, {
      key: "rotationQuat",
      get: function get() {
        if (!this.valid.rotationQuat) {
          fromEuler(this._temp.rotationQuat, this._temp.rotation[0] * (180 / Math.PI), this._temp.rotation[1] * (180 / Math.PI), this._temp.rotation[2] * (180 / Math.PI));
          this.valid.rotationQuat = true;
          this.valid.mat4 = false;
        }

        return this._temp.rotationQuat;
      },
      set: function set(value) {
        this._temp.rotationQuat = value;
        this.valid.rotationQuat = true;
      } // TODO
      // get rotation(){
      // 	if(!this.valid.rotationQuat){
      // 		quat.fromEuler(this._temp.rotationQuat, this._temp.rotation[0] * (180 / Math.PI), this._temp.rotation[1] * (180 / Math.PI), this._temp.rotation[2] * (180 / Math.PI));
      // 		this.valid.rotationQuat = true;
      // 		this.valid.mat4 = false;
      // 	}
      // 	return this._temp.rotationQuat;
      // }

    }, {
      key: "rotation",
      set: function set(value) {
        this._temp.rotation = value;
        this.valid.rotation = true;
        this.valid.rotationQuat = false;
      }
      /**
       * Translation's X component
       */

    }, {
      key: "x",
      get: function get() {
        if (!this.valid.translation) {
          getTranslation(this._temp.translation, this.localMatrix);
          this.valid.translation = true;
        }

        return this._temp.translation[0];
      }
      /**
       * Translation's Y component
       */
      ,
      set: function set(val) {
        if (this._temp.translation[0] === val) return val;
        this._temp.translation[0] = val;
        this.valid.mat4 = false;
        return val;
      }
    }, {
      key: "y",
      get: function get() {
        if (!this.valid.translation) {
          getTranslation(this._temp.translation, this.localMatrix);
          this.valid.translation = true;
        }

        return this._temp.translation[1];
      }
      /**
       * Translation's Z component
       */
      ,
      set: function set(val) {
        if (this._temp.translation[1] === val) return val;
        this._temp.translation[1] = val;
        this.valid.mat4 = false;
        return val;
      }
    }, {
      key: "z",
      get: function get() {
        if (!this.valid.translation) {
          getTranslation(this._temp.translation, this.localMatrix);
          this.valid.translation = true;
        }

        return this._temp.translation[2];
      }
      /**
       * Translation's XYZ components represented as an array
       */
      ,
      set: function set(val) {
        if (this._temp.translation[2] === val) return val;
        this._temp.translation[2] = val;
        this.valid.mat4 = false;
        return this._temp.translation[2];
      }
    }, {
      key: "xyz",
      get: function get() {
        if (!this.valid.translation) {
          getTranslation(this._temp.translation, this.localMatrix);
          this.valid.translation = true;
        }

        return this._temp.translation;
      },
      set: function set(val) {
        if (this._temp.translation[0] === val[0] && this._temp.translation[1] === val[1] && this._temp.translation[2] === val[2]) return val;
        this._temp.translation[0] = val[0];
        this._temp.translation[1] = val[1];
        this._temp.translation[2] = val[2];
        this.valid.mat4 = false;
        return this._temp.translation;
      }
    }, {
      key: "sx",
      get: function get() {
        if (!this.valid.scale) {
          getScaling(this._temp.scale, this.localMatrix);
          this.valid.scale = true;
        }

        return this._temp.scale[0];
      },
      set: function set(val) {
        if (this._temp.scale[0] === val) return val;
        this._temp.scale[0] = val;
        this.valid.mat4 = false;
        return this._temp.scale[0];
      }
    }, {
      key: "sy",
      get: function get() {
        if (!this.valid.scale) {
          getScaling(this._temp.scale, this.localMatrix);
          this.valid.scale = true;
        }

        return this._temp.scale[1];
      },
      set: function set(val) {
        if (this._temp.scale[1] === val) return val;
        this._temp.scale[1] = val;
        this.valid.mat4 = false;
        return this._temp.scale[1];
      }
    }, {
      key: "sz",
      get: function get() {
        if (!this.valid.scale) {
          getScaling(this._temp.scale, this.localMatrix);
          this.valid.scale = true;
        }

        return this._temp.scale[2];
      },
      set: function set(val) {
        if (this._temp.scale[2] === val) return val;
        this._temp.scale[2] = val;
        this.valid.mat4 = false;
        return this._temp.scale[2];
      }
    }, {
      key: "sxyz",
      get: function get() {
        if (!this.valid.scale) {
          getScaling(this._temp.scale, this.localMatrix);
          this.valid.scale = true;
        }

        return this._temp.scale;
      },
      set: function set(val) {
        if (this._temp.scale[0] === val[0] && this._temp.scale[1] === val[1] && this._temp.scale[2] === val[2]) return val;
        this._temp.scale[0] = val[0];
        this._temp.scale[1] = val[1];
        this._temp.scale[2] = val[2];
        this.valid.mat4 = false;
        return this._temp.scale;
      }
    }, {
      key: "pitch",
      get: function get() {
        if (!this.valid.rotation) {
          getRotation(this._temp.rotation, this.localMatrix);
          this.valid.rotation = true;
        }

        return this._temp.rotation[0];
      },
      set: function set(val) {
        if (this._temp.rotation[0] === val) return val;
        this._temp.rotation[0] = val;
        this.valid.rotationQuat = false;
        this.valid.mat4 = false;
        return this._temp.rotation[0];
      }
    }, {
      key: "yaw",
      get: function get() {
        if (!this.valid.rotation) {
          getRotation(this._temp.rotation, this.localMatrix);
          this.valid.rotation = true;
        }

        return this._temp.rotation[1];
      },
      set: function set(val) {
        if (this._temp.rotation[1] === val) return val;
        this._temp.rotation[1] = val;
        this.valid.rotationQuat = false;
        this.valid.mat4 = false;
        return this._temp.rotation[1];
      }
    }, {
      key: "roll",
      get: function get() {
        if (!this.valid.rotation) {
          getRotation(this._temp.rotation, this.localMatrix);
          this.valid.rotation = true;
        }

        return this._temp.rotation[2];
      },
      set: function set(val) {
        if (this._temp.rotation[2] === val) return val;
        this._temp.rotation[2] = val;
        this.valid.rotationQuat = false;
        this.valid.mat4 = false;
        return this._temp.rotation[2];
      }
    }]);

    return Transform;
  }();

  var tMatrix$6 = create$1();

  var Timer =
  /*#__PURE__*/
  function (_Entity) {
    _inherits(Timer, _Entity);

    function Timer() {
      var _this;

      _classCallCheck(this, Timer);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(Timer).call(this));
      _this.currentTime = 0;
      _this.interval = 0;
      _this.currentIntervalCount = 0;
      _this.intervalCount = -1;
      _this.mode = "timeout";
      _this.direction = 1;
      _this.enabled = true;

      _this.callback = function () {};

      return _this;
    }

    _createClass(Timer, [{
      key: "update",
      value: function update(dt, scene) {
        if (!this.enabled) return;
        this.currentTime += dt * this.direction;

        switch (this.mode) {
          case "timeout":
            if (this.currentTime > this.interval) {
              this.callback(scene);
              this.enabled = false;
            }

            break;

          case "interval":
            if (this.currentTime > this.interval) {
              this.currentTime = 0 + (this.currentTime - this.interval); // Carry over the remainder

              this.callback(scene);
              this.currentIntervalCount++;

              if (this.intervalCount > 0 && this.currentIntervalCount >= this.intervalCount) {
                this.enabled = false;
              }
            }

            break;

          case "modulate":
            if (this.currentTime > this.interval) {
              this.currentTime = this.interval - (this.currentTime - this.interval);
              this.direction = -1;
              this.currentIntervalCount++;
            } else if (this.currentTime < 0) {
              this.currentTime = 0 - this.currentTime;
              this.direction = 1;
              this.currentIntervalCount++;
            }

            this.callback(dt, this.currentTime / this.interval, this.currentIntervalCount);
            break;
        }
      }
    }, {
      key: "setTimeout",
      value: function setTimeout(callback) {
        var interval = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        this.interval = interval;
        this.callback = callback;
        this.mode = "timeout";
        this.currentTime = 0;
        this.enabled = true;
      }
    }, {
      key: "setInterval",
      value: function setInterval(callback) {
        var interval = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        var count = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
        this.interval = interval;
        this.intervalCount = count;
        this.callback = callback;
        this.mode = "interval";
        this.currentTime = 0;
        this.currentIntervalCount = 0;
        this.enabled = true;
      }
    }, {
      key: "setModulate",
      value: function setModulate(callback) {
        var interval = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        this.interval = interval;
        this.callback = callback;
        this.mode = "modulate";
        this.currentTime = 0;
        this.currentIntervalCount = 0;
        this.enabled = true;
      }
    }, {
      key: "restart",
      value: function restart() {
        this.currentTime = 0;
      }
    }]);

    return Timer;
  }(Entity);

  var EasingFunctions = {
    // no easing, no acceleration
    linear: function linear(t) {
      return t;
    },
    // accelerating from zero velocity
    easeIn: function easeIn(t) {
      return -Math.cos(t * Math.PI) / 2 + 0.5;
    },
    // accelerating from zero velocity
    easeInQuad: function easeInQuad(t) {
      return t * t;
    },
    // decelerating to zero velocity
    easeOutQuad: function easeOutQuad(t) {
      return t * (2 - t);
    },
    // acceleration until halfway, then deceleration
    easeInOutQuad: function easeInOutQuad(t) {
      return t < .5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
    },
    // accelerating from zero velocity 
    easeInCubic: function easeInCubic(t) {
      return t * t * t;
    },
    // decelerating to zero velocity 
    easeOutCubic: function easeOutCubic(t) {
      return --t * t * t + 1;
    },
    // acceleration until halfway, then deceleration 
    easeInOutCubic: function easeInOutCubic(t) {
      return t < .5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;
    },
    // accelerating from zero velocity 
    easeInQuart: function easeInQuart(t) {
      return t * t * t * t;
    },
    // decelerating to zero velocity 
    easeOutQuart: function easeOutQuart(t) {
      return 1 - --t * t * t * t;
    },
    // acceleration until halfway, then deceleration
    easeInOutQuart: function easeInOutQuart(t) {
      return t < .5 ? 8 * t * t * t * t : 1 - 8 * --t * t * t * t;
    },
    // accelerating from zero velocity
    easeInQuint: function easeInQuint(t) {
      return t * t * t * t * t;
    },
    // decelerating to zero velocity
    easeOutQuint: function easeOutQuint(t) {
      return 1 + --t * t * t * t * t;
    },
    // acceleration until halfway, then deceleration 
    easeInOutQuint: function easeInOutQuint(t) {
      return t < .5 ? 16 * t * t * t * t * t : 1 + 16 * --t * t * t * t * t;
    },
    // elastic bounce effect at the end
    easeInElastic: function easeInElastic(t) {
      return (.04 - .04 / t) * Math.sin(25 * t) + 1;
    },
    // elastic bounce effect at the beginning
    easeOutElastic: function easeOutElastic(t) {
      return .04 * t / --t * Math.sin(25 * t);
    },
    // elastic bounce effect at the beginning and end
    easeInOutElastic: function easeInOutElastic(t) {
      return (t -= .5) < 0 ? (.02 + .01 / t) * Math.sin(50 * t) : (.02 - .01 / t) * Math.sin(50 * t) + 1;
    }
  };
  var Tween =
  /*#__PURE__*/
  function (_Component) {
    _inherits(Tween, _Component);

    function Tween() {
      var _this;

      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          propParent = _ref.propParent,
          property = _ref.property,
          to = _ref.to,
          from = _ref.from,
          duration = _ref.duration,
          direction = _ref.direction,
          callback = _ref.callback,
          _ref$method = _ref.method,
          method = _ref$method === void 0 ? "linear" : _ref$method,
          _ref$onUpdate = _ref.onUpdate,
          onUpdate = _ref$onUpdate === void 0 ? function () {} : _ref$onUpdate;

      _classCallCheck(this, Tween);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(Tween).call(this));

      _this.set(propParent, property, to, from, duration, direction, callback, method, onUpdate);

      return _this;
    }

    _createClass(Tween, [{
      key: "update",
      value: function update(dt, scene, entity) {
        if (!this.enabled || this.percentComplete === 1) return;
        this.currentTime += dt * this.direction;
        this.percentComplete = Math.min(this.currentTime / this.duration, 1);

        if (this.percentComplete === 1 && this.callback) {
          this.propParent[this.property] = this.to;
          this.callback();
        } else {
          this.propParent[this.property] = this.from + (this.to - this.from) * this.method(this.percentComplete);
          this.onUpdate(this.propParent[this.property]);
        }
      }
    }, {
      key: "set",
      value: function set(propParent, property, to, from, duration) {
        var direction = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 1;
        var callback = arguments.length > 6 ? arguments[6] : undefined;
        var method = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : "linear";
        var onUpdate = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : function () {};
        this.duration = duration;
        this.direction = direction;
        this.propParent = propParent;
        this.property = property;
        this.from = from;
        this.to = to;
        this.callback = callback;
        this.onUpdate = onUpdate;
        this.method = EasingFunctions[method];
        this.currentTime = 0;
        this.percentComplete = 0;
        if (from === undefined && propParent) from = propParent[property];
      }
    }, {
      key: "linear",
      value: function linear(propParent, property, to) {
        var from = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : propParent[prop];
        var duration = arguments.length > 4 ? arguments[4] : undefined;
        var callback = arguments.length > 5 ? arguments[5] : undefined;
        this.set(propParent, property, to, from, duration, callback, "linear");
      }
    }, {
      key: "easeIn",
      value: function easeIn(propParent, property, to) {
        var from = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : propParent[prop];
        var duration = arguments.length > 4 ? arguments[4] : undefined;
        var callback = arguments.length > 5 ? arguments[5] : undefined;
        this.set(propParent, property, to, from, duration, callback, "easeIn");
      }
    }]);

    return Tween;
  }(Component);

  var id = 0;
  var viewMatrix$1 = create$1();
  var Viewport =
  /*#__PURE__*/
  function () {
    _createClass(Viewport, [{
      key: "clearColor",
      get: function get() {
        return this._clearColor;
      },
      set: function set(value) {
        this._clearColor = value;
        this.webgl.clearColor(this._clearColor.color[0], this._clearColor.color[1], this._clearColor.color[2], this._clearColor.color[3]);
        return this._clearColor;
      }
    }, {
      key: "width",
      get: function get() {
        return this.contextElement.clientWidth * this.getDevicePixelRatio(this.webgl);
      }
    }, {
      key: "height",
      get: function get() {
        return this.contextElement.clientHeight * this.getDevicePixelRatio(this.webgl);
      }
    }]);

    function Viewport(contextElement) {
      var _this = this;

      var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
          _ref$listenForMouseEv = _ref.listenForMouseEvents,
          listenForMouseEvents = _ref$listenForMouseEv === void 0 ? false : _ref$listenForMouseEv;

      _classCallCheck(this, Viewport);

      this._currentTexture = [];
      this.id = id++;
      this.mouseEventViewport = null;
      this.mouseEventRadius = 1.0;
      this.mouseEventRenderPick = true;
      this.mouseEventHover = false;
      this.materialClick = new MaterialClick();
      this.camera = null;
      this.contextElement = contextElement;
      this._clearColor = new Color(0, 0, 0, 1);
      this.clearOnRender = true;
      this.programs = [];
      this.program = null;
      this.enabledExtensions = {};
      this.frameBufferTextures = [];
      this.sceneListenEvents = {};
      this._prerenderCalls = []; // TODO: This should live at the camera

      this.projectionMatrix = create$1(); // TODO: move getAttributes to params + update scene.js
      // this._projectionType = contextElement.getAttribute("projection-type") || "Perspective";
      // this._nearPlane = (contextElement.getAttribute("nearplane") * 1) || 0;
      // this._farPlane = (contextElement.getAttribute("farplane") * 1) || 1000.0;

      this.orthoWidth = contextElement.getAttribute("ortho-width") * 1 || 0;
      this.orthoHeight = contextElement.getAttribute("ortho-height") * 1 || 0;
      this.parallax = contextElement.getAttribute("parallax") == "true"; // Initialize WebGL

      if (!window.WebGLRenderingContext) throw new Error("[Onyx] WebGL is not supported by this browser."); // WebGL Options

      var webglOptions = {
        alpha: true,
        antialias: true,
        depth: true,
        failIfMajorPerformanceCaveat: false,
        powerPreference: "default",
        premultipliedAlpha: true,
        preserveDrawingBuffer: true,
        stencil: true // Read from HTML tag

      };
      if (contextElement.getAttribute("alpha") == 'false') webglOptions.alpha = false;
      if (contextElement.getAttribute("antialias") == 'false') webglOptions.antialias = false;
      if (contextElement.getAttribute("depth") == 'false') webglOptions.depth = false;
      if (contextElement.getAttribute("fail-if-major-performance-caveat") == 'true') webglOptions.failIfMajorPerformanceCaveat = true;
      if (contextElement.getAttribute("power-preference")) webglOptions.powerPreference = contextElement.getAttribute("powerPreference");
      if (contextElement.getAttribute("premultiplied-alpha") == 'false') webglOptions.premultipliedAlpha = false;
      if (contextElement.getAttribute("preserve-drawing-buffer") == 'false') webglOptions.preserveDrawingBuffer = false;
      if (contextElement.getAttribute("stencil") == 'false') webglOptions.stencil = false;

      try {
        this.webgl = contextElement.getContext("webgl", webglOptions) || contextElement.getContext("experimental-webgl", webglOptions);
        this.webgl.id = this.id;
      } catch (e) {
        contextElement.classList.add("webgl-issue-initialization");
        throw new Error("[Onyx] Couldn't initialize WebGL");
      }

      if (!this.webgl) {
        contextElement.classList.add("webgl-issue-disabled");
        throw new Error("[Onyx] WebGL appears to be disabled");
      } // Get the viewport ready...


      this.webgl.viewport(0, 0, contextElement.width, contextElement.height);
      this.webgl.clearColor(this._clearColor.color[0], this._clearColor.color[1], this._clearColor.color[2], this._clearColor.color[3]);
      this.webgl.blendFuncSeparate(this.webgl.SRC_ALPHA, this.webgl.ONE_MINUS_SRC_ALPHA, this.webgl.ZERO, this.webgl.ONE);
      this.projectionMatrix = create$1();

      if (!CONST.AVAILABLE_EXTENSIONS.length) {
        CONST.AVAILABLE_EXTENSIONS = this.webgl.getSupportedExtensions(); // console.log(CONST.AVAILABLE_EXTENSIONS);
      }

      this.enableExtension("OES_standard_derivatives"); // this.enableExtension("OES_texture_float");
      // this.enableExtension("OES_texture_float_linear");

      this.clear(); // Watch for changes

      window.addEventListener("resize", function () {
        _this.evaluate();
      });

      if (listenForMouseEvents) {
        this.listenForMouseEvents();
      }

      this.evaluate();
    }

    _createClass(Viewport, [{
      key: "clear",
      value: function clear() {
        // this.webgl.colorMask(true, true, true, true);
        this.webgl.clearColor(this._clearColor.color[0], this._clearColor.color[1], this._clearColor.color[2], this._clearColor.color[3]);
        this.webgl.clear(this.webgl.COLOR_BUFFER_BIT | this.webgl.DEPTH_BUFFER_BIT);
      }
    }, {
      key: "enableExtension",
      value: function enableExtension(extension) {
        if (!this.enabledExtensions[extension]) this.enabledExtensions[extension] = this.webgl.getExtension(extension);
        if (!this.enabledExtensions[extension]) console.warn("Extension \"".concat(extension, "\" not available."));
      }
    }, {
      key: "evaluate",
      value: function evaluate() {
        var clear = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

        if (clear) {
          var _devicePixelRatio = this.getDevicePixelRatio(this.webgl);

          if (!navigator.isCocoonJS) {
            if (this.contextElement.clientWidth && this.contextElement.clientHeight) {
              this.contextElement.width = this.contextElement.clientWidth * _devicePixelRatio;
              this.contextElement.height = this.contextElement.clientHeight * _devicePixelRatio;
            }
          } else {
            this.contextElement.width = window.innerWidth * _devicePixelRatio;
            this.contextElement.height = window.innerHeight * _devicePixelRatio;
          }
        } else {
          if (this.contextElement.clientWidth && this.contextElement.clientHeight) {
            if (this.contextElement.width !== this.contextElement.clientWidth * devicePixelRatio) this.contextElement.width = this.contextElement.clientWidth * devicePixelRatio;
            if (this.contextElement.height !== this.contextElement.clientHeight * devicePixelRatio) this.contextElement.height = this.contextElement.clientHeight * devicePixelRatio;
          }
        }

        this.webgl.viewport(0, 0, this.webgl.drawingBufferWidth, this.webgl.drawingBufferHeight);
        if (!this.camera) return; //TODO this should be at the camera level, along with FOV, etc.

        if (this.camera._projectionType.toLowerCase() == "orthographic") {
          // Solve width / height
          var width = this.orthoWidth;
          var height = this.orthoHeight;

          if (!width && !height) {
            width = this.contextElement.clientWidth;
            height = this.contextElement.clientHeight;
          } else {
            var aspect = this.webgl.drawingBufferWidth / this.webgl.drawingBufferHeight;

            if (!width) {
              width = height * aspect;
            } else if (!height) {
              height = width / aspect;
            }
          } // this.width = width;
          // this.height = height;


          ortho(this.projectionMatrix, 0, width, 0, height, this.camera._nearPlane, this.camera._farPlane);
        } else {
          perspective(this.projectionMatrix, this.camera.fov, this.webgl.drawingBufferWidth / this.webgl.drawingBufferHeight, this.camera._nearPlane, this.camera._farPlane);
        }
      }
    }, {
      key: "getDevicePixelRatio",
      value: function getDevicePixelRatio(context) {
        // For hi-res displays-- For example, the Chromebook Pixel
        if (CONST.AUTO_DETECT_DEVICE_PIXEL_RATIO && 'devicePixelRatio' in window) {
          if (window.devicePixelRatio > 1) {
            // && context.webkitBackingStorePixelRatio < 2) {
            return window.devicePixelRatio;
          } else {
            return 1;
          }
        } else {
          return 1;
        }
      }
    }, {
      key: "render",
      value: function render(dt, scene, stack, matrix, materialOverride, frameBufferTextureStack) {
        if (!this.camera) return; // Fire any prerender calls

        while (this._prerenderCalls.length) {
          this._prerenderCalls[0]();

          this._prerenderCalls.splice(0, 1);
        } // if(this.clearOnRender) this.clear();
        // Calculate view matrix


        mul(viewMatrix$1, matrix, this.projectionMatrix);
        this.camera.render(dt, scene, this, stack, viewMatrix$1, materialOverride, frameBufferTextureStack); // this.camera.render(dt, scene, this, stack, viewMatrix, this.materialClick, frameBufferTextureStack);
        // Fixes flickering on some browsers (maybe?)
        // this.webgl.flush();
      }
    }, {
      key: "renderPick",
      value: function renderPick() {
        var dt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
        var scene = arguments.length > 1 ? arguments[1] : undefined;
        var stack = arguments.length > 2 ? arguments[2] : undefined;
        var matrix = arguments.length > 3 ? arguments[3] : undefined;
        var materialOverride = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : this.materialClick;
        var frameBufferTextureStack = arguments.length > 5 ? arguments[5] : undefined;
        var mouseX = arguments.length > 6 ? arguments[6] : undefined;
        var mouseY = arguments.length > 7 ? arguments[7] : undefined;
        var event = arguments.length > 8 ? arguments[8] : undefined;
        var radius = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : 1.0;
        var callback = arguments.length > 10 ? arguments[10] : undefined;
        if (!this.camera) return; // window.requestAnimationFrame(() => {
        // this.canvas2d.width = this.contextElement.width;
        // this.canvas2d.height = this.contextElement.height;
        // this.evaluate(true);
        // this.clear();

        this.mouseEventViewport.camera = this.camera;
        this.mouseEventViewport.contextElement.width = this.contextElement.width;
        this.mouseEventViewport.contextElement.height = this.contextElement.height;
        this.mouseEventViewport.orthoHeight = this.orthoHeight;
        this.mouseEventViewport.orthoWidth = this.orthoWidth;
        this.mouseEventViewport.evaluate(true);
        this.mouseEventViewport.canvas2d.width = this.mouseEventViewport.contextElement.width;
        this.mouseEventViewport.canvas2d.height = this.mouseEventViewport.contextElement.height;
        this.mouseEventViewport.webgl.clear(this.webgl.COLOR_BUFFER_BIT | this.webgl.DEPTH_BUFFER_BIT); // this.mouseEventViewport.clear();
        // this.mouseEventViewport.webgl.disable(this.webgl.GL_BLEND);
        // Calculate view matrix

        mul(viewMatrix$1, matrix, this.projectionMatrix);
        this.camera.render(dt, scene, this.mouseEventViewport, stack, viewMatrix$1, materialOverride, frameBufferTextureStack);

        if (event.offsetX === undefined) {
          var rect = this.contextElement.getBoundingClientRect();
          event.offsetX = mouseX;
          event.offsetY = mouseY;
        }

        radius = Math.max(radius | 0, 1);
        var devicePixelRatio = this.getDevicePixelRatio(this.webgl);
        mouseX *= devicePixelRatio;
        mouseY *= devicePixelRatio;
        mouseX -= radius / 2;
        mouseY -= radius / 2;
        mouseY = this.contextElement.height - mouseY;
        var rgbaData = new Uint8Array(radius * radius * 4); // this.webgl.readPixels(mouseX | 0, mouseY | 0, radius, radius, this.webgl.RGBA, this.webgl.UNSIGNED_BYTE, rgbaData);

        this.mouseEventViewport.webgl.readPixels(mouseX | 0, mouseY | 0, radius, radius, this.webgl.RGBA, this.webgl.UNSIGNED_BYTE, rgbaData);
        var scores = [];

        for (var i = 0; i < rgbaData.length; i += 4) {
          var index = rgbaData[i] + rgbaData[i + 1] * 255 - 1; // Find entity by RGB data

          var _entity = this.camera.parentScene.findByIndex(index); // Add entity to the candidates list


          if (_entity) {
            if (!scores[index]) scores[index] = 0;
            scores[index]++;
          }
        }

        var largest = 0;
        var largestEntity = 0;

        for (var _i in scores) {
          if (scores[_i] > largest) {
            largest = scores[_i];
            largestEntity = _i * 1;
          }
        } // return;


        var entity = scene.findByIndex(largestEntity); // let entity = this.camera.parentScene.findByIndex(largestEntity);

        if (!entity) entity = scene;

        if (event.type === "mousedown" || event.type === "touchstart") {
          entity.onMouseDown(event);
        } else if (event.type === "mouseup" || event.type === "touchend") {
          entity.onMouseUp(event);
        } else if (event.type === "mousemove") {
          entity.onMouseOver(event);
        } else if (event.type === "mousedrop") {
          entity.onMouseDrop(event);
        } // Render again. TODO [Performance]: Fix
        // this.camera.render(dt, scene, this, stack, viewMatrix);


        if (callback) callback(); // });
      } // renderPickOld(dt = 0, scene, stack, matrix, materialOverride = this.materialClick, frameBufferTextureStack, mouseX, mouseY, event, radius = 1.0) {
      // 	if(!this.camera) return;
      // 	window.requestAnimationFrame(() => {
      // 		// let width = this.contextElement.offsetWidth || this.contextElement.width || this.contextElement.naturalWidth;
      // 		// let height = this.contextElement.offsetHeight || this.contextElement.height || this.contextElement.naturalHeight;
      // 		// mouseX *= devicePixelRatio;
      // 		// mouseY *= devicePixelRatio;
      // 		// if(this.camera._projectionType.toLowerCase() == "orthographic"){
      // 		// 	// Solve width / height
      // 		// 	width = this.orthoWidth;
      // 		// 	height = this.orthoHeight;
      // 		// 	if(!width && !height){
      // 		// 		width = this.contextElement.clientWidth;
      // 		// 		height = this.contextElement.clientHeight;
      // 		// 	}else{
      // 		// 		let aspect = this.webgl.drawingBufferWidth / this.webgl.drawingBufferHeight;
      // 		// 		if(!width){
      // 		// 			width = height * aspect;
      // 		// 		}else if(!height){
      // 		// 			height = width / aspect;
      // 		// 		}
      // 		// 	}
      // 		// }
      // 		// width /= devicePixelRatio;
      // 		// height /= devicePixelRatio;
      // 		// this.mouseEventViewport.camera = this.camera;
      // 		// this.mouseEventViewport.contextElement.width = width;
      // 		// this.mouseEventViewport.contextElement.height = height;
      // 		// this.mouseEventViewport.evaluate(true);
      // 		// this.mouseEventViewport.canvas2d.width = this.mouseEventViewport.contextElement.width;
      // 		// this.mouseEventViewport.canvas2d.height = this.mouseEventViewport.contextElement.height;
      // 		// this.mouseEventViewport.webgl.clear(this.webgl.COLOR_BUFFER_BIT | this.webgl.DEPTH_BUFFER_BIT);
      // 		// alert(this.contextElement.width || this.contextElement.naturalWidth);
      // 		this.canvas2d.width = this.contextElement.width;
      // 		this.canvas2d.height = this.contextElement.height;
      // 		this.evaluate(true);
      // 		this.clear();
      // 		// this.mouseEventViewport.clear();
      // 		// this.mouseEventViewport.webgl.disable(this.webgl.GL_BLEND);
      // 		// Calculate view matrix
      // 		mat4.mul(viewMatrix, matrix, this.projectionMatrix);
      // 		this.camera.render(dt, scene, this, stack, viewMatrix, materialOverride, frameBufferTextureStack);
      // 		// this.camera.render(dt, scene, this.mouseEventViewport, stack, viewMatrix, materialOverride, frameBufferTextureStack);
      // 		// this.camera.renderScenePick( dt, scene, this.mouseEventViewport, stack, viewMatrix, materialOverride, frameBufferTextureStack );
      // 		radius = Math.max(radius | 0, 1);
      // 		let devicePixelRatio = this.getDevicePixelRatio(this.webgl);
      // 		mouseX *= devicePixelRatio;
      // 		mouseY *= devicePixelRatio;
      // 		mouseX -= radius / 2;
      // 		mouseY -= radius / 2;
      // 		mouseY = this.contextElement.height - mouseY;
      // 		var rgbaData = new Uint8Array((radius * radius) * 4);
      // 		this.webgl.readPixels(mouseX | 0, mouseY | 0, radius, radius, this.webgl.RGBA, this.webgl.UNSIGNED_BYTE, rgbaData);
      // 		// Copy scene to 2D Canvas (TODO: Is this faster if we read from the webgl buffer?)
      // 		// this.mouseEventViewport.context2d.drawImage(this.mouseEventViewport.contextElement, 0, 0);
      // 		// // alert(this.mouseEventViewport.contextElement.width);
      // 		// let rgbaData = this.mouseEventViewport.context2d.getImageData(mouseX | 0, mouseY | 0, radius, radius).data;
      // 		// this.context2d.drawImage(this.contextElement, 0, 0);
      // 		// // alert(this.contextElement.width);
      // 		// let rgbaData = this.context2d.getImageData(mouseX | 0, mouseY | 0, radius, radius).data;
      // 		let scores = [];
      // 		for(let i = 0; i < rgbaData.length; i++){
      // 			// Find entity by RGB data
      // 			let entity = this.camera.parentScene.findByIndex(rgbaData[i] - 1);
      // 			// Add entity to the candidates list
      // 			if(entity){
      // 				let index = rgbaData[i] - 1;
      // 				if(!scores[index]) scores[index] = 0;
      // 				scores[index]++;
      // 			}
      // 		}
      // 		let largest = 0;
      // 		let largestEntity = 0;
      // 		for(let i in scores){
      // 			if(scores[i] > largest){
      // 				largest = scores[i];
      // 				largestEntity = i * 1;
      // 			}
      // 		}
      // 		// return;
      // 		// if(this.camera.parentScene.entities[largestEntity]) this.camera.parentScene.entities[largestEntity].emit('click', event);
      // 		if(this.camera.parentScene.findByIndex(largestEntity)) this.camera.parentScene.findByIndex(largestEntity).onMouseDown(event);
      // 	});
      // }

    }, {
      key: "createProgram",
      value: function createProgram(material) {
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = this.programs[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var _program = _step.value;

            if (_program.vertexShader == material.vertexShader && _program.fragmentShader == material.fragmentShader) {
              return _program;
            }
          } // Create a new program (if one doesn't already exist)

        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator["return"] != null) {
              _iterator["return"]();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }

        this.programs.push(new GLProgram(this));
        var program = this.programs[this.programs.length - 1]; // Compile shaders

        program.addVertexShader(this, material.vertexShader);
        program.addFragmentShader(this, material.fragmentShader); // Links the compiled shaders to the program

        this.webgl.linkProgram(program.program); // If creating the shader program failed, alert

        if (!this.webgl.getProgramParameter(program.program, this.webgl.LINK_STATUS)) {
          throw "Unable to initialize the shader program. " + this.webgl.getProgramInfoLog(program.program);
        } // Get attributes from shaders


        program.getAttributesFromShaders(this, material.shaderAttributes);
        program.getUniformLocations(this, material.shaderUniforms);
        return program;
      }
    }, {
      key: "useProgram",
      value: function useProgram(program) {
        if (this.program === program) return;
        this.program = program;
        this.program.use(this);
      }
    }, {
      key: "bindToCamera",
      value: function bindToCamera(camera) {
        this.camera = camera;
        camera.addViewport(this);
        this.evaluate();
      }
    }, {
      key: "listenForMouseEvents",
      value: function listenForMouseEvents() {
        var _this2 = this;

        var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
            _ref2$scene = _ref2.scene,
            scene = _ref2$scene === void 0 ? null : _ref2$scene,
            _ref2$mouseRadius = _ref2.mouseRadius,
            mouseRadius = _ref2$mouseRadius === void 0 ? 1.0 : _ref2$mouseRadius,
            _ref2$renderPick = _ref2.renderPick,
            renderPick = _ref2$renderPick === void 0 ? true : _ref2$renderPick,
            _ref2$mouseEventHover = _ref2.mouseEventHover,
            mouseEventHover = _ref2$mouseEventHover === void 0 ? false : _ref2$mouseEventHover;

        if (!scene) return;
        var videoBufferCanvas = document.createElement("canvas");
        this.mouseEventRadius = mouseRadius;
        this.mouseEventRenderPick = renderPick;
        this.mouseEventHover = mouseEventHover;
        var offsetX = 0;
        var offsetY = 0;
        var radius = 1;

        if (!this.mouseEventViewport) {
          // Initialize 2D
          try {
            this.mouseEventViewport = new Viewport(videoBufferCanvas);
            this.mouseEventViewport.canvas2d = document.createElement('canvas');
            this.mouseEventViewport.context2d = this.mouseEventViewport.canvas2d.getContext("2d");
            this.canvas2d = document.createElement('canvas');
            this.context2d = this.canvas2d.getContext("2d");
          } catch (e) {
            console.error("Couldn't initialize 2D");
          }
        } // Watch for mouse events


        var events = {
          "mousedown": function mousedown(event) {
            _this2._prerenderCalls.push(function () {
              offsetX = Math.round(event.offsetX);
              offsetY = Math.round(event.offsetY);
              radius = _this2.mouseEventRadius;

              if (_this2.mouseEventRenderPick) {
                _this2.renderPick(0, scene, [scene], scene.transform.localMatrix, undefined, undefined, offsetX, offsetY, event, radius);
              } else {
                scene.onMouseDown(event);
              }
            }); // event.preventDefault(); 

          },
          "touchstart": function touchstart(event) {
            _this2._prerenderCalls.push(function () {
              var rect = _this2.contextElement.getBoundingClientRect();

              offsetX = Math.round(event.targetTouches[0].pageX - rect.x);
              offsetY = Math.round(event.targetTouches[0].pageY - rect.y);
              radius = event.targetTouches[0].radiusX;

              if (_this2.mouseEventRenderPick) {
                _this2.renderPick(0, scene, [scene], scene.transform.localMatrix, undefined, undefined, offsetX, offsetY, event, radius);
              } else {
                scene.onMouseDown(event);
              }
            });

            event.preventDefault();
          },
          "mousemove": function mousemove(event) {
            offsetX = event.offsetX;
            offsetY = event.offsetY;
            if (_this2.mouseEventHover) _this2._prerenderCalls.push(function () {
              // scene.onMouseUp(event);
              _this2.renderPick(0, scene, [scene], scene.transform.localMatrix, undefined, undefined, offsetX, offsetY, event, radius);
            });
          },
          "touchmove": function touchmove(event) {
            var rect = _this2.contextElement.getBoundingClientRect();

            offsetX = Math.round(event.targetTouches[0].pageX - rect.x);
            offsetY = Math.round(event.targetTouches[0].pageY - rect.y);
            if (_this2.mouseEventHover) _this2._prerenderCalls.push(function () {
              // scene.onMouseUp(event);
              _this2.renderPick(0, scene, [scene], scene.transform.localMatrix, undefined, undefined, offsetX, offsetY, event, radius);
            });
          },
          "mouseup": function mouseup(event) {
            _this2._prerenderCalls.push(function () {
              // scene.onMouseUp(event);
              if (_this2.mouseEventRenderPick) {
                _this2.renderPick(0, scene, [scene], scene.transform.localMatrix, undefined, undefined, offsetX, offsetY, event, radius);
              } else {
                scene.onMouseUp(event);
              }
            }); // event.preventDefault(); 

          },
          "touchend": function touchend(event) {
            _this2._prerenderCalls.push(function () {
              // scene.onMouseUp(event);
              if (_this2.mouseEventRenderPick) {
                _this2.renderPick(0, scene, [scene], scene.transform.localMatrix, undefined, undefined, offsetX, offsetY, event, radius);
              } else {
                event.offsetX = offsetX;
                event.offsetY = offsetY;
                scene.onMouseUp(event);
              }
            });

            event.preventDefault();
          }
        };
        var eventKeys = Object.keys(events);
        this.__eventKeys = eventKeys; // TODO: Babel compile error if this is removed

        for (var _i2 = 0, _eventKeys = eventKeys; _i2 < _eventKeys.length; _i2++) {
          var event = _eventKeys[_i2];
          this.contextElement.addEventListener(event, events[event]);
        }

        this.sceneListenEvents[scene.id] = events;
      }
    }, {
      key: "removeMouseListenEvents",
      value: function removeMouseListenEvents(_ref3) {
        var scene = _ref3.scene;
        var events = this.sceneListenEvents[scene.id];
        if (!events) return;

        for (var _i3 = 0, _Object$keys = Object.keys(events); _i3 < _Object$keys.length; _i3++) {
          var event = _Object$keys[_i3];
          this.contextElement.removeEventListener(event, events[event]);
        }
      }
    }, {
      key: "addFrameBufferTexture",
      value: function addFrameBufferTexture(frameBufferTexture) {
        this.frameBufferTextures.push(frameBufferTexture);
      }
    }, {
      key: "removeFrameBufferTexture",
      value: function removeFrameBufferTexture(frameBufferTexture) {
        if (this.frameBufferTextures.indexOf(frameBufferTexture) > -1) this.frameBufferTextures.splice(this.frameBufferTextures.indexOf(frameBufferTexture), 1);
      }
    }]);

    return Viewport;
  }();

  var lightMVMatrix = create$1();
  var viewMatrix$2 = create$1();
  var RENDER_TO_SCREEN = false; // Render shadowmap to canvas/screen. Useful for debugging

  var RenderPassShadow =
  /*#__PURE__*/
  function (_RenderPass) {
    _inherits(RenderPassShadow, _RenderPass);

    function RenderPassShadow() {
      var _this;

      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref$renderPasses = _ref.renderPasses,
          _ref$width = _ref.width,
          width = _ref$width === void 0 ? 1024 : _ref$width,
          _ref$height = _ref.height,
          height = _ref$height === void 0 ? 1024 : _ref$height;

      _classCallCheck(this, RenderPassShadow);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(RenderPassShadow).apply(this, arguments));
      _this.width = width;
      _this.height = height;
      _this.frameBufferTextures = [];
      _this.material = new MaterialDepth();
      _this.materialSkinned = new MaterialDepthSkinned();
      return _this;
    }

    _createClass(RenderPassShadow, [{
      key: "render",
      value: function render(dt, scene, viewport, stack, matrix) {
        var frameBufferTextureStack = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : [];

        if (!CONST.DIRECTIONAL_SHADOWS_ENABLED && !CONST.POINT_SHADOWS_ENABLED) {
          var _iteratorNormalCompletion = true;
          var _didIteratorError = false;
          var _iteratorError = undefined;

          try {
            for (var _iterator = this.renderPasses[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
              var renderPass = _step.value;
              if (!RENDER_TO_SCREEN) renderPass.render(dt, scene, viewport, stack, matrix, frameBufferTextureStack);
            }
          } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion && _iterator["return"] != null) {
                _iterator["return"]();
              }
            } finally {
              if (_didIteratorError) {
                throw _iteratorError;
              }
            }
          }
        } else {
          var shadowCount = 0;

          if (CONST.DIRECTIONAL_SHADOWS_ENABLED) {
            if (!this.frameBufferTextures[shadowCount]) {
              this.frameBufferTextures[shadowCount] = new FrameBufferTexture2D({
                height: this.width,
                width: this.height,
                magFilter: "NEAREST",
                minFilter: "NEAREST",
                textureType: "TEXTURE_2D",
                flipY: true,
                wrap: {
                  s: "CLAMP_TO_EDGE",
                  t: "CLAMP_TO_EDGE"
                }
              });
            } // Bind frameBufferTexture


            this.frameBufferTextures[shadowCount].bind(viewport, 0, viewport.webgl.TEXTURE_2D);
            viewport.clear();
            viewport.webgl.clearColor(0, 0, 0, 0);
            viewport.webgl.clearDepth(1.0);
            viewport.webgl.clear(viewport.webgl.COLOR_BUFFER_BIT | viewport.webgl.DEPTH_BUFFER_BIT);
            var _iteratorNormalCompletion2 = true;
            var _didIteratorError2 = false;
            var _iteratorError2 = undefined;

            try {
              for (var _iterator2 = scene.entities[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                var entity = _step2.value;

                if (entity instanceof Camera === false && entity.visible) {
                  //TODO: Move this to entity?
                  if (entity.components[0] && entity.components[0].meshes && entity.components[0].meshes[0].material.skeletal) {
                    entity.render(dt, scene, viewport, scene.directionalLight, stack, viewMatrix$2, null, this.materialSkinned);
                  } else {
                    entity.render(dt, scene, viewport, scene.directionalLight, stack, viewMatrix$2, null, this.material);
                  }
                }
              } // Unbind frameBufferTexture

            } catch (err) {
              _didIteratorError2 = true;
              _iteratorError2 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
                  _iterator2["return"]();
                }
              } finally {
                if (_didIteratorError2) {
                  throw _iteratorError2;
                }
              }
            }

            this.frameBufferTextures[shadowCount].unbind(viewport);
            shadowCount++;
          }

          frameBufferTextureStack.push(this.frameBufferTextures);
          var _iteratorNormalCompletion4 = true;
          var _didIteratorError4 = false;
          var _iteratorError4 = undefined;

          try {
            for (var _iterator4 = this.renderPasses[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
              var _renderPass = _step4.value;
              if (!RENDER_TO_SCREEN) _renderPass.render(dt, scene, viewport, stack, matrix, frameBufferTextureStack);
            }
          } catch (err) {
            _didIteratorError4 = true;
            _iteratorError4 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion4 && _iterator4["return"] != null) {
                _iterator4["return"]();
              }
            } finally {
              if (_didIteratorError4) {
                throw _iteratorError4;
              }
            }
          }

          frameBufferTextureStack.pop();
        }
      }
    }]);

    return RenderPassShadow;
  }(RenderPass);

  var VERTEX_SHADER = "\n    #define TEXTURES_ENABLED\n\n    attribute vec3 aVertexPosition;\n\tattribute vec2 aTextureCoord;\n\n\tuniform mat4 uMVCPMatrix; // Model View Camera Projection Matrix\n    \n    varying float vDepth;\n\tvarying vec2 vTextureCoord;\n\n    void main(void) {\n        gl_Position = uMVCPMatrix * vec4(aVertexPosition, 1.0);\n\n        // Set texture coordinate\n        #ifdef TEXTURES_ENABLED\n            vTextureCoord = aTextureCoord;\n\t\t#endif\n    }\n";
  var FRAG_SHADER = "\n    #extension GL_OES_standard_derivatives: enable\n\n    #ifdef GL_FRAGMENT_PRECISION_HIGH\n        precision highp float;\n    #else\n        precision mediump float;\n    #endif\n\n    #define TEXTURES_ENABLED\n\n    uniform sampler2D uDiffuseTexture;\n    uniform float uEntityIndex;\n    \n\tvarying vec2 vTextureCoord;\n\n    vec2 packDepthVec2(const in float depth) {\n        const vec2 bitShift = vec2(255.0, 1.0);\n        const vec2 bitMask = vec2(0.0, 1.0 / 255.0);\n      \n        vec2 res = fract(depth * bitShift);\n        res -= res.xy * bitMask;\n      \n        return res;\n    }\n\n    vec3 packDepthVec3(const in float depth) {\n        const vec3 bitShift = vec3(255.0 * 255.0, 255.0, 1.0);\n        const vec3 bitMask = vec3(0.0, 1.0 / 255.0, 1.0 / 255.0);\n      \n        vec3 res = fract(depth * bitShift);\n        res -= res.xyz * bitMask;\n      \n        return res;\n    }\n\n    void main(void) {\n        // Packs normalized fragment's Z-Coordinate which is in [0,1] interval.\n        gl_FragColor = vec4(mod(uEntityIndex, 255.0) / 255.0, floor(uEntityIndex / 255.0) / 255.0, 1.0, 1.0);\n        // gl_FragColor = vec4(packDepthVec3(uEntityIndex), 1.0);\n\n        #ifdef TEXTURES_ENABLED\n            gl_FragColor.a = ceil(texture2D(uDiffuseTexture, vTextureCoord).a);\n        #endif\n        \n        if(gl_FragColor.a == 0.0) discard;\n    }\n";
  var MaterialClick =
  /*#__PURE__*/
  function (_Material) {
    _inherits(MaterialClick, _Material);

    function MaterialClick() {
      var _this;

      _classCallCheck(this, MaterialClick);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(MaterialClick).apply(this, arguments));
      _this.vertexShader = VERTEX_SHADER;
      _this.fragmentShader = FRAG_SHADER;
      _this.blend = true;
      _this.depthTest = true;
      _this.cullFace = false;
      return _this;
    }

    _createClass(MaterialClick, [{
      key: "render",
      value: function render(dt, scene, viewport, camera, stack, viewMatrix, modelMatrix, frameBufferTextureStack) {
        // Parent Entity
        // TODO: More accurately find parent entity
        var entity = stack[stack.length - 3];
        if (!entity.pointerEvents) return false;
        var entityIndex = entity.index;
        if (entityIndex < 0) return; // Set uniforms (uMVMatrix, etc...)

        _get(_getPrototypeOf(MaterialClick.prototype), "render", this).call(this, dt, scene, viewport, camera, stack, viewMatrix, modelMatrix, frameBufferTextureStack); // Parent material


        var parentMaterial = stack[stack.length - 1].material; // Set current textures

        if (parentMaterial.diffuseTexture) {
          if (parentMaterial.diffuseTexture.setAsTexture(viewport, 0, viewport.program.uniform.uDiffuseTexture) === false) return;
        }

        viewport.webgl.uniform1f(viewport.program.uniform.uEntityIndex, entityIndex + 1); // Enable transparency

        viewport.webgl.blendFunc(viewport.webgl.SRC_ALPHA, viewport.webgl.ONE_MINUS_SRC_ALPHA);
        viewport.webgl.enable(viewport.webgl.BLEND);
      }
    }]);

    return MaterialClick;
  }(Material);

  var VERTEX_SHADER$1 = "\n    attribute vec3 aVertexPosition;\n\n    uniform mat4 uLMVMatrix;\n    \n    varying float vDepth;\n\n    void main(void) {\n        gl_Position = uLMVMatrix * vec4(aVertexPosition, 1.0);\n\n        float zBuf = gl_Position.z / gl_Position.w;  // between -1 and 1\n        vDepth = 0.5 + (zBuf * 0.5);           // between 0 and 1\n    }\n";
  var FRAG_SHADER$1 = "\n    #extension GL_OES_standard_derivatives: enable\n\n    #ifdef GL_FRAGMENT_PRECISION_HIGH\n        precision highp float;\n    #else\n        precision mediump float;\n    #endif\n\n    #ifdef GL_OES_standard_derivatives\n        #define USE_SVM\n    #endif\n\n    varying float vDepth;\n\n    vec2 packDepthVec2(const in float depth) {\n        const vec2 bitShift = vec2(255.0, 1.0);\n        const vec2 bitMask = vec2(0.0, 1.0 / 255.0);\n      \n        vec2 res = fract(depth * bitShift);\n        res -= res.xy * bitMask;\n      \n        return res;\n    }\n\n    vec3 packDepthVec3(const in float depth) {\n        const vec3 bitShift = vec3(255.0 * 255.0, 255.0, 1.0);\n        const vec3 bitMask = vec3(0.0, 1.0 / 255.0, 1.0 / 255.0);\n      \n        vec3 res = fract(depth * bitShift);\n        res -= res.xyz * bitMask;\n      \n        return res;\n    }\n\n    vec4 packDepthVec4(const in float depth) {\n        const vec4 bitShift = vec4(255.0 * 255.0 * 255.0, 255.0 * 255.0, 255.0, 1.0);\n        const vec4 bitMask = vec4(0.0, 1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0);\n      \n        vec4 res = fract(depth * bitShift);\n        res -= res.xxyz * bitMask;\n      \n        return res;\n    }\n\n    void main(void) {\n        #ifdef USE_SVM\n            float depth2 = pow(vDepth, 2.0);\n\n            // approximate the spatial average of vDepth^2\n            float dx = dFdx(vDepth);\n            float dy = dFdy(vDepth);\n            float depth2Avg = depth2 + 0.25 * (dx*dx + dy*dy);\n\n            // depth saved in red and green channels while average depth^2 is\n            // stored in the blue and alpha channels\n            gl_FragColor = vec4(packDepthVec3(vDepth), depth2Avg);\n        #else\n            // Packs normalized fragment's Z-Coordinate which is in [0,1] interval.\n            \n            gl_FragColor = packDepthVec4(gl_FragCoord.z);\n        #endif\n    }\n";
  var MaterialDepth =
  /*#__PURE__*/
  function (_Material) {
    _inherits(MaterialDepth, _Material);

    function MaterialDepth() {
      var _this;

      _classCallCheck(this, MaterialDepth);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(MaterialDepth).apply(this, arguments));
      _this.vertexShader = VERTEX_SHADER$1;
      _this.fragmentShader = FRAG_SHADER$1;
      if (!CONST.SHADOWS_VSM_ENABLED) _this.fragmentShader = _this.fragmentShader.replace("#define USE_SVM", "");
      _this.blend = false;
      _this.cullFaceMode = "FRONT";
      return _this;
    }

    _createClass(MaterialDepth, [{
      key: "render",
      value: function render(dt, scene, viewport, light, stack, viewMatrix, modelMatrix) {
        // TODO: Pull in parent's material's diffuse texture (for sprite alpha)
        var parent = stack[stack.length - 1];
        if (!parent || !parent.material.shadowCastingMode) return false; // TODO: Might need to move this if we're using depth for something else

        _get(_getPrototypeOf(MaterialDepth.prototype), "render", this).call(this, dt, scene, viewport, light, stack);

        viewport.webgl.disable(viewport.webgl.CULL_FACE);
        viewport.webgl.uniformMatrix4fv(viewport.program.uniform.uLMVMatrix, false, light.getMVPMatrix(modelMatrix, viewport, viewMatrix));
      }
    }]);

    return MaterialDepth;
  }(Material);

  var VERTEX_SHADER$2 = "\n    #define MAX_BONES ".concat(CONST.MAX_BONES, "\n    \n    attribute vec3 aVertexPosition;\n\tattribute vec4 aVertexWeights;\n\tattribute vec4 aVertexWeightIndices;\n\n    uniform mat4 uLMVMatrix;\n\n    uniform mat4 uDeformMatrix[MAX_BONES]; // Bone matrices\n    \n    varying float vDepth;\n\n    mat4 boneTransformMat4() {\n\t\tmat4 ret;\n\n\t\t// Weight normalization factor\n\t\tfloat normfac = 1.0 / (aVertexWeights[0] + aVertexWeights[1] + aVertexWeights[2] + aVertexWeights[3]);\n\n\t\t// Weight1 * Bone1 + Weight2 * Bone2\n\t\tret = normfac * aVertexWeights[0] * uDeformMatrix[int(floor(aVertexWeightIndices[0] + 0.5))]\n\t\t\t+ normfac * aVertexWeights[1] * uDeformMatrix[int(floor(aVertexWeightIndices[1] + 0.5))]\n\t\t\t+ normfac * aVertexWeights[2] * uDeformMatrix[int(floor(aVertexWeightIndices[2] + 0.5))]\n\t\t\t+ normfac * aVertexWeights[3] * uDeformMatrix[int(floor(aVertexWeightIndices[3] + 0.5))];\n\n\t\treturn ret;\n\t}\n\n    void main(void) {\n\t\t// Set the position\n        if(aVertexWeights[0] + aVertexWeights[1] + aVertexWeights[2] + aVertexWeights[3] > 0.0){\n            mat4 bt = boneTransformMat4();\n\n            gl_Position = uLMVMatrix * bt * vec4(aVertexPosition, 1.0);\n        }else{\n            gl_Position = uLMVMatrix * vec4(aVertexPosition, 1.0);\n        }\n\n        float zBuf = gl_Position.z / gl_Position.w;  // between -1 and 1\n        vDepth = 0.5 + (zBuf * 0.5);           // between 0 and 1\n    }\n");
  var MaterialDepthSkinned =
  /*#__PURE__*/
  function (_MaterialDepth) {
    _inherits(MaterialDepthSkinned, _MaterialDepth);

    function MaterialDepthSkinned() {
      var _this;

      _classCallCheck(this, MaterialDepthSkinned);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(MaterialDepthSkinned).apply(this, arguments));
      _this.vertexShader = VERTEX_SHADER$2;
      return _this;
    }

    return MaterialDepthSkinned;
  }(MaterialDepth);

  var tLightPositionFlatArray = new Float32Array(CONST.MAX_LIGHTS * 3);
  var tLightMVPFlatArray = new Float32Array(CONST.MAX_LIGHTS * 16);
  var tLighColorFlatArray = new Float32Array(CONST.MAX_LIGHTS * 3);
  var tLightEnabled = new Array(CONST.MAX_LIGHTS);
  var tLightIntensity = new Array(CONST.MAX_LIGHTS);
  var tLightMaxDistance = new Array(CONST.MAX_LIGHTS); // Variable Qualifiers
  // Qualifiers give a special meaning to the variable. The following qualifiers are available:
  //		const – The declaration is of a compile time constant.
  //		attribute – Global variables that may change per vertex, that are passed from the OpenGL application to vertex shaders. This qualifier can only be used in vertex shaders. For the shader this is a read-only variable. See Attribute section.
  //		uniform – Global variables that may change per primitive [...], that are passed from the OpenGL application to the shaders. This qualifier can be used in both vertex and fragment shaders. For the shaders this is a read-only variable. See Uniform section.
  //		varying – used for interpolated data between a vertex shader and a fragment shader. Available for writing in the vertex shader, and read-only in a fragment shader. See Varying section.
  // The vertex level shader. This is typically the position on screen.

  var VERTEX_SHADER$3 = "\n\tprecision highp float;\n\n\t#define MAX_BONES ".concat(CONST.MAX_BONES, "\n\t#define MAX_LIGHTS ").concat(CONST.MAX_LIGHTS, "\n\n\t#define SKELETAL_ENABLED\n\t#define TEXTURES_ENABLED\n\t#if MAX_LIGHTS > 0\n\t#define SHADOWS_ENABLED\n\t#endif\n\n\tattribute vec4 aVertexPosition;\n\tattribute vec3 aVertexNormal;\n\tattribute vec2 aTextureCoord;\n\tattribute vec4 aVertexWeights;\n\tattribute vec4 aVertexWeightIndices;\n\n\tuniform mat4 uMVCPMatrix; // Model View Camera Projection Matrix\n\tuniform mat4 uMMatrix; // World Matrix\n\tuniform mat4 uViewMatrix; // View Matrix\n\tuniform mat4 uNormalMatrix;\n\n\tuniform mat4 uDeformMatrix[MAX_BONES]; // Bone matrices\n\n\tuniform mat4 uDirectionalLightMVPMatrix; // Light MVP Matrix\n\tvarying vec4 vDirectionalShadowPos;\n\n\t#if MAX_LIGHTS > 0\n\tuniform mat4 uLightMVPMatrix[MAX_LIGHTS]; // Light MVP Matrix\n\tvarying vec4 vShadowPos[MAX_LIGHTS];\n\t#endif\n\n\tvarying vec3 vPositionCoord;\n\tvarying vec2 vTextureCoord;\n\tvarying vec3 vNormal;\n\n\tconst mat4 texUnitConverter = mat4(0.5, 0.0, 0.0, 0.0, 0.0, 0.5, 0.0, 0.0, 0.0, 0.0, 0.5, 0.0, 0.5, 0.5, 0.5, 1.0);\n\t\n\tmat4 boneTransformMat4() {\n\t\tmat4 ret;\n\n\t\t// Weight normalization factor\n\t\tfloat normfac = 1.0 / (aVertexWeights[0] + aVertexWeights[1] + aVertexWeights[2] + aVertexWeights[3]);\n\n\t\t// Weight1 * Bone1 + Weight2 * Bone2\n\t\tret = normfac * aVertexWeights[0] * uDeformMatrix[int(floor(aVertexWeightIndices[0] + 0.5))]\n\t\t\t+ normfac * aVertexWeights[1] * uDeformMatrix[int(floor(aVertexWeightIndices[1] + 0.5))]\n\t\t\t+ normfac * aVertexWeights[2] * uDeformMatrix[int(floor(aVertexWeightIndices[2] + 0.5))]\n\t\t\t+ normfac * aVertexWeights[3] * uDeformMatrix[int(floor(aVertexWeightIndices[3] + 0.5))];\n\n\t\treturn ret;\n\t}\n\n\tvoid main() {\n\t\t// Set the position\n\t\t#ifdef SKELETAL_ENABLED\n\t\t\tif(aVertexWeights[0] + aVertexWeights[1] + aVertexWeights[2] + aVertexWeights[3] > 0.0){\n\t\t\t\tmat4 bt = boneTransformMat4();\n\t\t\t\tvNormal = normalize((bt * vec4(aVertexNormal, 0.0)).xyz);\n\n\t\t\t\tgl_Position = uMVCPMatrix * bt * aVertexPosition;\n\t\t\t}else{\n\t\t\t\tvNormal = normalize(mat3(uNormalMatrix) * aVertexNormal);\n\n\t\t\t\tgl_Position = uMVCPMatrix * aVertexPosition;\n\t\t\t}\n\t\t#else\n\t\t\tvNormal = normalize(mat3(uNormalMatrix) * aVertexNormal);\n\n\t\t\tgl_Position = uMVCPMatrix * aVertexPosition;\n\t\t#endif\n\n\t\tvPositionCoord = vec3(uMMatrix * aVertexPosition);\n\t\t\n        // Set texture coordinate\n        #ifdef TEXTURES_ENABLED\n            vTextureCoord = aTextureCoord;\n\t\t#endif\n\n\t\t#ifdef SHADOWS_ENABLED\n\t\t\tvDirectionalShadowPos = texUnitConverter * uDirectionalLightMVPMatrix * aVertexPosition;\n\n\t\t\tfor(int i=0; i < ").concat(CONST.MAX_LIGHTS, "; ++i){\n\t\t\t\tvShadowPos[i] = uLightMVPMatrix[i] * aVertexPosition;\n\t\t\t\t// vShadowPos[i] = aVertexPosition.xyz - uLightPosition[i];\n\t\t\t}\n\t\t#endif\n\t}\n"); // The fragment (or "pixel") level shader.
  //distanceLightWeighting = alpha/(uPointLightingDistance*uPointLightingDistance)

  var FRAG_SHADER$2 = "\n\t#extension GL_OES_standard_derivatives: enable\n\n\t#ifdef GL_FRAGMENT_PRECISION_HIGH\n\t\tprecision highp float;\n\t\t// precision highp int;\n\t#else\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\t#endif\n\n\t#define MAX_LIGHTS ".concat(CONST.MAX_LIGHTS, "\n\n    #ifdef GL_OES_standard_derivatives\n        #define USE_SVM\n    #endif\n\n\t#if MAX_LIGHTS > 0\n\t#define POINT_LIGHTING_ENABLED\n\t#define DIRECTIONAL_SHADOWS_ENABLED\n\t#define POINT_SHADOWS_ENABLED\n\t#endif\n\t#define DIRECTIONAL_LIGHTING_ENABLED\n\t#define SHADOW_BIAS 0.0007\n\t#define FOG_ENABLED\n\t#define TEXTURE_DIFFUSE_ENABLED\n\t#define TEXTURE_SPECULAR_COLOR_ENABLED\n\t#define TEXTURE_AMBIENT_ENABLED\n\t#define TEXTURE_AMBIENT_BLEND_MODE 1 // 0: Additive | 1: Multiply | 2: Screen\n\t#define TEXTURE_AMBIENT_COORDINATES 0 // 0: Use UVs | 1: Use World Coordinates XY | 2: Use World Coordinates XZ\n\t#define TEXTURE_AMBIENT_SIZE 1024.00\n\t#define TEXTURE_AMBIENT_SCALE 1.0\n\t#define TEXTURE_AMBIENT_FLIPY\n\t#define TEXTURE_EMIT_ENABLED\n\n\tvarying vec3 vPositionCoord;\n\tvarying vec2 vTextureCoord;\n\tvarying vec3 vNormal;\n\n\tvarying vec4 vDirectionalShadowPos;\n\t#if MAX_LIGHTS > 0\n\tvarying vec4 vShadowPos[MAX_LIGHTS];\n\t#endif\n\n\tuniform vec3 uCameraPosition;\n\n\tuniform vec3 uSceneAmbientLightColor;\n\n\tuniform vec3 uDirectionalLightColor;\n\tuniform vec3 uDirectionalLightVector;\n\tuniform float uDirectionalLightIntensity;\n\t\n\tuniform sampler2D uDiffuseTexture;\n\tuniform sampler2D uSpecularColorTexture;\n\tuniform sampler2D uSpecularHighlightTexture;\n\tuniform sampler2D uAmbientTexture; // TODO: Should be global illumination texture\n\tuniform sampler2D uEmitTexture;\n\n\tuniform vec4 uFogColor;\n\tuniform float uFogDensity;\n\tuniform float uFogDistance;\n\n\t#if MAX_LIGHTS > 0\n\tuniform vec3 uLightPosition[MAX_LIGHTS]; // Light positions\n\tuniform vec3 uLightColor[MAX_LIGHTS];\n\tuniform float uLightIntensity[MAX_LIGHTS];\n\tuniform float uLightMaxDistance[MAX_LIGHTS];\n\tuniform samplerCube uPointLightDepth[MAX_LIGHTS];\n\t#endif\n\tuniform sampler2D uDirectionalLightDepth;\n\tuniform float uDirectionalLightDepthSize;\n\n\tuniform vec3 uMaterialDiffuseColor;\n\tuniform vec3 uMaterialSpecularColor;\n\tuniform vec3 uMaterialAmbientColor;\n\tuniform vec3 uMaterialEmitColor;\n\tuniform vec3 uMaterialTransmissionFilter;\n\tuniform float uMaterialDissolve;\n\tuniform float uMaterialSpecularExponent;\n\tuniform float uMaterialEmitExponent;\n\n\tuniform float uShadowBias;\n\n\tfloat unpackDepthVec2(in vec2 color) {\n\t\tconst vec2 bitShift = vec2(1.0 / 255.0, 1.0);\n\t\treturn dot(color, bitShift);\n\t}\n\n\tfloat unpackDepthVec3(in vec3 color) {\n\t\tconst vec3 bitShift = vec3(1.0 / (255.0 * 255.0), 1.0 / 255.0, 1.0);\n\t\treturn dot(color, bitShift);\n\t}\n\n\tfloat unpackDepthVec4(in vec4 color) {\n\t\tconst vec4 bitShift = vec4(1.0 / (255.0 * 255.0 * 255.0), 1.0 / (255.0 * 255.0), 1.0 / 255.0, 1.0);\n\t\treturn dot(color, bitShift);\n\t}\n\n\tvec4 shadow_filter(vec2 uv_shadowMap, in sampler2D depthColorTexture){\n        // if (!use_filter) {\n        \t// return texture2D(depthColorTexture, uv_shadowMap);\n\t\t// }\n\t\t\n        vec4 result = vec4(0.0);\n\t\t\n\t\tfor (int x = -1; x <= 1; x++) {\n        \tfor (int y = -1; y <= 1; y++) {\n        \t\tfloat x_l = (uv_shadowMap.x - float(x) / uDirectionalLightDepthSize);\n        \t\tfloat y_l = (uv_shadowMap.y - float(y) / uDirectionalLightDepthSize);\n        \t\tvec2 lookup = vec2(x_l, y_l);\n        \t\tresult += texture2D(depthColorTexture, lookup).rgba; //get(x,y);\n        \t}\n\t\t}\n\t\t\n        return result / 9.0;\n\t}\n\t\n\tfloat linstep(float low, float high, float v){\n\t\treturn clamp((v-low)/(high-low), 0.0, 1.0);\n\t}\n\n\tfloat directionalShadow(in vec4 shadowPosition, in sampler2D depthColorTexture) {\n\t\t#ifdef USE_SVM\n\t\t\tvec4 shadowMapColor = shadow_filter(shadowPosition.xy, depthColorTexture);\n\t\t\tfloat distance = shadowPosition.z;\n\t\t\tfloat mean = unpackDepthVec3(shadowMapColor.rgb);\n\n\t\t\t// Surface is fully lit\n\t\t\tif(distance < mean) return 1.0;\n\n\t\t\tfloat depth_2 = shadowMapColor.a;\n\n\t\t\t// The fragment is either in shadow or penumbra. We now use chebyshev's upperBound to check\n\t\t\t// How likely this pixel is to be lit (p_max)\n\t\t\tfloat variance = depth_2 - pow(mean, 2.00);\n\t\t\tvariance = max(variance, uShadowBias);\n\n\t\t\tfloat d = distance - mean;\n\t\t\tfloat p_max = variance / (variance + d*d);\n\t\t\tp_max = clamp(p_max, 0.0, 1.0);\n\t\t\tfloat p = smoothstep(distance - 0.02, distance, mean);\n\n\t\t\treturn p_max;\n\t\t\t\n\t\t\t// float p_max = linstep(0.2, 1.0, variance / (variance + d*d));\n\t\t\t// float p = smoothstep(distance - 0.02, distance, mean);\n\t\t\t// return (max(p, p_max) > 1.0 - uShadowBias)?1.0:0.0;\n\t\t\t// return clamp(max(p, p_max), 0.0, 1.0);\n\t\t\t// shadowCoeff = 0 = shadow\n\t\t\t// shadowCoeff = 1 = no shadow\n\t\t#else\n\t\t\tvec3 fragmentDepth = shadowPosition.xyz;\n\t\t\tfragmentDepth.z -= uShadowBias;\n\n\t\t\tfloat texelDepth = unpackDepthVec4(texture2D(depthColorTexture, fragmentDepth.xy));\n\t\t\treturn (fragmentDepth.z < texelDepth) ? 1.0 : 0.0;\n\n\t\t\t// float texelSize = 1.0 / 1024.0;\n\t\t\t// float amountInLight = 0.0;\n\n\t\t\t// for (int x = -1; x <= 1; x++) {\n\t\t\t// \tfor (int y = -1; y <= 1; y++) {\n\t\t\t// \t\tfloat texelDepth = unpackDepthVec4(texture2D(depthColorTexture, fragmentDepth.xy + vec2(x, y) * texelSize));\n\n\t\t\t// \t\tif (fragmentDepth.z < texelDepth) {\n\t\t\t// \t\t\tamountInLight += 1.0;\n\t\t\t// \t\t}\n\t\t\t// \t}\n\t\t\t// }\n\t\t\t// amountInLight /= 9.0;\n\n\t\t\t// return amountInLight;\n\t\t#endif\n\t}\n\n\tfloat omnidirectionalShadow(in vec3 direction, in samplerCube sampler) {\n\t\tdirection *= vec3(1.0, -1.0, 1.0);\n\t\tfloat vertexDepth = clamp(length(direction), 0.0, 1.0);\n\t\tfloat shadowMapDepth = unpackDepthVec4(textureCube(sampler, direction)) + SHADOW_BIAS;\n\n\t\treturn (vertexDepth > shadowMapDepth) ? 0.0 : 1.0;\n\t}\n\n\tfloat calculateFog(){\n\t\t// get the distance of the pixel\n\t\tfloat perspective_far = uFogDistance;\n\t\tfloat fog_cord = (gl_FragCoord.z / gl_FragCoord.w) / perspective_far;\n\n\t\t// density of fog\n\t\tfloat fog_density = uFogDensity;\n\n\t\t// increase fog by density\n\t\t// fog also thickens with distance\n\t\treturn fog_cord * fog_density;\n\t}\n\n\tvoid main(void) {\n\t\tvec3 N = normalize(vNormal);\n\t\tvec3 V = normalize(uCameraPosition); // we are in Eye Coordinates, so EyePos is (0,0,0) \n\n\t\t#if defined(DIRECTIONAL_LIGHTING_ENABLED) || defined(POINT_LIGHTING_ENABLED)\n\n\t\t\t// Calculate lighting\n\t\t\tvec4 Iamb = vec4(0.0);\n\t\t\tvec4 Ispec = vec4(0.0);\n\t\t\tvec4 Idiff = vec4(0.0);\n\t\t\tvec4 Iemit = vec4(0.0);\n\n\t\t\t#ifdef DIRECTIONAL_LIGHTING_ENABLED\n\t\t\t\tvec3 L = normalize(-uDirectionalLightVector); \n\t\t\t\tvec3 R = normalize(-reflect(L,N)); \n\t\t\t\n\t\t\t\t//calculate Ambient Term: \n\t\t\t\tIamb += vec4(uSceneAmbientLightColor, 0.0); \n\n\t\t\t\t#ifdef DIRECTIONAL_SHADOWS_ENABLED\n\t\t\t\t\tfloat shadow = directionalShadow(vDirectionalShadowPos, uDirectionalLightDepth);\n\t\t\t\t#else\n\t\t\t\t\tfloat shadow = 1.0;\n\t\t\t\t#endif\n\t\t\t\t\n\t\t\t\t//calculate Diffuse Term: \n\t\t\t\tIdiff += vec4(clamp(shadow * uDirectionalLightColor * max(dot(N,L), 0.0), 0.0, 1.0), 0.0);\n\t\t\t\n\t\t\t\t// calculate Specular Term:\n\t\t\t\tIspec += vec4(clamp(shadow * uDirectionalLightColor * pow(max(dot(R,V),0.0),0.3*uMaterialSpecularExponent), 0.0, 1.0), 0.0);\n\t\t\t#endif\n\t\t\t\n\t\t\t#ifdef POINT_LIGHTING_ENABLED\n\t\t\t\tfor (int i=0; i<MAX_LIGHTS; i++){\n\n\t\t\t\t\tvec3 L = normalize(uLightPosition[i] - vPositionCoord); \n\n\t\t\t\t\tif(length(L) > 0.0){\n\t\t\t\t\t\tvec3 R = normalize(-reflect(L,N)); \n\n\t\t\t\t\t\t#ifdef POINT_SHADOWS_ENABLED\n\t\t\t\t\t\t\tfloat shadow = omnidirectionalShadow(L, uPointLightDepth[i]); //lightPosition, in samplerCube sampler\n\t\t\t\t\t\t\tif(shadow <= 0.0) continue;\n\t\t\t\t\t\t#else\n\t\t\t\t\t\t\tfloat shadow = 1.0;\n\t\t\t\t\t\t#endif\n\n\t\t\t\t\t\t//calculate Ambient Term: \n\t\t\t\t\t\t// vec4 Iamb = vec4(uMaterialAmbientColor, 1.0); \n\t\t\t\t\t\t\n\t\t\t\t\t\t//calculate Diffuse Term: \n\t\t\t\t\t\tIdiff += vec4(clamp(uLightColor[i] * max(dot(N,L), 0.0), 0.0, 1.0), 0.0);\n\t\t\t\t\t\n\t\t\t\t\t\t// calculate Specular Term:\n\t\t\t\t\t\tIspec += vec4(clamp(uLightColor[i] * pow(max(dot(R,V),0.0),0.3*uMaterialSpecularExponent), 0.0, 1.0), 0.0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t#endif\n\n\t\t\t#if defined(TEXTURE_AMBIENT_ENABLED) || defined(TEXTURE_DIFFUSE_ENABLED)\n\t\t\t\t#if defined(TEXTURE_AMBIENT_ENABLED)\n\t\t\t\t\t\tIamb *= texture2D(uAmbientTexture, vTextureCoord);\n\t\t\t\t\t#endif\n\t\t\t\t#if defined(TEXTURE_DIFFUSE_ENABLED)\n\t\t\t\t\tIamb *= texture2D(uDiffuseTexture, vTextureCoord);\n\t\t\t\t#endif\n\t\t\t#else\n\t\t\t\tIamb *= vec4(uSceneAmbientLightColor * uMaterialAmbientColor, 1.0);\n\t\t\t#endif\n\n\t\t\t#ifdef TEXTURE_DIFFUSE_ENABLED\n\t\t\t\tIdiff *= texture2D(uDiffuseTexture, vTextureCoord);\n\t\t\t#else\n\t\t\t\tIdiff *= vec4(uMaterialDiffuseColor, 1.0);\n\t\t\t#endif\n\n\t\t\t#ifdef TEXTURE_SPECULAR_COLOR_ENABLED\n\t\t\t\tIspec *= texture2D(uSpecularColorTexture, vTextureCoord);\n\t\t\t#else\n\t\t\t\tIspec *= vec4(uMaterialSpecularColor, 1.0);\n\t\t\t#endif\n\n\t\t\t#ifdef TEXTURE_EMIT_ENABLED\n\t\t\t\tIemit += texture2D(uEmitTexture, vTextureCoord);\n\t\t\t#else\n\t\t\t\tIemit += vec4(uMaterialEmitColor, 1.0);\n\t\t\t#endif\n\t\t\tIemit.rgb *= uMaterialEmitExponent;\n\n\t\t\t// Final Color = Diffuse + Specular + Ambient + Emit\n\t\t\tgl_FragColor = Idiff + Ispec + Iamb + Iemit; \n\t\t  \tgl_FragColor.a *= uMaterialDissolve;\n\t\t#else\n\t\t\t#ifdef TEXTURE_DIFFUSE_ENABLED\n\t\t\t\tgl_FragColor = texture2D(uDiffuseTexture, vTextureCoord);\n\t\t\t#else\n\t\t\t\tgl_FragColor = vec4(uMaterialDiffuseColor, 1.0);\n\t\t\t#endif\n\t\t#endif\n\n\t\t// Discard if there's no pixel to show. This helps when there's empty space background\n\t\t// TODO: Is there a way to optimize this?\n\t\tif (gl_FragColor.a == 0.0) discard;\n\n\t\t#ifdef FOG_ENABLED\n\t\t\tfloat fog = calculateFog();\n\n\t\t\t// mix together the frag color with the fog color\n\t\t\tgl_FragColor = mix(uFogColor, gl_FragColor, clamp(1.0-fog,0.0,1.0));\n\t\t#endif\n\t}\n");
  var MaterialPhong =
  /*#__PURE__*/
  function (_Material) {
    _inherits(MaterialPhong, _Material);

    function MaterialPhong() {
      var _this;

      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref$ambientColor = _ref.ambientColor,
          ambientColor = _ref$ambientColor === void 0 ? new Color(0.0, 0.0, 0.0, 1.0) : _ref$ambientColor,
          _ref$diffuseColor = _ref.diffuseColor,
          diffuseColor = _ref$diffuseColor === void 0 ? new Color(1.0, 1.0, 1.0, 1.0) : _ref$diffuseColor,
          _ref$specularColor = _ref.specularColor,
          specularColor = _ref$specularColor === void 0 ? new Color(0.0, 0.0, 0.0, 1.0) : _ref$specularColor,
          _ref$specularExponent = _ref.specularExponent,
          specularExponent = _ref$specularExponent === void 0 ? 128.0 : _ref$specularExponent,
          _ref$emitColor = _ref.emitColor,
          emitColor = _ref$emitColor === void 0 ? new Color(0.0, 0.0, 0.0, 0.0) : _ref$emitColor,
          _ref$emitExponent = _ref.emitExponent,
          emitExponent = _ref$emitExponent === void 0 ? 1 : _ref$emitExponent,
          _ref$transmissionFilt = _ref.transmissionFilter,
          transmissionFilter = _ref$transmissionFilt === void 0 ? new Color(1.0, 1.0, 1.0, 1.0) : _ref$transmissionFilt,
          _ref$dissolve = _ref.dissolve,
          dissolve = _ref$dissolve === void 0 ? 1 : _ref$dissolve,
          _ref$lighting = _ref.lighting,
          lighting = _ref$lighting === void 0 ? 1 : _ref$lighting,
          _ref$shadowCastingMod = _ref.shadowCastingMode,
          shadowCastingMode = _ref$shadowCastingMod === void 0 ? 1 : _ref$shadowCastingMod,
          _ref$receiveShadows = _ref.receiveShadows,
          receiveShadows = _ref$receiveShadows === void 0 ? true : _ref$receiveShadows,
          _ref$shadowBias = _ref.shadowBias,
          shadowBias = _ref$shadowBias === void 0 ? CONST.DEFAULT_SHADOW_BIAS : _ref$shadowBias,
          _ref$skeletal = _ref.skeletal,
          skeletal = _ref$skeletal === void 0 ? false : _ref$skeletal,
          _ref$ambientTextureCo = _ref.ambientTextureCoordinateSpace,
          ambientTextureCoordinateSpace = _ref$ambientTextureCo === void 0 ? "UVtoXZ" : _ref$ambientTextureCo,
          _ref$ambientTextureFl = _ref.ambientTextureFlipY,
          ambientTextureFlipY = _ref$ambientTextureFl === void 0 ? false : _ref$ambientTextureFl,
          _ref$receivesFog = _ref.receivesFog,
          receivesFog = _ref$receivesFog === void 0 ? true : _ref$receivesFog,
          _ref$ambientTexture = _ref.ambientTexture,
          ambientTexture = _ref$ambientTexture === void 0 ? null : _ref$ambientTexture,
          _ref$diffuseTexture = _ref.diffuseTexture,
          diffuseTexture = _ref$diffuseTexture === void 0 ? null : _ref$diffuseTexture,
          _ref$specularColorTex = _ref.specularColorTexture,
          specularColorTexture = _ref$specularColorTex === void 0 ? null : _ref$specularColorTex,
          _ref$specularHighligh = _ref.specularHighlightTexture,
          specularHighlightTexture = _ref$specularHighligh === void 0 ? null : _ref$specularHighligh,
          _ref$emitTexture = _ref.emitTexture,
          emitTexture = _ref$emitTexture === void 0 ? null : _ref$emitTexture,
          _ref$alphaTexture = _ref.alphaTexture,
          alphaTexture = _ref$alphaTexture === void 0 ? null : _ref$alphaTexture,
          _ref$bumpMapTexture = _ref.bumpMapTexture,
          bumpMapTexture = _ref$bumpMapTexture === void 0 ? null : _ref$bumpMapTexture,
          _ref$displacementText = _ref.displacementTexture,
          displacementTexture = _ref$displacementText === void 0 ? null : _ref$displacementText,
          _ref$decalTexture = _ref.decalTexture,
          decalTexture = _ref$decalTexture === void 0 ? null : _ref$decalTexture;

      _classCallCheck(this, MaterialPhong);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(MaterialPhong).apply(this, arguments));
      _this.vertexShader = VERTEX_SHADER$3;
      _this.fragmentShader = FRAG_SHADER$2;
      _this.ambientColor = ambientColor;
      _this.diffuseColor = diffuseColor;
      _this.specularColor = specularColor;
      _this.emitColor = emitColor;
      _this.specularExponent = specularExponent;
      _this.emitExponent = emitExponent;
      _this.transmissionFilter = transmissionFilter;
      _this.dissolve = dissolve;
      _this.ambientTexture = ambientTexture;
      _this.diffuseTexture = diffuseTexture;
      _this.specularColorTexture = specularColorTexture;
      _this.specularHighlightTexture = specularHighlightTexture;
      _this.emitTexture = emitTexture;
      _this.alphaTexture = alphaTexture;
      _this.bumpMapTexture = bumpMapTexture;
      _this.displacementTexture = displacementTexture;
      _this.decalTexture = decalTexture;
      _this.shadowBias = shadowBias;
      _this.lighting = lighting;
      _this.skeletal = skeletal; // TODO Rename to "skinning"?

      _this.shadowCastingMode = shadowCastingMode;
      _this.receiveShadows = receiveShadows;
      _this.receivesFog = receivesFog;
      _this.ambientTextureCoordinateSpace = ambientTextureCoordinateSpace; // TODO: Name this var better?

      _this.ambientTextureFlipY = ambientTextureFlipY; // TODO: Name this var better?

      _this.buildProgram(); // TODO: Where should "autobuild" this live?


      return _this;
    }

    _createClass(MaterialPhong, [{
      key: "render",
      value: function render(dt, scene, viewport, camera, stack, viewMatrix, modelMatrix, frameBufferTextureStack) {
        // Set uniforms (uPMatrix, uCMatrix, etc...)
        _get(_getPrototypeOf(MaterialPhong.prototype), "render", this).call(this, dt, scene, viewport, camera, stack, viewMatrix, modelMatrix, frameBufferTextureStack); // Set current textures


        if (this.diffuseTexture) {
          if (this.diffuseTexture.setAsTexture(viewport, 0, viewport.program.uniform.uDiffuseTexture) === false) return;
        }

        if (this.ambientTexture) {
          if (this.ambientTexture.setAsTexture(viewport, 1, viewport.program.uniform.uAmbientTexture) === false) return;
        }

        if (this.specularColorTexture) {
          if (this.specularColorTexture.setAsTexture(viewport, 2, viewport.program.uniform.uSpecularColorTexture) === false) return;
        }

        if (this.specularHighlightTexture) {
          if (this.specularHighlightTexture.setAsTexture(viewport, 3, viewport.program.uniform.uSpecularHighlightTexture) === false) return;
        }

        if (this.emitTexture) {
          if (this.emitTexture.setAsTexture(viewport, 4, viewport.program.uniform.uEmitTexture) === false) return;
        }

        viewport.webgl.uniform4fv(viewport.program.uniform.uDiffuseColor, this.diffuseColor.toArray()); // Set the material properties

        viewport.webgl.uniform3fv(viewport.program.uniform.uMaterialDiffuseColor, this.diffuseColor.toVec3Array());
        viewport.webgl.uniform3fv(viewport.program.uniform.uMaterialSpecularColor, this.specularColor.toVec3Array());
        viewport.webgl.uniform3fv(viewport.program.uniform.uMaterialAmbientColor, this.ambientColor.toVec3Array());
        viewport.webgl.uniform3fv(viewport.program.uniform.uMaterialEmitColor, this.emitColor.toVec3Array());
        viewport.webgl.uniform3fv(viewport.program.uniform.uMaterialTransmissionFilter, this.transmissionFilter.toVec3Array());
        viewport.webgl.uniform1f(viewport.program.uniform.uMaterialSpecularExponent, this.specularExponent);
        viewport.webgl.uniform1f(viewport.program.uniform.uMaterialEmitExponent, this.emitExponent);
        viewport.webgl.uniform1f(viewport.program.uniform.uMaterialDissolve, this.dissolve); // Set global lighting

        var shadowCount = 0;
        viewport.webgl.uniform3fv(viewport.program.uniform.uSceneAmbientLightColor, scene.ambientLightColor.toVec3Array()); //TODO: [Optimization] Prevent creating Float32Arrays every time

        viewport.webgl.uniform3fv(viewport.program.uniform.uDirectionalLightColor, scene.directionalLight.diffuseColor.toVec3Array());
        viewport.webgl.uniform3fv(viewport.program.uniform.uDirectionalLightVector, scene.directionalLight.vector);
        viewport.webgl.uniform1f(viewport.program.uniform.uShadowBias, this.shadowBias);

        if (CONST.DIRECTIONAL_SHADOWS_ENABLED) {
          if (viewport.program.uniform["uDirectionalLightDepth"] && frameBufferTextureStack[frameBufferTextureStack.length - 1]) {
            if (frameBufferTextureStack[frameBufferTextureStack.length - 1][shadowCount].setAsTexture(viewport, 5 + shadowCount, viewport.program.uniform["uDirectionalLightDepth"]) === false) return;
            viewport.webgl.uniform1f(viewport.program.uniform.uDirectionalLightDepthSize, frameBufferTextureStack[frameBufferTextureStack.length - 1][shadowCount].width);
          }

          viewport.webgl.uniformMatrix4fv(viewport.program.uniform.uDirectionalLightMVPMatrix, false, scene.directionalLight.getMVPMatrix(modelMatrix, viewport));
          shadowCount++;
        } // Build dynamic point lights


        if (viewport.program.uniform["uLightPosition[0]"] !== undefined) {
          tLightPositionFlatArray.fill(0);
          tLightMVPFlatArray.fill(0);
          tLighColorFlatArray.fill(0);
          tLightIntensity.fill(0);
          tLightMaxDistance.fill(0);

          for (var lightIndex = 0; lightIndex < CONST.MAX_LIGHTS; lightIndex++) {
            var light = scene.lights[lightIndex];

            if (!light || !light.enabled) continue;

            for (var j = 0; j < 3; j++) {
              tLightPositionFlatArray[lightIndex * 3 + j] = light.transform.xyz[j];
            }

            var tMVP = light.getMVPMatrix(modelMatrix, viewport);

            for (var j = 0; j < 16; j++) {
              tLightMVPFlatArray[lightIndex * 16 + j] = tMVP[j];
            }

            for (var j = 0; j < 3; j++) {
              tLighColorFlatArray[lightIndex * 3 + j] = light.diffuseColor.toArray()[j];
            }

            tLightIntensity[lightIndex] = light.intensity * 1;
            tLightMaxDistance[lightIndex] = light.maxDistance * 1;
          }

          shadowCount += CONST.MAX_LIGHTS;
          viewport.webgl.uniform3fv(viewport.program.uniform["uLightPosition[0]"], tLightPositionFlatArray);
          viewport.webgl.uniformMatrix4fv(viewport.program.uniform["uLightMVPMatrix[0]"], false, tLightMVPFlatArray);
          viewport.webgl.uniform3fv(viewport.program.uniform["uLightColor[0]"], tLighColorFlatArray); // viewport.webgl.uniform1fv(viewport.program.uniform["uLightIntensity[0]"], tLightIntensity);
          // viewport.webgl.uniform1fv(viewport.program.uniform["uLightMaxDistance[0]"], tLightMaxDistance);
        } // Set fog


        viewport.webgl.uniform4fv(viewport.program.uniform.uFogColor, scene.fogColor.toArray());
        viewport.webgl.uniform1f(viewport.program.uniform.uFogDensity, scene.fogDensity);
        viewport.webgl.uniform1f(viewport.program.uniform.uFogDistance, viewport.camera._farPlane); // Enable transparency

        viewport.webgl.blendFunc(viewport.webgl.SRC_ALPHA, viewport.webgl.ONE_MINUS_SRC_ALPHA);
        viewport.webgl.enable(viewport.webgl.BLEND);
      }
    }, {
      key: "buildProgram",
      value: function buildProgram() {
        this.vertexShader = VERTEX_SHADER$3;
        this.fragmentShader = FRAG_SHADER$2;
        if (!CONST.SHADOWS_VSM_ENABLED) this.fragmentShader = this.fragmentShader.replace("#define USE_SVM", "");

        {
          this.vertexShader = this.vertexShader.replace("#define POINT_SHADOWS_ENABLED", "");
          this.fragmentShader = this.fragmentShader.replace("#define POINT_SHADOWS_ENABLED", "");
        }

        if (!CONST.LIGHTING_ENABLED) {
          this.vertexShader = this.vertexShader.replace("#define DIRECTIONAL_SHADOWS_ENABLED", "");
          this.fragmentShader = this.fragmentShader.replace("#define DIRECTIONAL_SHADOWS_ENABLED", "");
          this.vertexShader = this.vertexShader.replace("#define POINT_SHADOWS_ENABLED", "");
          this.fragmentShader = this.fragmentShader.replace("#define POINT_SHADOWS_ENABLED", "");
          this.vertexShader = this.vertexShader.replace("#define DIRECTIONAL_LIGHTING_ENABLED", "");
          this.fragmentShader = this.fragmentShader.replace("#define DIRECTIONAL_LIGHTING_ENABLED", "");
          this.vertexShader = this.vertexShader.replace("#define POINT_LIGHTING_ENABLED", "");
          this.fragmentShader = this.fragmentShader.replace("#define POINT_LIGHTING_ENABLED", "");
        }

        switch (this.lighting) {
          case 1:
            // Leave it alone
            break;

          case 0:
          default:
            this.vertexShader = this.vertexShader.replace("#define DIRECTIONAL_LIGHTING_ENABLED", "");
            this.fragmentShader = this.fragmentShader.replace("#define DIRECTIONAL_LIGHTING_ENABLED", "");
            this.vertexShader = this.vertexShader.replace("#define POINT_LIGHTING_ENABLED", "");
            this.fragmentShader = this.fragmentShader.replace("#define POINT_LIGHTING_ENABLED", "");
            this.vertexShader = this.vertexShader.replace("#define SHADOWS_ENABLED", "");
            this.fragmentShader = this.fragmentShader.replace("#define SHADOWS_ENABLED", "");
            break;
        }

        if (!this.ambientTexture && !this.diffuseTexture && !this.specularColorTexture && !this.specularHighlightTexture && !this.alphaTexture && !this.bumpMapTexture && !this.displacementTexture && !this.decalTexture) {
          this.vertexShader = this.vertexShader.replace("#define TEXTURES_ENABLED", "");
          this.fragmentShader = this.fragmentShader.replace("#define TEXTURES_ENABLED", "");
        }

        if (!this.ambientTexture) {
          this.fragmentShader = this.fragmentShader.replace("#define TEXTURE_AMBIENT_ENABLED", "");
        } else {
          this.fragmentShader = this.fragmentShader.replace("#define TEXTURE_AMBIENT_SIZE 1024.00", "#define TEXTURE_AMBIENT_SIZE " + this.ambientTexture.width.toFixed(2));
          if (this.ambientTexture.scale) this.fragmentShader = this.fragmentShader.replace("#define TEXTURE_AMBIENT_SCALE 1.0", "#define TEXTURE_AMBIENT_SCALE " + this.ambientTexture.scale.toFixed(2));

          switch (this.ambientTextureCoordinateSpace) {
            case "UV":
              this.fragmentShader = this.fragmentShader.replace("#define TEXTURE_AMBIENT_COORDINATES 0", "#define TEXTURE_AMBIENT_COORDINATES 0");
              break;

            case "UVtoXY":
              this.fragmentShader = this.fragmentShader.replace("#define TEXTURE_AMBIENT_COORDINATES 0", "#define TEXTURE_AMBIENT_COORDINATES 1");
              break;

            case "UVtoXZ":
              this.fragmentShader = this.fragmentShader.replace("#define TEXTURE_AMBIENT_COORDINATES 0", "#define TEXTURE_AMBIENT_COORDINATES 2");
              break;
          }

          if (this.ambientTextureCoordinateSpace !== "WORLD") {
            this.fragmentShader = this.fragmentShader.replace("#define TEXTURE_AMBIENT_COORDINATES 1", "#define TEXTURE_AMBIENT_COORDINATES 0");
          }

          if (!this.ambientTextureFlipY) {
            this.fragmentShader = this.fragmentShader.replace("#define TEXTURE_AMBIENT_FLIPY", "");
          }
        }

        if (!this.diffuseTexture) {
          this.fragmentShader = this.fragmentShader.replace("#define TEXTURE_DIFFUSE_ENABLED", "");
        }

        if (!this.specularColorTexture) {
          this.fragmentShader = this.fragmentShader.replace("#define TEXTURE_SPECULAR_COLOR_ENABLED", "");
        }

        if (!this.specularHighlightTexture) {
          this.fragmentShader = this.fragmentShader.replace("#define TEXTURE_SPECULAR_HIGHLIGHT_ENABLED", "");
        }

        if (!this.emitTexture) {
          this.fragmentShader = this.fragmentShader.replace("#define TEXTURE_EMIT_ENABLED", "");
        }

        if (!this.skeletal) {
          this.vertexShader = this.vertexShader.replace("#define SKELETAL_ENABLED", "");
        }

        if (!this.receivesFog) {
          this.fragmentShader = this.fragmentShader.replace("#define FOG_ENABLED", "");
        }

        if (!this.receiveShadows) {
          this.vertexShader = this.vertexShader.replace("#define SHADOWS_ENABLED", "");
          this.fragmentShader = this.fragmentShader.replace("#define SHADOWS_ENABLED", "");
        }
      }
    }]);

    return MaterialPhong;
  }(Material);

  var Importer =
  /*#__PURE__*/
  function () {
    function Importer() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      _classCallCheck(this, Importer);

      this.options = options;
    }

    _createClass(Importer, null, [{
      key: "load",
      value: function () {
        var _load = _asyncToGenerator(
        /*#__PURE__*/
        regeneratorRuntime.mark(function _callee() {
          return regeneratorRuntime.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee);
        }));

        function load() {
          return _load.apply(this, arguments);
        }

        return load;
      }()
    }, {
      key: "loadFromURL",
      value: function () {
        var _loadFromURL = _asyncToGenerator(
        /*#__PURE__*/
        regeneratorRuntime.mark(function _callee2(src, instance, importCache) {
          return regeneratorRuntime.wrap(function _callee2$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  if (src) {
                    _context2.next = 2;
                    break;
                  }

                  return _context2.abrupt("return", false);

                case 2:
                  instance.src = src;
                  instance.srcPath = src.substr(0, src.lastIndexOf("/"));
                  if (instance.resPath === undefined) instance.resPath = instance.srcPath;
                  instance.srcFilename = src.split("/").pop();

                  if (!(importCache && importCache[src] && importCache[src].input)) {
                    _context2.next = 10;
                    break;
                  }

                  return _context2.abrupt("return", instance.input = importCache[src].input);

                case 10:
                  return _context2.abrupt("return", this.fetchFromURL(src).then(function (response) {
                    instance.input = response;

                    if (importCache) {
                      importCache[src] = {
                        input: response
                      };
                    } // return this.load();

                  }));

                case 11:
                case "end":
                  return _context2.stop();
              }
            }
          }, _callee2, this);
        }));

        function loadFromURL(_x, _x2, _x3) {
          return _loadFromURL.apply(this, arguments);
        }

        return loadFromURL;
      }() // Fetch

    }, {
      key: "fetchFromURL",
      value: function () {
        var _fetchFromURL = _asyncToGenerator(
        /*#__PURE__*/
        regeneratorRuntime.mark(function _callee3(url) {
          return regeneratorRuntime.wrap(function _callee3$(_context3) {
            while (1) {
              switch (_context3.prev = _context3.next) {
                case 0:
                  return _context3.abrupt("return", fetch(url, {
                    "Content-Type": "text/html"
                  }).then(function (response) {
                    // Read response
                    if (!response.ok) {
                      throw Error(response.statusText, response.url);
                    }

                    return response.text();
                  }).then( // Return contents
                  function (contents) {
                    return contents;
                  })["catch"](function (e) {
                    console.error("Error fetching template '".concat(url, "'."), e);
                  }));

                case 1:
                case "end":
                  return _context3.stop();
              }
            }
          }, _callee3);
        }));

        function fetchFromURL(_x4) {
          return _fetchFromURL.apply(this, arguments);
        }

        return fetchFromURL;
      }()
    }]);

    return Importer;
  }();

  var importCache = {};
  var ImportSpriteFromTexturePacker =
  /*#__PURE__*/
  function (_Importer) {
    _inherits(ImportSpriteFromTexturePacker, _Importer);

    function ImportSpriteFromTexturePacker() {
      _classCallCheck(this, ImportSpriteFromTexturePacker);

      return _possibleConstructorReturn(this, _getPrototypeOf(ImportSpriteFromTexturePacker).apply(this, arguments));
    }

    _createClass(ImportSpriteFromTexturePacker, null, [{
      key: "clearCache",
      value: function clearCache() {
        importCache = {};
      }
    }, {
      key: "load",
      value: function () {
        var _load = _asyncToGenerator(
        /*#__PURE__*/
        regeneratorRuntime.mark(function _callee() {
          var options,
              instance,
              objs,
              directory,
              _iteratorNormalCompletion,
              _didIteratorError,
              _iteratorError,
              _iterator,
              _step,
              _src2,
              filename,
              _options$src,
              src,
              _i,
              _Object$values,
              obj,
              textures,
              _iteratorNormalCompletion2,
              _didIteratorError2,
              _iteratorError2,
              _iterator2,
              _step2,
              _src,
              _iteratorNormalCompletion3,
              _didIteratorError3,
              _iteratorError3,
              _iterator3,
              _step3,
              texture,
              sprite,
              materialIndex,
              _i2,
              _Object$values2,
              _obj,
              _filename,
              _iteratorNormalCompletion4,
              _didIteratorError4,
              _iteratorError4,
              _iterator4,
              _step4,
              frame,
              animationName,
              animation,
              speed,
              _animationName,
              _animation,
              _i3,
              _Object$entries,
              _Object$entries$_i,
              key,
              _frame,
              _speed,
              _args = arguments;

          return regeneratorRuntime.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  options = _args.length > 0 && _args[0] !== undefined ? _args[0] : {};
                  if (!Array.isArray(options.src)) options.src = [options.src];
                  instance = {};
                  instance.options = options;

                  if (!(!importCache[options.src[0]] || !importCache[options.src[0]].sprite)) {
                    _context.next = 128;
                    break;
                  }

                  objs = {};
                  directory = options.src[0].substring(0, options.src[0].lastIndexOf("/") + 1);
                  if (!options.defaultPivot) options.defaultPivot = [0.5, 0.5]; // Get the src file and all references then JSON parse

                  _iteratorNormalCompletion = true;
                  _didIteratorError = false;
                  _iteratorError = undefined;
                  _context.prev = 11;
                  _iterator = options.src[Symbol.iterator]();

                case 13:
                  if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {
                    _context.next = 23;
                    break;
                  }

                  _src2 = _step.value;
                  filename = _src2.split("/").pop(); // Only parse JSON files that we haven't parsed yet

                  if (!(!importCache[_src2] || !importCache[_src2].sprite)) {
                    _context.next = 20;
                    break;
                  }

                  _context.next = 19;
                  return this.loadFromURL(directory + filename, instance, importCache);

                case 19:
                  // Parse it
                  if (!objs[filename]) {
                    objs[filename] = JSON.parse(instance.input);

                    if (objs[filename].meta.related_multi_packs) {
                      (_options$src = options.src).push.apply(_options$src, _toConsumableArray(objs[filename].meta.related_multi_packs)); //.filter((val) => importCache[val]));

                    }
                  }

                case 20:
                  _iteratorNormalCompletion = true;
                  _context.next = 13;
                  break;

                case 23:
                  _context.next = 29;
                  break;

                case 25:
                  _context.prev = 25;
                  _context.t0 = _context["catch"](11);
                  _didIteratorError = true;
                  _iteratorError = _context.t0;

                case 29:
                  _context.prev = 29;
                  _context.prev = 30;

                  if (!_iteratorNormalCompletion && _iterator["return"] != null) {
                    _iterator["return"]();
                  }

                case 32:
                  _context.prev = 32;

                  if (!_didIteratorError) {
                    _context.next = 35;
                    break;
                  }

                  throw _iteratorError;

                case 35:
                  return _context.finish(32);

                case 36:
                  return _context.finish(29);

                case 37:
                  // Build sources and create sprite
                  // Use the options in the sprite options except for the src. Copy the src from the objs' meta data.
                  src = options.src;
                  options.src = [];

                  for (_i = 0, _Object$values = Object.values(objs); _i < _Object$values.length; _i++) {
                    obj = _Object$values[_i];
                    options.src.push(instance.resPath + "/" + obj.meta.image);
                  } // Filter and order to src


                  if (!options.textures) {
                    _context.next = 86;
                    break;
                  }

                  textures = [];
                  _iteratorNormalCompletion2 = true;
                  _didIteratorError2 = false;
                  _iteratorError2 = undefined;
                  _context.prev = 45;
                  _iterator2 = options.src[Symbol.iterator]();

                case 47:
                  if (_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done) {
                    _context.next = 71;
                    break;
                  }

                  _src = _step2.value;
                  _iteratorNormalCompletion3 = true;
                  _didIteratorError3 = false;
                  _iteratorError3 = undefined;
                  _context.prev = 52;

                  for (_iterator3 = options.textures[Symbol.iterator](); !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                    texture = _step3.value;
                    if (texture.src === _src) textures.push(texture);
                  }

                  _context.next = 60;
                  break;

                case 56:
                  _context.prev = 56;
                  _context.t1 = _context["catch"](52);
                  _didIteratorError3 = true;
                  _iteratorError3 = _context.t1;

                case 60:
                  _context.prev = 60;
                  _context.prev = 61;

                  if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
                    _iterator3["return"]();
                  }

                case 63:
                  _context.prev = 63;

                  if (!_didIteratorError3) {
                    _context.next = 66;
                    break;
                  }

                  throw _iteratorError3;

                case 66:
                  return _context.finish(63);

                case 67:
                  return _context.finish(60);

                case 68:
                  _iteratorNormalCompletion2 = true;
                  _context.next = 47;
                  break;

                case 71:
                  _context.next = 77;
                  break;

                case 73:
                  _context.prev = 73;
                  _context.t2 = _context["catch"](45);
                  _didIteratorError2 = true;
                  _iteratorError2 = _context.t2;

                case 77:
                  _context.prev = 77;
                  _context.prev = 78;

                  if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
                    _iterator2["return"]();
                  }

                case 80:
                  _context.prev = 80;

                  if (!_didIteratorError2) {
                    _context.next = 83;
                    break;
                  }

                  throw _iteratorError2;

                case 83:
                  return _context.finish(80);

                case 84:
                  return _context.finish(77);

                case 85:
                  options.textures = textures;

                case 86:
                  sprite = new Sprite(options);
                  _context.next = 89;
                  return sprite.loadTextures();

                case 89:
                  options.src = src;
                  materialIndex = -1;
                  _i2 = 0, _Object$values2 = Object.values(objs);

                case 92:
                  if (!(_i2 < _Object$values2.length)) {
                    _context.next = 125;
                    break;
                  }

                  _obj = _Object$values2[_i2];
                  materialIndex++; // sprite.src = instance.resPath + "/" + obj.meta.image;

                  _filename = _obj.meta.image.split(".")[0]; // There are two main types of texturePacker formats: Array or object of frames

                  if (!(_obj.frames instanceof Array)) {
                    _context.next = 118;
                    break;
                  }

                  _iteratorNormalCompletion4 = true;
                  _didIteratorError4 = false;
                  _iteratorError4 = undefined;
                  _context.prev = 100;

                  for (_iterator4 = _obj.frames[Symbol.iterator](); !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
                    frame = _step4.value;
                    animationName = _filename;
                    if (frame.filename.indexOf("/")) animationName = frame.filename.substring(0, frame.filename.lastIndexOf("/"));
                    animation = sprite.animations[animationName];

                    if (!animation) {
                      animation = new SpriteAnimation({
                        loop: true
                      });
                      sprite.addAnimation(animationName, animation);
                    } // Get speed from options or userData


                    speed = instance.options.speed || 15 / 1000;

                    if (frame.userData && frame.userData.speed) {
                      // TODO: Multiply options.speed with given framerate?
                      speed = frame.userData.speed;
                    }

                    animation.addFrame({
                      speed: speed,
                      // of 15 FPS,
                      name: frame.filename.substring(frame.filename.lastIndexOf("/") + 1),
                      x: frame.frame.x * 1,
                      y: frame.frame.y * 1,
                      width: frame.frame.w * 1,
                      height: frame.frame.h * 1,
                      offsetX: frame.spriteSourceSize.x,
                      offsetY: frame.spriteSourceSize.y,
                      pivotX: !frame.pivot ? options.defaultPivot[0] : frame.pivot.x * 1,
                      pivotY: !frame.pivot ? options.defaultPivot[1] : 1 - frame.pivot.y * 1,
                      materialIndex: materialIndex
                    });
                  }

                  _context.next = 108;
                  break;

                case 104:
                  _context.prev = 104;
                  _context.t3 = _context["catch"](100);
                  _didIteratorError4 = true;
                  _iteratorError4 = _context.t3;

                case 108:
                  _context.prev = 108;
                  _context.prev = 109;

                  if (!_iteratorNormalCompletion4 && _iterator4["return"] != null) {
                    _iterator4["return"]();
                  }

                case 111:
                  _context.prev = 111;

                  if (!_didIteratorError4) {
                    _context.next = 114;
                    break;
                  }

                  throw _iteratorError4;

                case 114:
                  return _context.finish(111);

                case 115:
                  return _context.finish(108);

                case 116:
                  _context.next = 122;
                  break;

                case 118:
                  _animationName = _filename;
                  _animation = new SpriteAnimation({
                    loop: true
                  });
                  sprite.addAnimation(_animationName, _animation);

                  for (_i3 = 0, _Object$entries = Object.entries(_obj.frames); _i3 < _Object$entries.length; _i3++) {
                    _Object$entries$_i = _slicedToArray(_Object$entries[_i3], 2), key = _Object$entries$_i[0], _frame = _Object$entries$_i[1];
                    // Get speed from options or userData
                    _speed = instance.options.speed || 15 / 1000;

                    if (_frame.userData && _frame.userData.speed) {
                      _speed = _frame.userData.speed;
                    }

                    _animation.addFrame({
                      speed: _speed,
                      // of 15 FPS
                      x: _frame.frame.x * 1,
                      y: _frame.frame.y * 1,
                      width: _frame.frame.w * 1,
                      height: _frame.frame.h * 1,
                      pivotX: !_frame.pivot ? options.defaultPivot[0] : _frame.pivot.x * 1,
                      pivotY: !_frame.pivot ? options.defaultPivot[1] : 1 - _frame.pivot.y * 1,
                      materialIndex: materialIndex
                    });
                  }

                case 122:
                  _i2++;
                  _context.next = 92;
                  break;

                case 125:
                  importCache[options.src[0]].sprite = sprite;
                  delete importCache[options.src[0]].sprite.id; // Free up memory

                  delete importCache[options.src[0]].input;

                case 128:
                  instance.sprite = this.cloneSprite(importCache[options.src[0]].sprite);

                  if (instance.options.defaultAnimation !== undefined) {
                    if (instance.options.autoplay || instance.options.autoplay === undefined) {
                      instance.sprite.playAnimation(instance.options.defaultAnimation);
                    } else {
                      instance.sprite.selectAnimation(instance.options.defaultAnimation);
                    }
                  }

                  return _context.abrupt("return", instance.sprite);

                case 131:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee, this, [[11, 25, 29, 37], [30,, 32, 36], [45, 73, 77, 85], [52, 56, 60, 68], [61,, 63, 67], [78,, 80, 84], [100, 104, 108, 116], [109,, 111, 115]]);
        }));

        function load() {
          return _load.apply(this, arguments);
        }

        return load;
      }()
    }, {
      key: "cloneSprite",
      value: function cloneSprite(sprite, instanceTexture) {
        var newSprite;

        if (instanceTexture) {
          var textures = sprite.textures;
          var texture = sprite.mesh.material.diffuseTexture;
          var src = sprite.src;
          sprite.src = null;
          newSprite = new Sprite(sprite);
          newSprite.textures = textures;
          newSprite.mesh.material.diffuseTexture = texture;
          newSprite._src = src;
          sprite.textures = textures;
          sprite.mesh.material.diffuseTexture = texture;
          sprite._src = src;
        } else {
          newSprite = new Sprite(sprite);
        }

        this.cloneSpriteAnimations(newSprite, sprite.animations);
        newSprite.transform = new Transform(sprite.transform);
        return newSprite;
      }
    }, {
      key: "cloneSpriteAnimations",
      value: function cloneSpriteAnimations(sprite, animations) {
        for (var _i4 = 0, _Object$entries2 = Object.entries(animations); _i4 < _Object$entries2.length; _i4++) {
          var _Object$entries2$_i = _slicedToArray(_Object$entries2[_i4], 2),
              key = _Object$entries2$_i[0],
              animation = _Object$entries2$_i[1];

          var newAnimation = new SpriteAnimation(animation);
          sprite.addAnimation(key, newAnimation);
        }
        return animations;
      }
    }]);

    return ImportSpriteFromTexturePacker;
  }(Importer);

  var assets = {
    "audio": {
      "music": ["res/audio/music/SD-Aambient-01.mp3", "res/audio/music/SD-Ambient.mp3", "res/audio/music/SD-Rhythm.mp3"],
      "sfx": ["res/audio/sfx/SD-Aim/SD-Aim-01-Dn.mp3", "res/audio/sfx/SD-Aim/SD-Aim-01-Up.mp3", "res/audio/sfx/SD-Aim/SD-Aim-02-Up.mp3", "res/audio/sfx/SD-Aim/SD-Aim-04-Up.mp3", "res/audio/sfx/SD-Ambient/SD-cricket.mp3", "res/audio/sfx/SD-Ambient/SD-Cricketsloop.mp3", "res/audio/sfx/SD-Ambient/SD-Lightning.mp3", "res/audio/sfx/SD-Ambient/SD-Owl.mp3", "res/audio/sfx/SD-Ambient/SD-Storm.mp3", "res/audio/sfx/SD-Ambient/SD-Thunder.mp3", "res/audio/sfx/SD-Ambient/SD-Wind.mp3", "res/audio/sfx/SD-Launch/SD-Launch-01.mp3", "res/audio/sfx/SD-Launch/SD-Launch-02.mp3", "res/audio/sfx/SD-Launch/SD-Launch-03.mp3", "res/audio/sfx/SD-Launch/SD-Launch-04.mp3", "res/audio/sfx/SD-Launch/SD-Launch-05.mp3", "res/audio/sfx/SD-OffScreen/SD-OffScreen-01.mp3", "res/audio/sfx/SD-OffScreen/SD-OffScreen-02.mp3", "res/audio/sfx/SD-OffScreen/SD-OffScreen-03.mp3", "res/audio/sfx/SD-OffScreen/SD-OffScreen-04.mp3", "res/audio/sfx/SD-OffScreen/SD-OffScreen-05.mp3", "res/audio/sfx/SD-OffScreen/SD-OffScreen-06.mp3", "res/audio/sfx/SD-Silence/0000.mp3", "res/audio/sfx/SD-Skip/SD-transition.mp3", "res/audio/sfx/SD-SnackBite/SD-SnackBite.mp3", "res/audio/sfx/SD-Tap/SD-Tap-Drip-1.mp3", "res/audio/sfx/SD-Tap/SD-Tap-Drip-2.mp3", "res/audio/sfx/SD-Tap/SD-Tap-Squeak.mp3", "res/audio/sfx/SD-Toasty/SD-Toasty-01.mp3", "res/audio/sfx/SD-Toasty/SD-Toasty-02.mp3", "res/audio/sfx/SD-Toasty/SD-Toasty-03.mp3", "res/audio/sfx/SD-Transition/SD-Organ-Lg.mp3", "res/audio/sfx/SD-Transition/SD-Organ-Sm.mp3", "res/audio/sfx/SD-Win/SD-Win-HIO-1.mp3", "res/audio/sfx/SD-Win/SD-Win-HIO-2.mp3", "res/audio/sfx/SD-Win/SD-Win-HIO-3.mp3"]
    },
    "videos": [],
    "images": ["res/textures/cn-preloader-black.png", "res/textures/mm-0.png", "res/textures/mm-1.png", "res/textures/mm-2.png", "res/textures/mm-3.png", "res/textures/mm-4.png", "res/textures/mm-5.png", "res/textures/mm-glyphs.png", "res/textures/TC-LOGO-Game.png", "res/textures/TC-LOGO-Show.png"],
    "models": [],
    "spritesheets": ["res/textures/mm-0.json", "res/textures/mm-glyphs.json", "res/textures/cn-preloader-black.json"]
  };

  var VERTEX_SHADER$4 = "\n    attribute vec3 aVertexPosition;\n    attribute vec2 aTextureCoord;\n\n    // uniform mat4 uMVCPMatrix; // Model View Camera Projection Matrix\n    uniform mat4 uVMatrix;\n    uniform mat4 uMMatrix;\n    \n\tvarying vec2 vTextureCoord;\n    \n    void main(void) {\n        // gl_Position = uMVCPMatrix * vec4(aVertexPosition, 1.0);\n        gl_Position = uVMatrix * uMMatrix * vec4(aVertexPosition, 1.0);\n\n        vTextureCoord = aTextureCoord;\n    }\n";
  var FRAG_SHADER$3 = "\n    #extension GL_OES_standard_derivatives: enable\n\n    #ifdef GL_FRAGMENT_PRECISION_HIGH\n        precision highp float;\n    #else\n        precision mediump float;\n    #endif\n\n    uniform sampler2D uDiffuseTexture;\n    \n\tuniform vec3 uHSLAdjust;\n\tuniform bool uHSLColorize;\n\tuniform float uOpacity;\n    \n    varying vec2 vTextureCoord;\n    \n    // All components are in the range [0\u20261], including hue.\n    vec3 rgb2hsv(vec3 c) {\n        vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n        vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n        vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n        float d = q.x - min(q.w, q.y);\n        float e = 1.0e-10;\n        return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n    }\n    \n\n    // All components are in the range [0\u20261], including hue.\n    vec3 hsv2rgb(vec3 c) {\n        vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n        vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n        return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n    }\n\n    void main(void) {\n        vec4 color = texture2D(uDiffuseTexture, vTextureCoord);\n\n        if(uHSLAdjust.r != 0. || uHSLAdjust.g != 0. || uHSLAdjust.b != 0.){\n            if(uHSLColorize){\n                // Desaturate...\n\n                // Convert to HSV\n                color.rgb = rgb2hsv(color.rgb);\n    \n                // Adjust\n                // color.r += 0.;\n                color.g = 0.;\n                // color.b += 0.;\n    \n                // Convert to RGB\n                color.rgb = hsv2rgb(color.rgb);\n            }\n\n            // Colorize...\n            // Convert to HSV\n            color.rgb = rgb2hsv(color.rgb);\n\n            // Adjust\n            color.r += uHSLAdjust.r;\n            color.g += uHSLAdjust.g;\n            color.b += uHSLAdjust.b;\n\n            // Convert to RGB\n            color.rgb = hsv2rgb(color.rgb);\n        }\n\n        color.a *= uOpacity;\n\n        // gl_FragColor = vec4(color.rgb * color.a, color.a);\n        gl_FragColor = color;\n\n        // gl_FragColor = vec4(1.,1.,0.,1.);\n        \n        if(gl_FragColor.a == 0.0) discard;\n    }\n";

  var MaterialSpriteColorized =
  /*#__PURE__*/
  function (_Onyx$Material) {
    _inherits(MaterialSpriteColorized, _Onyx$Material);

    function MaterialSpriteColorized() {
      var _this;

      _classCallCheck(this, MaterialSpriteColorized);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(MaterialSpriteColorized).apply(this, arguments));
      _this.vertexShader = VERTEX_SHADER$4;
      _this.fragmentShader = FRAG_SHADER$3;
      _this.blend = true;
      _this.depthTest = true;
      _this.cullFace = false;
      return _this;
    }

    _createClass(MaterialSpriteColorized, [{
      key: "render",
      value: function render(dt, scene, viewport, camera, stack, viewMatrix, modelMatrix, frameBufferTextureStack) {
        // Set uniforms (uMVMatrix, etc...)
        _get(_getPrototypeOf(MaterialSpriteColorized.prototype), "render", this).call(this, dt, scene, viewport, camera, stack, viewMatrix, modelMatrix, frameBufferTextureStack); // Parent Entity


        var entity = stack[stack.length - 3];
        var sprite = stack[stack.length - 2]; // Set current textures
        // let texture = entity.sprite.textures[entity.sprite._materialIndex];
        // if(texture.setAsTexture(viewport, 0, viewport.program.uniform.uDiffuseTexture) === false) return;

        if (sprite.textures[sprite._materialIndex].setAsTexture(viewport, 0, viewport.program.uniform.uDiffuseTexture) === false) return; // Set HSV adjust

        if (entity.HSV) viewport.webgl.uniform3fv(viewport.program.uniform.uHSLAdjust, entity.HSV);
        if (entity.HSV) viewport.webgl.uniform1i(viewport.program.uniform.uHSLColorize, entity.HSVColorize || false);
        viewport.webgl.uniform1f(viewport.program.uniform.uOpacity, entity.opacity !== undefined ? entity.opacity : 1); // // Enable transparency

        viewport.webgl.blendFunc(viewport.webgl.SRC_ALPHA, viewport.webgl.ONE_MINUS_SRC_ALPHA); // viewport.webgl.blendFunc(viewport.webgl.ONE, viewport.webgl.ONE_MINUS_SRC_ALPHA);
        // viewport.webgl.enable(viewport.webgl.BLEND);
      }
    }]);

    return MaterialSpriteColorized;
  }(Material);

  var MATERIAL = new MaterialSpriteColorized();
  var ANIMATIONS;

  var Actor =
  /*#__PURE__*/
  function (_Onyx$Entity) {
    _inherits(Actor, _Onyx$Entity);

    _createClass(Actor, [{
      key: "state",
      get: function get() {
        return this._state;
      },
      set: function set(val) {
        var oldVal = this._state;
        this._state = val;

        if (this.states[val]) {
          if (this.sprite) {
            if (!Array.isArray(this.states[val])) {
              this.sprite.selectAnimation(this.states[val]);
            } else {
              if (this.states[val][0] === "HIDDEN") {
                this.sprite.visible = false;
                return;
              } else {
                this.sprite.visible = true;
              }

              var rnd = Math.floor(Math.random() * this.states[val].length);
              this.sprite.selectAnimation(this.states[val][rnd]);
            }

            this.sprite.currentAnimation.play();
          }

          if (val !== oldVal) this.onStateChange(val, oldVal);
        } else {
          console.warn("State '".concat(val, "' not found."), this);
        }
      }
    }]);

    function Actor() {
      var _this;

      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var overrides = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      _classCallCheck(this, Actor);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(Actor).call(this)); // Load Defaults

      options = Actor.extend({
        sprite: {
          src: "res/textures/mm-0.json"
        },
        animations: {},
        states: {},
        audio: {},
        events: {},
        collidable: true,
        opacity: 1,
        spriteSpeed: 1000 / 12,
        pointerEvents: true,
        draggable: false,
        physics: true,
        gravityScale: 1,
        restitution: 0.1,
        terminalVelocity: 100,
        autoGroundLevel: true,
        defaultState: "idle",
        limitedToWorld: true,
        limitedToUpperBounds: true,
        sortableY: true,
        HSV: [0, 0, 0],
        scale: [1, 1, 1],
        state: null,
        flipX: false,
        flipY: false,
        hasPointerEvents: undefined,
        isPersistent: true,
        isStatic: false,
        isSensor: false,
        friction: 0.25,
        position: [0, 0, 0],
        rotation: [0, 0, 0],
        velocity: [0, 0, 0],
        animationStartFrame: 0,
        autoPhysicsBody: false,
        cls: "actor",
        data: {},
        body: null
      }, options); // Extend options with overrides

      Actor.extend(options, overrides);
      _this.constructorName = "Actor";
      _this.transform.xyz = _toConsumableArray(options.position); // this.transform.sxyz = [...options.scale];

      _this.transform.rotation = _toConsumableArray(options.rotation);
      _this.pointerEvents = options.hasPointerEvents !== undefined ? options.hasPointerEvents : options.pointerEvents;
      _this.physics = options.physics;
      _this.gravityScale = options.gravityScale;
      _this.restitution = options.restitution;
      _this.data = JSON.parse(JSON.stringify(options.data));
      _this.isPersistent = options.isPersistent;

      if (_this.physics) {
        // this.body = this.addComponent(new SimplePhysicsBody2D({
        //     gravityScale: options.gravityScale,
        //     restitution: options.restitution,
        //     terminalVelocity: options.terminalVelocity,
        //     collidable: options.collidable,
        //     limitedToWorld: options.limitedToWorld,
        //     limitedToUpperBounds: options.limitedToUpperBounds,
        //     velocity: options.velocity,
        //     isStatic: options.isStatic,
        //     isSensor: options.isSensor,
        //     friction: options.friction
        // }));
        // if(this.data.speed !== undefined) this.body.speed = this.data.speed;
        // if(options.body){
        //     this.body.width = options.body.width;
        //     this.body.height = options.body.height;
        //     this.body.bottom = options.body.bottom;
        //     this.body.left = options.body.left;
        // }
        if (options.body.shape === "circle") {
          _this.body = Matter.Bodies.circle(options.position[0], -options.position[1], options.body.radius * options.scale[0], options.body.options);
        } else {
          _this.body = Matter.Bodies.rectangle(options.position[0], -options.position[1], options.body.width * options.scale[0], options.body.height * options.scale[1], options.body.options);
        }

        _this.physicsEnabled = true;
        _this.body.parentEntity = _assertThisInitialized(_this);
        _this.body.prevVelocity = {
          x: 0,
          y: 0
        }; // Matter.Body.rotate(this.body, options.rotation[2]);
      }

      _this.className = options.cls;
      _this.states = options.states;
      _this._state = options.state || options.defaultState;
      _this.audio = options.audio;
      _this.isOnGround = false;
      _this.sortableY = options.sortableY;
      _this.autoPhysicsBody = options.autoPhysicsBody;
      _this.zoom = 1;
      _this._zoom = 1;
      _this.holdZoom = 0;
      _this.spriteSpeed = options.spriteSpeed;
      _this.velocityX = 0;
      _this.velocityY = 0;
      _this.opacity = options.opacity;
      options.sprite.flipX = options.flipX;
      options.sprite.flipY = options.flipY;

      if (Array.isArray(options.sprite.src) || options.sprite.src.split(".").pop() == "json") {
        _this.loadTexturePacker(options.sprite, options.animations, options.scale);
      } else {
        _this.loadSprite(sprite, options.animations, options.scale);
      }

      for (var _i = 0, _Object$keys = Object.keys(options.events); _i < _Object$keys.length; _i++) {
        var event = _Object$keys[_i];
        _this[event] = options.events[event];
      }

      _this.canHold = options.canHold;
      _this.canUse = options.canUse;
      _this.heldItems = [];
      _this.parentItems = [];
      _this.HSV = new Float32Array(3);

      _this.HSV.set(options.HSV); // this.transform.roll = options.roll;


      _this.isReady = false;
      _this.animationStartFrame = options.animationStartFrame;
      return _this;
    }

    _createClass(Actor, [{
      key: "update",
      value: function update() {
        _get(_getPrototypeOf(Actor.prototype), "update", this).apply(this, arguments);

        if (!this.enabled) return;
        if (!this.sprite || !this.parentScene) return;

        if (this.parentScene && this.physicsEnabled && this.parentScene.physicsEnabled) {
          this.transform.xyz = [this.body.position.x, -this.body.position.y, this.transform.z];
          this.transform.roll = -this.body.angle;
          this.body.prevVelocity = {
            x: this.body.velocity.x,
            y: this.body.velocity.y
          };
        }

        this.onUpdate();
        if (this.autoPhysicsBody) this.setPhysicsBody(); // if(this.physics && this.parentScene.selectedObject !== this) this.updatePhysics();
      }
    }, {
      key: "onSpawn",
      value: function onSpawn() {
        _get(_getPrototypeOf(Actor.prototype), "onSpawn", this).apply(this, arguments);

        this.checkReady();
      }
    }, {
      key: "onDestroy",
      value: function onDestroy() {
        _get(_getPrototypeOf(Actor.prototype), "onDestroy", this).apply(this, arguments);

        if (this.physicsEnabled) Matter.World.remove(this.parentScene.matterEngine.world, [this.body]);
      }
    }, {
      key: "checkReady",
      value: function checkReady() {
        if (this.sprite && this.parentScene) {
          if (this.physicsEnabled) Matter.World.add(this.parentScene.matterEngine.world, [this.body]);
          if (this.autoPhysicsBody) this.setPhysicsBody(); // this.setGroundLevel(0);

          this.sortComponentsByZ(true);
          this.isReady = true;
          this.onReady();
        } else {
          return false;
        }
      }
    }, {
      key: "onReady",
      value: function onReady() {}
    }, {
      key: "setPhysicsBody",
      value: function setPhysicsBody() {
        if (this.physics && this.body && this.sprite) {
          // if(this.roll){
          //     this.body.height = this.sprite.height * this.sprite.transform.sx;
          //     this.body.width = this.sprite.width * this.sprite.transform.sy;
          //     this.body.bottom = -this.body.width / 2;
          //     this.body.left = -this.body.height / 2;
          // }else{
          this.body.width = this.sprite.width * this.sprite.transform.sx;
          this.body.height = this.sprite.height * this.sprite.transform.sy;

          if (this.sprite.currentAnimation) {
            this.body.left = -this.body.width * this.sprite.currentAnimation.currentFrame.pivotX;
            this.body.bottom = -this.body.height * this.sprite.currentAnimation.currentFrame.pivotY;
          } else {
            this.body.left = -(this.body.width / 2);
            this.body.bottom = -(this.body.height / 2);
          } // }

        } else if (this.sprite) {
          this.width = this.sprite.width * this.sprite.transform.sx;
          this.height = this.sprite.height * this.sprite.transform.sy;

          if (this.sprite.currentAnimation) {
            this.left = -this.width * this.sprite.currentAnimation.currentFrame.pivotX;
            this.bottom = -this.height * this.sprite.currentAnimation.currentFrame.pivotY;
          } else {
            this.left = -(this.width / 2);
            this.bottom = -(this.height / 2);
          }
        }
      }
    }, {
      key: "loadSprite",
      value: function () {
        var _loadSprite = _asyncToGenerator(
        /*#__PURE__*/
        regeneratorRuntime.mark(function _callee(sprite) {
          var animations,
              scale,
              _args = arguments;
          return regeneratorRuntime.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  animations = _args.length > 1 && _args[1] !== undefined ? _args[1] : {};
                  scale = _args.length > 2 && _args[2] !== undefined ? _args[2] : [1, 1, 1];
                  this.sprite = new Sprite(sprite);
                  this.initSprite(this.sprite, animations, scale);
                  this.addComponent(this.sprite, animations, scale);
                  this.state = this._state;
                  this.checkReady();

                case 7:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee, this);
        }));

        function loadSprite(_x) {
          return _loadSprite.apply(this, arguments);
        }

        return loadSprite;
      }()
    }, {
      key: "loadTexturePacker",
      value: function () {
        var _loadTexturePacker = _asyncToGenerator(
        /*#__PURE__*/
        regeneratorRuntime.mark(function _callee2(sprite, animations) {
          var scale,
              _args2 = arguments;
          return regeneratorRuntime.wrap(function _callee2$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  scale = _args2.length > 2 && _args2[2] !== undefined ? _args2[2] : [1, 1, 1];

                  // Pull sprite's animations
                  if (Object.keys(game.spritesheets[sprite.src.split("/").pop()].animations).length) {
                    ANIMATIONS = game.spritesheets[sprite.src.split("/").pop()].animations;
                    game.spritesheets[sprite.src.split("/").pop()].animations = {};
                  }

                  _context2.next = 4;
                  return ImportSpriteFromTexturePacker.cloneSprite(game.spritesheets[sprite.src.split("/").pop()], true);

                case 4:
                  this.sprite = _context2.sent;
                  this.sprite.flipX = sprite.flipX;
                  this.sprite.flipY = sprite.flipY;
                  _context2.next = 9;
                  return this.initSprite(this.sprite, animations, scale);

                case 9:
                  this.addComponent(this.sprite, animations, scale);
                  this.state = this._state;
                  if (this.sprite.currentAnimation) this.sprite.currentAnimation.setFrame(this.animationStartFrame);
                  this.checkReady();

                case 13:
                case "end":
                  return _context2.stop();
              }
            }
          }, _callee2, this);
        }));

        function loadTexturePacker(_x2, _x3) {
          return _loadTexturePacker.apply(this, arguments);
        }

        return loadTexturePacker;
      }()
    }, {
      key: "initSprite",
      value: function () {
        var _initSprite = _asyncToGenerator(
        /*#__PURE__*/
        regeneratorRuntime.mark(function _callee3(sprite, animations) {
          var _this2 = this;

          var scale,
              usedAnims,
              _i2,
              _Object$values,
              state,
              _iteratorNormalCompletion,
              _didIteratorError,
              _iteratorError,
              _iterator,
              _step,
              animName,
              _i3,
              _Object$keys2,
              name,
              animation,
              i,
              _loop,
              _i4,
              _Object$keys3,
              _ret,
              _args3 = arguments;

          return regeneratorRuntime.wrap(function _callee3$(_context3) {
            while (1) {
              switch (_context3.prev = _context3.next) {
                case 0:
                  scale = _args3.length > 2 && _args3[2] !== undefined ? _args3[2] : [1, 1, 1];
                  sprite.transform.sxyz = [scale[0] * game.SPRITE_SCALE, scale[1] * game.SPRITE_SCALE, scale[2] * game.SPRITE_SCALE];
                  sprite.animations = {};
                  this.sprite.mesh.material = MATERIAL; // this.sprite.mesh.material = new MaterialSpriteColorized();
                  // Remove all unused animations...
                  // Find all used animations

                  usedAnims = [];
                  _i2 = 0, _Object$values = Object.values(this.states);

                case 6:
                  if (!(_i2 < _Object$values.length)) {
                    _context3.next = 30;
                    break;
                  }

                  state = _Object$values[_i2];
                  _iteratorNormalCompletion = true;
                  _didIteratorError = false;
                  _iteratorError = undefined;
                  _context3.prev = 11;

                  for (_iterator = state[Symbol.iterator](); !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                    animName = _step.value;
                    usedAnims.push(animName.split("=")[0]);
                  }

                  _context3.next = 19;
                  break;

                case 15:
                  _context3.prev = 15;
                  _context3.t0 = _context3["catch"](11);
                  _didIteratorError = true;
                  _iteratorError = _context3.t0;

                case 19:
                  _context3.prev = 19;
                  _context3.prev = 20;

                  if (!_iteratorNormalCompletion && _iterator["return"] != null) {
                    _iterator["return"]();
                  }

                case 22:
                  _context3.prev = 22;

                  if (!_didIteratorError) {
                    _context3.next = 25;
                    break;
                  }

                  throw _iteratorError;

                case 25:
                  return _context3.finish(22);

                case 26:
                  return _context3.finish(19);

                case 27:
                  _i2++;
                  _context3.next = 6;
                  break;

                case 30:
                  // Set animation speeds
                  for (_i3 = 0, _Object$keys2 = Object.keys(animations); _i3 < _Object$keys2.length; _i3++) {
                    name = _Object$keys2[_i3];
                    animation = ANIMATIONS[name];

                    for (i in animations[name].timing) {
                      animation.frames[i].speed = animations[name].timing[i];
                    }

                    if (animations[name].loop !== undefined) animation.loop = animations[name].loop;
                  } // Parse animation sequence from folder title


                  _loop = function _loop() {
                    var name = _Object$keys3[_i4];
                    // 
                    var parsedName = name.split("=")[0]; // If this isn't used...

                    if (usedAnims.indexOf(parsedName) < 0) {
                      return "continue";
                    }

                    var animation = ANIMATIONS[name];
                    sprite.animations[parsedName] = new SpriteAnimation(animation, sprite); //Object.assign({}, animation);

                    animation = sprite.animations[parsedName]; // Set speeds

                    var _iteratorNormalCompletion2 = true;
                    var _didIteratorError2 = false;
                    var _iteratorError2 = undefined;

                    try {
                      for (var _iterator2 = animation.frames[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                        var frame = _step2.value;
                        frame.speed = _this2.spriteSpeed;
                      } // Set frame order
                      // Clone, sort, and clear...

                    } catch (err) {
                      _didIteratorError2 = true;
                      _iteratorError2 = err;
                    } finally {
                      try {
                        if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
                          _iterator2["return"]();
                        }
                      } finally {
                        if (_didIteratorError2) {
                          throw _iteratorError2;
                        }
                      }
                    }

                    var frames = animation.frames.sort(function (a, b) {
                      if (a.name < b.name) return -1;
                      if (a.name > b.name) return 1;
                      return 0;
                    });

                    if (name.indexOf("=") > -1) {
                      // Parse order
                      var sequenceArr = name.split("=")[1].split(","); // frames.sort((a, b) => {return a.name < b.name});

                      if (!isNaN(sequenceArr[0])) animation.frames = [];
                      var _iteratorNormalCompletion3 = true;
                      var _didIteratorError3 = false;
                      var _iteratorError3 = undefined;

                      try {
                        for (var _iterator3 = sequenceArr[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                          var step = _step3.value;

                          if (step == '') {
                            // console.warn('space');
                            continue;
                          }

                          ;

                          (function () {
                            switch (step[0].toUpperCase()) {
                              case 'E':
                              case 'S':
                                animation.loop = false;
                                break;

                              case 'P':
                                var frame = animation.frames[animation.frames.length - 1];
                                var range = step.replace("P", "").split("-");

                                if (!range[1]) {
                                  frame.speed = range[0] * 1000;
                                } else {
                                  frame.onStart = function () {
                                    frame.speed = (Math.random() * range[1] + range[0]) * 1000;
                                  };
                                }

                                break;

                              case 'R':
                                var frameIndex = step.replace("R", "") - 1;

                                animation.frames[animation.frames.length - 1].onComplete = function () {
                                  animation.setFrame(frameIndex);
                                };

                                break;

                              case 'L':
                                animation.loop = true;
                                break;

                              case 'I':
                                animation.frames[animation.frames.length - 1].onComplete = function () {
                                  _this2.state = "idle";
                                };

                                break;

                              case 'V':
                                animation.frames[animation.frames.length - 1].onComplete = function () {
                                  _this2.visible = false;
                                };

                                break;

                              default:
                                animation.frames.push(Object.assign({}, frames[step - 1]));
                            }
                          })();
                        }
                      } catch (err) {
                        _didIteratorError3 = true;
                        _iteratorError3 = err;
                      } finally {
                        try {
                          if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
                            _iterator3["return"]();
                          }
                        } finally {
                          if (_didIteratorError3) {
                            throw _iteratorError3;
                          }
                        }
                      }
                    }
                  };

                  _i4 = 0, _Object$keys3 = Object.keys(ANIMATIONS);

                case 33:
                  if (!(_i4 < _Object$keys3.length)) {
                    _context3.next = 40;
                    break;
                  }

                  _ret = _loop();

                  if (!(_ret === "continue")) {
                    _context3.next = 37;
                    break;
                  }

                  return _context3.abrupt("continue", 37);

                case 37:
                  _i4++;
                  _context3.next = 33;
                  break;

                case 40:
                case "end":
                  return _context3.stop();
              }
            }
          }, _callee3, this, [[11, 15, 19, 27], [20,, 22, 26]]);
        }));

        function initSprite(_x4, _x5) {
          return _initSprite.apply(this, arguments);
        }

        return initSprite;
      }()
    }, {
      key: "save",
      value: function save() {
        if (!this.isPersistent) return;
        return {
          cls: this.className,
          position: _toConsumableArray(this.transform.xyz),
          scale: _toConsumableArray(this.sprite.transform.sxyz),
          flipX: this.sprite.flipX,
          flipY: this.sprite.flipY,
          state: this.state,
          data: this.data
        };
      }
    }, {
      key: "onStateChange",
      value: function onStateChange(newState, oldState) {} // setGroundLevel(offsetY = -100){
      //     if(this.body) this.body.bounds.bottom = Math.min(this.transform.y + this.body.bottom + offsetY, this.parentScene.groundEndY);
      // }

    }, {
      key: "onUpdate",
      value: function onUpdate() {}
    }, {
      key: "onStartDrag",
      value: function onStartDrag(evt) {
        this.isOnGround = false;
      }
    }, {
      key: "onHitFloor",
      value: function onHitFloor(event) {
        this.isOnGround = true;
      }
    }, {
      key: "onCollide",
      value: function onCollide(event, item) {// console.log(`Collide: ${this.className}:${item.className}`);
      }
    }], [{
      key: "extend",
      value: function extend(instance) {
        var newProperties = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        Object.keys(newProperties).forEach(function (key, index) {
          if (key === "_id") return;

          if (Array.isArray(newProperties[key])) {
            instance[key] = _toConsumableArray(newProperties[key]);
          } else if (newProperties[key] !== null && _typeof(newProperties[key]) === 'object') {
            instance[key] = {};
            Actor.extend(instance[key], newProperties[key]);
          } else {
            instance[key] = newProperties[key];
          }
        });
        return instance;
      }
    }]);

    return Actor;
  }(Entity);

  var MATERIAL$1 = new MaterialSpriteColorized();
  var SPRITE_POOL = [];

  var Text =
  /*#__PURE__*/
  function (_Onyx$Entity) {
    _inherits(Text, _Onyx$Entity);

    _createClass(Text, [{
      key: "value",
      get: function get() {
        return this.characters.join("");
      },
      set: function set(val) {
        if (val.toString() === this.characters.join("")) return;
        this.characters = val.toString().split("");
        this.buildSprites();
      }
    }]);

    function Text() {
      var _this;

      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          glyphSpriteSheet = _ref.glyphSpriteSheet,
          _ref$glyphAnimation = _ref.glyphAnimation,
          glyphAnimation = _ref$glyphAnimation === void 0 ? "" : _ref$glyphAnimation,
          _ref$glyphCharacters = _ref.glyphCharacters,
          glyphCharacters = _ref$glyphCharacters === void 0 ? "" : _ref$glyphCharacters,
          _ref$text = _ref.text,
          text = _ref$text === void 0 ? "" : _ref$text,
          _ref$align = _ref.align,
          align = _ref$align === void 0 ? "left" : _ref$align,
          _ref$alignVertical = _ref.alignVertical,
          alignVertical = _ref$alignVertical === void 0 ? "middle" : _ref$alignVertical,
          _ref$tracking = _ref.tracking,
          tracking = _ref$tracking === void 0 ? 4 : _ref$tracking,
          _ref$HSV = _ref.HSV,
          HSV = _ref$HSV === void 0 ? [0, 0, 0] : _ref$HSV,
          _ref$pointerEvents = _ref.pointerEvents;

      _classCallCheck(this, Text);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(Text).apply(this, arguments));
      _this.glyphSpriteSheet = glyphSpriteSheet;
      _this.glyphAnimation = glyphAnimation;
      _this.glyphCharacters = glyphCharacters;
      _this.sprites = [];
      _this.characters = [];
      _this.width = 0;
      _this.height = 0;
      _this.align = align;
      _this.alignVertical = alignVertical;
      _this.tracking = tracking;
      _this.value = text;
      _this.HSV = HSV;
      _this.pointerEvents = false;
      return _this;
    }

    _createClass(Text, [{
      key: "newSprite",
      value: function () {
        var _newSprite = _asyncToGenerator(
        /*#__PURE__*/
        regeneratorRuntime.mark(function _callee() {
          var sprite;
          return regeneratorRuntime.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  if (!SPRITE_POOL[0]) {
                    _context.next = 4;
                    break;
                  }

                  sprite = SPRITE_POOL.pop();
                  _context.next = 7;
                  break;

                case 4:
                  _context.next = 6;
                  return ImportSpriteFromTexturePacker.cloneSprite(this.glyphSpriteSheet, true);

                case 6:
                  sprite = _context.sent;

                case 7:
                  sprite.mesh.material = MATERIAL$1;
                  return _context.abrupt("return", sprite);

                case 9:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee, this);
        }));

        function newSprite() {
          return _newSprite.apply(this, arguments);
        }

        return newSprite;
      }()
    }, {
      key: "buildSprites",
      value: function () {
        var _buildSprites = _asyncToGenerator(
        /*#__PURE__*/
        regeneratorRuntime.mark(function _callee2() {
          var i, newChar, _i, _i2, _char, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, sprite, _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, _sprite, _iteratorNormalCompletion3, _didIteratorError3, _iteratorError3, _iterator3, _step3, _sprite2, _iteratorNormalCompletion4, _didIteratorError4, _iteratorError4, _iterator4, _step4, _sprite3;

          return regeneratorRuntime.wrap(function _callee2$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  this.width = 0;
                  this.height = 0; // Add any needed sprites

                  i = this.characters.length - this.sprites.length;

                case 3:
                  if (!(i > 0)) {
                    _context2.next = 12;
                    break;
                  }

                  _context2.next = 6;
                  return this.newSprite();

                case 6:
                  newChar = _context2.sent;
                  this.addComponent(newChar);
                  this.sprites.push(newChar);

                case 9:
                  i--;
                  _context2.next = 3;
                  break;

                case 12:
                  // Remove any extra
                  for (_i = this.sprites.length - this.characters.length; _i > 0; _i--) {
                    this.removeComponent(this.sprites[_i]);
                    SPRITE_POOL.push(this.sprites[_i]);
                    this.sprites.splice(_i, 1);
                  } // Place and select frame of any characters


                  for (_i2 in this.characters) {
                    _char = this.sprites[_i2];
                    _char.transform.x = this.width;

                    _char.selectAnimation(this.glyphAnimation, this.glyphCharacters.indexOf(this.characters[_i2]));

                    this.width += _char.currentAnimation.currentFrame.width + this.tracking;
                    this.height = Math.max(this.height, _char.currentAnimation.currentFrame.height);
                  } // Remove trailing space


                  this.width -= this.tracking;
                  _context2.t0 = this.align;
                  _context2.next = _context2.t0 === "center" ? 18 : _context2.t0 === "right" ? 38 : 58;
                  break;

                case 18:
                  _iteratorNormalCompletion = true;
                  _didIteratorError = false;
                  _iteratorError = undefined;
                  _context2.prev = 21;

                  for (_iterator = this.sprites[Symbol.iterator](); !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                    sprite = _step.value;
                    sprite.transform.x += -this.width / 2;
                  }

                  _context2.next = 29;
                  break;

                case 25:
                  _context2.prev = 25;
                  _context2.t1 = _context2["catch"](21);
                  _didIteratorError = true;
                  _iteratorError = _context2.t1;

                case 29:
                  _context2.prev = 29;
                  _context2.prev = 30;

                  if (!_iteratorNormalCompletion && _iterator["return"] != null) {
                    _iterator["return"]();
                  }

                case 32:
                  _context2.prev = 32;

                  if (!_didIteratorError) {
                    _context2.next = 35;
                    break;
                  }

                  throw _iteratorError;

                case 35:
                  return _context2.finish(32);

                case 36:
                  return _context2.finish(29);

                case 37:
                  return _context2.abrupt("break", 58);

                case 38:
                  _iteratorNormalCompletion2 = true;
                  _didIteratorError2 = false;
                  _iteratorError2 = undefined;
                  _context2.prev = 41;

                  for (_iterator2 = this.sprites[Symbol.iterator](); !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                    _sprite = _step2.value;
                    _sprite.transform.x += -this.width;
                  }

                  _context2.next = 49;
                  break;

                case 45:
                  _context2.prev = 45;
                  _context2.t2 = _context2["catch"](41);
                  _didIteratorError2 = true;
                  _iteratorError2 = _context2.t2;

                case 49:
                  _context2.prev = 49;
                  _context2.prev = 50;

                  if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
                    _iterator2["return"]();
                  }

                case 52:
                  _context2.prev = 52;

                  if (!_didIteratorError2) {
                    _context2.next = 55;
                    break;
                  }

                  throw _iteratorError2;

                case 55:
                  return _context2.finish(52);

                case 56:
                  return _context2.finish(49);

                case 57:
                  return _context2.abrupt("break", 58);

                case 58:
                  _context2.t3 = this.alignVertical;
                  _context2.next = _context2.t3 === "bottom" ? 61 : 81;
                  break;

                case 61:
                  _iteratorNormalCompletion3 = true;
                  _didIteratorError3 = false;
                  _iteratorError3 = undefined;
                  _context2.prev = 64;

                  for (_iterator3 = this.sprites[Symbol.iterator](); !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {// sprite.transform.y += -this.height;

                    _sprite2 = _step3.value;
                  }

                  _context2.next = 72;
                  break;

                case 68:
                  _context2.prev = 68;
                  _context2.t4 = _context2["catch"](64);
                  _didIteratorError3 = true;
                  _iteratorError3 = _context2.t4;

                case 72:
                  _context2.prev = 72;
                  _context2.prev = 73;

                  if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
                    _iterator3["return"]();
                  }

                case 75:
                  _context2.prev = 75;

                  if (!_didIteratorError3) {
                    _context2.next = 78;
                    break;
                  }

                  throw _iteratorError3;

                case 78:
                  return _context2.finish(75);

                case 79:
                  return _context2.finish(72);

                case 80:
                  return _context2.abrupt("break", 101);

                case 81:
                  _iteratorNormalCompletion4 = true;
                  _didIteratorError4 = false;
                  _iteratorError4 = undefined;
                  _context2.prev = 84;

                  for (_iterator4 = this.sprites[Symbol.iterator](); !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
                    _sprite3 = _step4.value;
                    _sprite3.transform.y += this.height + _sprite3.currentAnimation.currentFrame.offsetY;
                  }

                  _context2.next = 92;
                  break;

                case 88:
                  _context2.prev = 88;
                  _context2.t5 = _context2["catch"](84);
                  _didIteratorError4 = true;
                  _iteratorError4 = _context2.t5;

                case 92:
                  _context2.prev = 92;
                  _context2.prev = 93;

                  if (!_iteratorNormalCompletion4 && _iterator4["return"] != null) {
                    _iterator4["return"]();
                  }

                case 95:
                  _context2.prev = 95;

                  if (!_didIteratorError4) {
                    _context2.next = 98;
                    break;
                  }

                  throw _iteratorError4;

                case 98:
                  return _context2.finish(95);

                case 99:
                  return _context2.finish(92);

                case 100:
                  return _context2.abrupt("break", 101);

                case 101:
                case "end":
                  return _context2.stop();
              }
            }
          }, _callee2, this, [[21, 25, 29, 37], [30,, 32, 36], [41, 45, 49, 57], [50,, 52, 56], [64, 68, 72, 80], [73,, 75, 79], [84, 88, 92, 100], [93,, 95, 99]]);
        }));

        function buildSprites() {
          return _buildSprites.apply(this, arguments);
        }

        return buildSprites;
      }()
    }]);

    return Text;
  }(Entity);

  var Scooby =
  /*#__PURE__*/
  function (_Actor) {
    _inherits(Scooby, _Actor);

    function Scooby() {
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      _objectDestructuringEmpty(_ref);

      _classCallCheck(this, Scooby);

      return _possibleConstructorReturn(this, _getPrototypeOf(Scooby).apply(this, arguments));
    }

    _createClass(Scooby, [{
      key: "onUpdate",
      value: function onUpdate() {
        _get(_getPrototypeOf(Scooby.prototype), "onUpdate", this).apply(this, arguments); // if(!this.snack){


        this.snack = this.parentScene.snack;
        if (this.snack.direction === undefined) this.snack.direction = -1; // }

        if (this.state !== "REVERSE") {
          if (this.snack.direction < 0 && this.snack.transform.x > this.transform.x) {
            this.state = "REVERSE";
            this.snack.direction = 1;
          } else if (this.snack.direction > 0 && this.snack.transform.x < this.transform.x) {
            this.state = "REVERSE";
            this.snack.direction = -1;
          }
        }
      }
    }, {
      key: "onReady",
      value: function onReady() {
        var _this = this;

        this.state = "WAG-A";

        this.sprite.currentAnimation.onComplete = function () {
          _this.state = "WAG-B";
        };

        this.itv = this.setInterval(function () {
          _this.randomState();
        }, 3000);
      }
    }, {
      key: "randomState",
      value: function randomState() {
        var states = ["BLINK", "TILT", "TILTSMILE", "SMACK", "WAG"];
        if (this.state === "idle") this.state = states[Math.random() * states.length | 0];
      }
    }, {
      key: "wag",
      value: function wag() {
        if (this.state === "idle") this.state = "WAG";
      }
    }, {
      key: "showHearts",
      value: function showHearts(multiplier, isHoleInOne) {
        var _this2 = this;

        // multiplier += 9;
        if (!isHoleInOne) return;
        var scale = 1; //1 + (multiplier * 0.1);
        // this.transform.sxyz = [scale, scale, 1];

        this.heart = this.parentScene.addActor({
          cls: "UI-Heart",
          position: [0, 240 * scale, 1],
          events: {
            onReady: function onReady() {
              _this2.heart.sprite.transform.sxyz = [scale * 1.5, scale * 1.5, 1];
            }
          }
        }, false);
        this.addComponent(this.heart); // if(isHoleInOne){
        // 	this.heartBig = this.parentScene.addActor({
        // 		cls: "FX-Heart",
        // 		state: "heart" + ((multiplier > 1)?"B":"A"),
        // 		position: [0, 0, 1]
        // 	}, false);
        // 	this.addComponent(this.heartBig);
        // }

        this.setTween({
          propParent: this.heart.transform,
          property: "y",
          to: 207 * scale,
          from: 107 * scale,
          duration: 1000,
          method: "easeIn"
        });
        this.setTween({
          propParent: this.heart,
          property: "opacity",
          to: 0,
          from: 3,
          duration: 1000,
          method: "easeIn"
        }); // if(multiplier > 1){
        // 	this.txtMultiplier = new Text({
        // 		glyphSpriteSheet: game.spritesheets["mm-glyphs.json"],
        // 		glyphAnimation: "SD",
        // 		glyphCharacters: "0123456789^*,-H.+Xx",
        // 		text: "x" + multiplier,
        // 		align: "left",
        // 		alignVertical: "bottom",
        // 		tracking: 0,
        // 	});
        // 	this.txtMultiplier.transform.x = 22 * scale;
        // 	this.txtMultiplier.transform.sxyz = [scale, scale, 1];
        // 	this.addComponent(this.txtMultiplier);
        // 	this.setTween({
        // 		propParent: this.txtMultiplier.transform,
        // 		property: "y",
        // 		from: 60 * scale,
        // 		to: 160 * scale,
        // 		duration: 1000,
        // 		method: "easeIn"
        // 	});
        // 	this.setTween({
        // 		propParent: this.txtMultiplier,
        // 		property: "opacity",
        // 		from: 3,
        // 		to: 0,
        // 		duration: 1000,
        // 		method: "easeIn",
        // 		onComplete: () => {
        // 			this.removeComponent(this.txtMultiplier);
        // 		}
        // 	});
        // }
      }
    }]);

    return Scooby;
  }(Actor);

  function earcut(data, holeIndices, dim) {
    dim = dim || 2;
    var hasHoles = holeIndices && holeIndices.length,
        outerLen = hasHoles ? holeIndices[0] * dim : data.length,
        outerNode = linkedList(data, 0, outerLen, dim, true),
        triangles = [];
    if (!outerNode || outerNode.next === outerNode.prev) return triangles;
    var minX, minY, maxX, maxY, x, y, invSize;
    if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim); // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox

    if (data.length > 80 * dim) {
      minX = maxX = data[0];
      minY = maxY = data[1];

      for (var i = dim; i < outerLen; i += dim) {
        x = data[i];
        y = data[i + 1];
        if (x < minX) minX = x;
        if (y < minY) minY = y;
        if (x > maxX) maxX = x;
        if (y > maxY) maxY = y;
      } // minX, minY and invSize are later used to transform coords into integers for z-order calculation


      invSize = Math.max(maxX - minX, maxY - minY);
      invSize = invSize !== 0 ? 1 / invSize : 0;
    }

    earcutLinked(outerNode, triangles, dim, minX, minY, invSize);
    return triangles;
  } // create a circular doubly linked list from polygon points in the specified winding order


  function linkedList(data, start, end, dim, clockwise) {
    var i, last;

    if (clockwise === signedArea(data, start, end, dim) > 0) {
      for (i = start; i < end; i += dim) {
        last = insertNode(i, data[i], data[i + 1], last);
      }
    } else {
      for (i = end - dim; i >= start; i -= dim) {
        last = insertNode(i, data[i], data[i + 1], last);
      }
    }

    if (last && equals(last, last.next)) {
      removeNode(last);
      last = last.next;
    }

    return last;
  } // eliminate colinear or duplicate points


  function filterPoints(start, end) {
    if (!start) return start;
    if (!end) end = start;
    var p = start,
        again;

    do {
      again = false;

      if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
        removeNode(p);
        p = end = p.prev;
        if (p === p.next) break;
        again = true;
      } else {
        p = p.next;
      }
    } while (again || p !== end);

    return end;
  } // main ear slicing loop which triangulates a polygon (given as a linked list)


  function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
    if (!ear) return; // interlink polygon nodes in z-order

    if (!pass && invSize) indexCurve(ear, minX, minY, invSize);
    var stop = ear,
        prev,
        next; // iterate through ears, slicing them one by one

    while (ear.prev !== ear.next) {
      prev = ear.prev;
      next = ear.next;

      if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
        // cut off the triangle
        triangles.push(prev.i / dim);
        triangles.push(ear.i / dim);
        triangles.push(next.i / dim);
        removeNode(ear); // skipping the next vertex leads to less sliver triangles

        ear = next.next;
        stop = next.next;
        continue;
      }

      ear = next; // if we looped through the whole remaining polygon and can't find any more ears

      if (ear === stop) {
        // try filtering points and slicing again
        if (!pass) {
          earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1); // if this didn't work, try curing all small self-intersections locally
        } else if (pass === 1) {
          ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
          earcutLinked(ear, triangles, dim, minX, minY, invSize, 2); // as a last resort, try splitting the remaining polygon into two
        } else if (pass === 2) {
          splitEarcut(ear, triangles, dim, minX, minY, invSize);
        }

        break;
      }
    }
  } // check whether a polygon node forms a valid ear with adjacent nodes


  function isEar(ear) {
    var a = ear.prev,
        b = ear,
        c = ear.next;
    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear
    // now make sure we don't have other points inside the potential ear

    var p = ear.next.next;

    while (p !== ear.prev) {
      if (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
      p = p.next;
    }

    return true;
  }

  function isEarHashed(ear, minX, minY, invSize) {
    var a = ear.prev,
        b = ear,
        c = ear.next;
    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear
    // triangle bbox; min & max are calculated like this for speed

    var minTX = a.x < b.x ? a.x < c.x ? a.x : c.x : b.x < c.x ? b.x : c.x,
        minTY = a.y < b.y ? a.y < c.y ? a.y : c.y : b.y < c.y ? b.y : c.y,
        maxTX = a.x > b.x ? a.x > c.x ? a.x : c.x : b.x > c.x ? b.x : c.x,
        maxTY = a.y > b.y ? a.y > c.y ? a.y : c.y : b.y > c.y ? b.y : c.y; // z-order range for the current triangle bbox;

    var minZ = zOrder(minTX, minTY, minX, minY, invSize),
        maxZ = zOrder(maxTX, maxTY, minX, minY, invSize);
    var p = ear.prevZ,
        n = ear.nextZ; // look for points inside the triangle in both directions

    while (p && p.z >= minZ && n && n.z <= maxZ) {
      if (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
      p = p.prevZ;
      if (n !== ear.prev && n !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;
      n = n.nextZ;
    } // look for remaining points in decreasing z-order


    while (p && p.z >= minZ) {
      if (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
      p = p.prevZ;
    } // look for remaining points in increasing z-order


    while (n && n.z <= maxZ) {
      if (n !== ear.prev && n !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;
      n = n.nextZ;
    }

    return true;
  } // go through all polygon nodes and cure small local self-intersections


  function cureLocalIntersections(start, triangles, dim) {
    var p = start;

    do {
      var a = p.prev,
          b = p.next.next;

      if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {
        triangles.push(a.i / dim);
        triangles.push(p.i / dim);
        triangles.push(b.i / dim); // remove two nodes involved

        removeNode(p);
        removeNode(p.next);
        p = start = b;
      }

      p = p.next;
    } while (p !== start);

    return filterPoints(p);
  } // try splitting polygon into two and triangulate them independently


  function splitEarcut(start, triangles, dim, minX, minY, invSize) {
    // look for a valid diagonal that divides the polygon into two
    var a = start;

    do {
      var b = a.next.next;

      while (b !== a.prev) {
        if (a.i !== b.i && isValidDiagonal(a, b)) {
          // split the polygon in two by the diagonal
          var c = splitPolygon(a, b); // filter colinear points around the cuts

          a = filterPoints(a, a.next);
          c = filterPoints(c, c.next); // run earcut on each half

          earcutLinked(a, triangles, dim, minX, minY, invSize);
          earcutLinked(c, triangles, dim, minX, minY, invSize);
          return;
        }

        b = b.next;
      }

      a = a.next;
    } while (a !== start);
  } // link every hole into the outer loop, producing a single-ring polygon without holes


  function eliminateHoles(data, holeIndices, outerNode, dim) {
    var queue = [],
        i,
        len,
        start,
        end,
        list;

    for (i = 0, len = holeIndices.length; i < len; i++) {
      start = holeIndices[i] * dim;
      end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
      list = linkedList(data, start, end, dim, false);
      if (list === list.next) list.steiner = true;
      queue.push(getLeftmost(list));
    }

    queue.sort(compareX); // process holes from left to right

    for (i = 0; i < queue.length; i++) {
      eliminateHole(queue[i], outerNode);
      outerNode = filterPoints(outerNode, outerNode.next);
    }

    return outerNode;
  }

  function compareX(a, b) {
    return a.x - b.x;
  } // find a bridge between vertices that connects hole with an outer ring and and link it


  function eliminateHole(hole, outerNode) {
    outerNode = findHoleBridge(hole, outerNode);

    if (outerNode) {
      var b = splitPolygon(outerNode, hole); // filter collinear points around the cuts

      filterPoints(outerNode, outerNode.next);
      filterPoints(b, b.next);
    }
  } // David Eberly's algorithm for finding a bridge between hole and outer polygon


  function findHoleBridge(hole, outerNode) {
    var p = outerNode,
        hx = hole.x,
        hy = hole.y,
        qx = -Infinity,
        m; // find a segment intersected by a ray from the hole's leftmost point to the left;
    // segment's endpoint with lesser x will be potential connection point

    do {
      if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
        var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);

        if (x <= hx && x > qx) {
          qx = x;

          if (x === hx) {
            if (hy === p.y) return p;
            if (hy === p.next.y) return p.next;
          }

          m = p.x < p.next.x ? p : p.next;
        }
      }

      p = p.next;
    } while (p !== outerNode);

    if (!m) return null;
    if (hx === qx) return m; // hole touches outer segment; pick leftmost endpoint
    // look for points inside the triangle of hole point, segment intersection and endpoint;
    // if there are no points found, we have a valid connection;
    // otherwise choose the point of the minimum angle with the ray as connection point

    var stop = m,
        mx = m.x,
        my = m.y,
        tanMin = Infinity,
        tan;
    p = m;

    do {
      if (hx >= p.x && p.x >= mx && hx !== p.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {
        tan = Math.abs(hy - p.y) / (hx - p.x); // tangential

        if (locallyInside(p, hole) && (tan < tanMin || tan === tanMin && (p.x > m.x || p.x === m.x && sectorContainsSector(m, p)))) {
          m = p;
          tanMin = tan;
        }
      }

      p = p.next;
    } while (p !== stop);

    return m;
  } // whether sector in vertex m contains sector in vertex p in the same coordinates


  function sectorContainsSector(m, p) {
    return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;
  } // interlink polygon nodes in z-order


  function indexCurve(start, minX, minY, invSize) {
    var p = start;

    do {
      if (p.z === null) p.z = zOrder(p.x, p.y, minX, minY, invSize);
      p.prevZ = p.prev;
      p.nextZ = p.next;
      p = p.next;
    } while (p !== start);

    p.prevZ.nextZ = null;
    p.prevZ = null;
    sortLinked(p);
  } // Simon Tatham's linked list merge sort algorithm
  // http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html


  function sortLinked(list) {
    var i,
        p,
        q,
        e,
        tail,
        numMerges,
        pSize,
        qSize,
        inSize = 1;

    do {
      p = list;
      list = null;
      tail = null;
      numMerges = 0;

      while (p) {
        numMerges++;
        q = p;
        pSize = 0;

        for (i = 0; i < inSize; i++) {
          pSize++;
          q = q.nextZ;
          if (!q) break;
        }

        qSize = inSize;

        while (pSize > 0 || qSize > 0 && q) {
          if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
            e = p;
            p = p.nextZ;
            pSize--;
          } else {
            e = q;
            q = q.nextZ;
            qSize--;
          }

          if (tail) tail.nextZ = e;else list = e;
          e.prevZ = tail;
          tail = e;
        }

        p = q;
      }

      tail.nextZ = null;
      inSize *= 2;
    } while (numMerges > 1);

    return list;
  } // z-order of a point given coords and inverse of the longer side of data bbox


  function zOrder(x, y, minX, minY, invSize) {
    // coords are transformed into non-negative 15-bit integer range
    x = 32767 * (x - minX) * invSize;
    y = 32767 * (y - minY) * invSize;
    x = (x | x << 8) & 0x00FF00FF;
    x = (x | x << 4) & 0x0F0F0F0F;
    x = (x | x << 2) & 0x33333333;
    x = (x | x << 1) & 0x55555555;
    y = (y | y << 8) & 0x00FF00FF;
    y = (y | y << 4) & 0x0F0F0F0F;
    y = (y | y << 2) & 0x33333333;
    y = (y | y << 1) & 0x55555555;
    return x | y << 1;
  } // find the leftmost node of a polygon ring


  function getLeftmost(start) {
    var p = start,
        leftmost = start;

    do {
      if (p.x < leftmost.x || p.x === leftmost.x && p.y < leftmost.y) leftmost = p;
      p = p.next;
    } while (p !== start);

    return leftmost;
  } // check if a point lies within a convex triangle


  function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
    return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 && (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 && (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;
  } // check if a diagonal between two polygon nodes is valid (lies in polygon interior)


  function isValidDiagonal(a, b) {
    return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && ( // dones't intersect other edges
    locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && ( // locally visible
    area(a.prev, a, b.prev) || area(a, b.prev, b)) || // does not create opposite-facing sectors
    equals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0); // special zero-length case
  } // signed area of a triangle


  function area(p, q, r) {
    return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
  } // check if two points are equal


  function equals(p1, p2) {
    return p1.x === p2.x && p1.y === p2.y;
  } // check if two segments intersect


  function intersects(p1, q1, p2, q2) {
    var o1 = sign(area(p1, q1, p2));
    var o2 = sign(area(p1, q1, q2));
    var o3 = sign(area(p2, q2, p1));
    var o4 = sign(area(p2, q2, q1));
    if (o1 !== o2 && o3 !== o4) return true; // general case

    if (o1 === 0 && onSegment(p1, p2, q1)) return true; // p1, q1 and p2 are collinear and p2 lies on p1q1

    if (o2 === 0 && onSegment(p1, q2, q1)) return true; // p1, q1 and q2 are collinear and q2 lies on p1q1

    if (o3 === 0 && onSegment(p2, p1, q2)) return true; // p2, q2 and p1 are collinear and p1 lies on p2q2

    if (o4 === 0 && onSegment(p2, q1, q2)) return true; // p2, q2 and q1 are collinear and q1 lies on p2q2

    return false;
  } // for collinear points p, q, r, check if point q lies on segment pr


  function onSegment(p, q, r) {
    return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);
  }

  function sign(num) {
    return num > 0 ? 1 : num < 0 ? -1 : 0;
  } // check if a polygon diagonal intersects any polygon segments


  function intersectsPolygon(a, b) {
    var p = a;

    do {
      if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i && intersects(p, p.next, a, b)) return true;
      p = p.next;
    } while (p !== a);

    return false;
  } // check if a polygon diagonal is locally inside the polygon


  function locallyInside(a, b) {
    return area(a.prev, a, a.next) < 0 ? area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 : area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
  } // check if the middle point of a polygon diagonal is inside the polygon


  function middleInside(a, b) {
    var p = a,
        inside = false,
        px = (a.x + b.x) / 2,
        py = (a.y + b.y) / 2;

    do {
      if (p.y > py !== p.next.y > py && p.next.y !== p.y && px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x) inside = !inside;
      p = p.next;
    } while (p !== a);

    return inside;
  } // link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
  // if one belongs to the outer ring and another to a hole, it merges it into a single ring


  function splitPolygon(a, b) {
    var a2 = new Node$1(a.i, a.x, a.y),
        b2 = new Node$1(b.i, b.x, b.y),
        an = a.next,
        bp = b.prev;
    a.next = b;
    b.prev = a;
    a2.next = an;
    an.prev = a2;
    b2.next = a2;
    a2.prev = b2;
    bp.next = b2;
    b2.prev = bp;
    return b2;
  } // create a node and optionally link it with previous one (in a circular doubly linked list)


  function insertNode(i, x, y, last) {
    var p = new Node$1(i, x, y);

    if (!last) {
      p.prev = p;
      p.next = p;
    } else {
      p.next = last.next;
      p.prev = last;
      last.next.prev = p;
      last.next = p;
    }

    return p;
  }

  function removeNode(p) {
    p.next.prev = p.prev;
    p.prev.next = p.next;
    if (p.prevZ) p.prevZ.nextZ = p.nextZ;
    if (p.nextZ) p.nextZ.prevZ = p.prevZ;
  }

  function Node$1(i, x, y) {
    // vertex index in coordinates array
    this.i = i; // vertex coordinates

    this.x = x;
    this.y = y; // previous and next vertex nodes in a polygon ring

    this.prev = null;
    this.next = null; // z-order curve value

    this.z = null; // previous and next nodes in z-order

    this.prevZ = null;
    this.nextZ = null; // indicates whether this is a steiner point

    this.steiner = false;
  } // return a percentage difference between the polygon area and its triangulation area;
  // used to verify correctness of triangulation


  earcut.deviation = function (data, holeIndices, dim, triangles) {
    var hasHoles = holeIndices && holeIndices.length;
    var outerLen = hasHoles ? holeIndices[0] * dim : data.length;
    var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));

    if (hasHoles) {
      for (var i = 0, len = holeIndices.length; i < len; i++) {
        var start = holeIndices[i] * dim;
        var end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
        polygonArea -= Math.abs(signedArea(data, start, end, dim));
      }
    }

    var trianglesArea = 0;

    for (i = 0; i < triangles.length; i += 3) {
      var a = triangles[i] * dim;
      var b = triangles[i + 1] * dim;
      var c = triangles[i + 2] * dim;
      trianglesArea += Math.abs((data[a] - data[c]) * (data[b + 1] - data[a + 1]) - (data[a] - data[b]) * (data[c + 1] - data[a + 1]));
    }

    return polygonArea === 0 && trianglesArea === 0 ? 0 : Math.abs((trianglesArea - polygonArea) / polygonArea);
  };

  function signedArea(data, start, end, dim) {
    var sum = 0;

    for (var i = start, j = end - dim; i < end; i += dim) {
      sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
      j = i;
    }

    return sum;
  } // turn a polygon in a multi-dimensional array form (e.g. as in GeoJSON) into a form Earcut accepts


  earcut.flatten = function (data) {
    var dim = data[0][0].length,
        result = {
      vertices: [],
      holes: [],
      dimensions: dim
    },
        holeIndex = 0;

    for (var i = 0; i < data.length; i++) {
      for (var j = 0; j < data[i].length; j++) {
        for (var d = 0; d < dim; d++) {
          result.vertices.push(data[i][j][d]);
        }
      }

      if (i > 0) {
        holeIndex += data[i - 1].length;
        result.holes.push(holeIndex);
      }
    }

    return result;
  };

  var Snack =
  /*#__PURE__*/
  function (_Actor) {
    _inherits(Snack, _Actor);

    function Snack() {
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      _objectDestructuringEmpty(_ref);

      _classCallCheck(this, Snack);

      return _possibleConstructorReturn(this, _getPrototypeOf(Snack).apply(this, arguments));
    }

    _createClass(Snack, [{
      key: "onCollide",
      value: function onCollide(_ref2) {
        var event = _ref2.event,
            relativeMomentum = _ref2.relativeMomentum;
        // console.log(event, relativeMomentum);
        this.parentScene.onCompleted();
      }
    }]);

    return Snack;
  }(Actor);

  var Cursor =
  /*#__PURE__*/
  function (_Actor) {
    _inherits(Cursor, _Actor);

    function Cursor() {
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      _objectDestructuringEmpty(_ref);

      _classCallCheck(this, Cursor);

      return _possibleConstructorReturn(this, _getPrototypeOf(Cursor).apply(this, arguments));
    }

    _createClass(Cursor, [{
      key: "onReady",
      value: function onReady() {
        this.arm = this.parentScene.addActor({
          cls: "UI-Cursor-Arm",
          position: [0, 0, 1]
        }, false);
        this.addComponent(this.arm);
        this.tip = this.parentScene.addActor({
          cls: "UI-Cursor-Tip",
          position: [0, 0, 2]
        }, false);
        this.addComponent(this.tip);
      }
    }, {
      key: "onUpdate",
      value: function onUpdate() {
        _get(_getPrototypeOf(Cursor.prototype), "onUpdate", this).apply(this, arguments);

        var opacity =  1 ;
        this.opacity = this.arm.opacity = this.tip.opacity = opacity;
      }
    }, {
      key: "length",
      set: function set(value) {
        // Scale force
        value = Math.max(0.01, value / 50);
        this.arm.transform.sx = value;
        this.tip.transform.sx = value;
      }
    }]);

    return Cursor;
  }(Actor);

  var Boo =
  /*#__PURE__*/
  function (_Actor) {
    _inherits(Boo, _Actor);

    function Boo() {
      var _this;

      _classCallCheck(this, Boo);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(Boo).apply(this, arguments));
      _this.constructorName = "Boo";
      _this.allowReset = false;
      return _this;
    }

    _createClass(Boo, [{
      key: "onUpdate",
      value: function onUpdate() {
        _get(_getPrototypeOf(Boo.prototype), "onUpdate", this).apply(this, arguments);
      }
    }, {
      key: "onReady",
      value: function onReady() {
        this.dust = this.parentScene.addActor({
          cls: "SK-Boo-Dust",
          position: [-this.transform.x, -this.transform.y, 1],
          events: {
            onReady: function onReady() {
              var _this2 = this;

              this.sprite.currentAnimation.onComplete = function () {
                _this2.visible = false;
              };
            }
          }
        }, false);
        this.addComponent(this.dust);
        this.dust.visible = false;
        this.arm = this.parentScene.addActor({
          cls: "SK-Arm",
          position: [-this.transform.x, -this.transform.y, 1],
          events: {
            onReady: function onReady() {
              var _this3 = this;

              this.sprite.currentAnimation.onComplete = function () {
                _this3.visible = false;

                _this3.parentScene.removeComponent(_this3);
              };

              this.sprite.currentAnimation.pause();
            }
          }
        }, false);
        this.addComponent(this.arm);
        this.arm.visible = false;
        this.opacity = 0; // this.setTimeout(() => {
        // 	this.onReadyToAppear();
        // }, 10000);
      }
    }, {
      key: "onReadyToAppear",
      value: function onReadyToAppear() {
        if (this.allowReset || this.twnAppear) return;
        this.allowReset = true;
        this.state = "idle";
        this.twnAppear = this.setTween({
          propParent: this,
          property: "opacity",
          from: 0,
          to: 1,
          method: "easeIn",
          duration: 1000
        }); // this.removeComponent(this.resetTimer);
      }
    }, {
      key: "showInstructions",
      value: function showInstructions() {
        var _this4 = this;

        if (this.arm) this.timArmInstructions = this.setTimeout(function () {
          _this4.arm.state = "idle";
          _this4.arm.visible = true;
        }, 500);
      }
    }, {
      key: "hideInstructions",
      value: function hideInstructions(permanently) {
        if (permanently) {
          this.removeComponent(this.arm);
        } else {
          this.arm.visible = false;
        }

        this.removeComponent(this.timArmInstructions);
      }
    }, {
      key: "lightningFlash",
      value: function lightningFlash(intensity, callback) {
        var _this5 = this;

        this.parentScene.background.HSV = [0, -1, intensity];
        this.parentScene.scooby.HSV = [0, -1, -intensity];
        this.parentScene.snack.HSV = [0, -1, -intensity];
        this.setTimeout(function () {
          _this5.parentScene.background.HSV = [0, 0, 0];
          _this5.parentScene.scooby.HSV = [0, 0, 0];
          _this5.parentScene.snack.HSV = [0, 0, 0];
          if (callback) callback();
        }, 64);
      }
    }, {
      key: "onLevelReset",
      value: function onLevelReset(callback) {
        var _this6 = this;

        if (!this.allowReset) return;
        this.allowReset = false;
        game.playSFX("SD-transition");
        this.lightningFlash(1, function () {
          _this6.setTimeout(function () {
            _this6.lightningFlash(0.5, function () {
              if (callback) callback();
            });
          }, 100);
        });
        this.state = "reset";
        this.dust.state = "idle";
        this.dust.visible = true;
        this.hideInstructions(true); // Fade away for 10 seconds

        this.setTween({
          propParent: this,
          property: "opacity",
          from: 1,
          to: 0,
          method: "easeIn",
          duration: 1000
        }); // this.resetTimer = this.setTimeout(() => {
        // 	this.onReadyToAppear();
        // }, 10000);

        this.removeComponent(this.twnAppear);
        this.twnAppear = null;
      }
    }]);

    return Boo;
  }(Actor);

  var SPR_WIDTH = 5500;

  var Fog =
  /*#__PURE__*/
  function (_Actor) {
    _inherits(Fog, _Actor);

    function Fog() {
      var _this;

      _classCallCheck(this, Fog);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(Fog).apply(this, arguments));
      _this.constructorName = "Fog";
      return _this;
    }

    _createClass(Fog, [{
      key: "onUpdate",
      value: function onUpdate() {
        _get(_getPrototypeOf(Fog.prototype), "onUpdate", this).apply(this, arguments);

        this.transform.x -= 0.25; // Check if offscreen

        if (this.transform.x + SPR_WIDTH < 0) {
          this.onOffscreen();
        }
      }
    }, {
      key: "onOffscreen",
      value: function onOffscreen() {
        this.transform.x += SPR_WIDTH + 1000;
      }
    }]);

    return Fog;
  }(Actor);

  var DURATION = 250;

  var Toasty =
  /*#__PURE__*/
  function (_Actor) {
    _inherits(Toasty, _Actor);

    function Toasty() {
      var _this;

      _classCallCheck(this, Toasty);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(Toasty).apply(this, arguments));
      _this.constructorName = "Toasty";
      _this.isDismissed = false;
      _this.timer = null;
      _this.tween = null;
      return _this;
    }

    _createClass(Toasty, [{
      key: "show",
      value: function show(state) {
        var _this2 = this;

        this.isDismissed = false;
        this.visible = true;
        this.removeComponent(this.timer);
        this.removeComponent(this.tween);
        if (state) this.state = state;
        this.tween = this.setTween({
          propParent: this.transform,
          property: "x",
          to: 0,
          from: this.transform.x,
          duration: DURATION,
          method: "easeIn",
          onComplete: function onComplete() {
            // this.visible = true;
            game.playRandomSFX(["SD-Toasty-#"]);
            _this2.timer = _this2.setTimeout(function () {
              _this2.dismiss();
            }, 1000);
          }
        });
      }
    }, {
      key: "dismiss",
      value: function dismiss() {
        var _this3 = this;

        this.isDismissed = true;
        this.removeComponent(this.timer);
        this.removeComponent(this.tween);
        this.tween = this.setTween({
          propParent: this.transform,
          property: "x",
          to: -500,
          from: this.transform.x,
          duration: DURATION,
          method: "easeIn",
          onComplete: function onComplete() {
            _this3.visible = false;
          }
        });
      }
    }]);

    return Toasty;
  }(Actor);

  var Instructions =
  /*#__PURE__*/
  function (_Actor) {
    _inherits(Instructions, _Actor);

    function Instructions() {
      var _this;

      _classCallCheck(this, Instructions);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(Instructions).apply(this, arguments));
      _this.constructorName = "Instructions";
      _this.isDismissing = false;
      _this.shotsTaken = 0;
      return _this;
    }

    _createClass(Instructions, [{
      key: "onReady",
      value: function onReady() {
        var _this2 = this;

        this.cookie = this.parentScene.addActor({
          cls: "IN-COOKIE",
          position: [0, 0, 1]
        }, false);
        this.addComponent(this.cookie);
        this.cookie.visible = false;

        this.sprite.currentAnimation.frames[28].onStart = this.sprite.currentAnimation.frames[63].onStart = function () {
          _this2.fireCookie();
        };

        this.sprite.currentAnimation.frames[5].onStart = this.sprite.currentAnimation.frames[40].onStart = function () {
          game.playRandomSFX(["SD-Tap-Drip-1", "SD-Tap-Drip-1", "SD-Tap-Squeak"]);
        };

        var frames = [9, 10, 11, 12, 15, 16, 17, 18, 19, 21, 22, 23, 24, 44, 45, 46, 47, 50, 51, 52, 53, 54, 56, 57, 58, 59];

        for (var _i = 0, _frames = frames; _i < _frames.length; _i++) {
          var frame = _frames[_i];

          this.sprite.currentAnimation.frames[frame].onStart = function () {
            game.playSFX("SD-Aim-01-Dn");
          };
        }

        this.sprite.currentAnimation.onComplete = function () {
          return _this2.dismiss(true);
        };

        this.sprite.currentAnimation.pause();
      }
    }, {
      key: "dismiss",
      value: function dismiss(instant) {
        var _this3 = this;

        this.parentScene.snack.visible = true;

        if (instant) {
          this.parentScene.remove(this);
        } else {
          if (this.isDismissing) return;
          this.isDismissing = true;
          this.twnDisappear = this.setTween({
            propParent: this,
            property: "opacity",
            from: 1,
            to: 0,
            method: "easeIn",
            duration: 1000,
            onComplete: function onComplete() {
              _this3.parentScene.remove(_this3);
            }
          });
        }
      }
    }, {
      key: "fireCookie",
      value: function fireCookie() {
        var _this4 = this;

        if (this.isDismissing) return;
        this.cookie.transform.xyz = _toConsumableArray(this.parentScene.snack.transform.xyz);
        this.cookie.state = "idle";
        this.cookie.visible = true;
        this.parentScene.snack.visible = false;
        this.setTimeout(function () {
          _this4.parentScene.scooby.state = "REVERSE";
        }, 512);
        this.setTimeout(function () {
          _this4.parentScene.snack.visible = true;
        }, 512);
        game.playRandomSFX(["SD-Launch-#"]);
        this.shotsTaken++;
      }
    }]);

    return Instructions;
  }(Actor);

  var CONFIG = {
    meta: {
      title: "SCOOBY DOO",
      version: "20.10.07.01",
      defaultHighScores: [10],
      startCookies: 0,
      // Set to 0 to disable cookie counting
      score: {
        holeInOne: 1,
        goal: 1
      },
      buttons: {
        arrowStayOnSnack: false,
        allowShootBeforeRest: true,
        gamepad: {
          "continue": [],
          // Blank = any
          skip: [9],
          jump: [0, 3, 12, 13, 4, 7],
          dash: [1, 2, 14, 15, 5, 6]
        }
      },
      backgrounds: ["BG-01", "BG-02", "BG-03", "BG-04", "BG-05", "BG-06", "BG-07", "BG-08", "BG-09", "BG-10", "BG-11", "BG-12", "BG-13"],
      cameos: ["ChrisPaul-01", "AbeLincoln-01", "WandaSykes-01", "SherlockHolmes-01", "RickyGervais-01", "WonderWoman-01", "PennTeller-01", "Urkel-01", "JimGaffigan-01", "WeirdAl-01", "Sia-01", "KeenanThompson-01", "Batman-01"],
      cameosAlt: ["ChrisPaul-02", "AbeLincoln-02", "WandaSykes-02", "SherlockHolmes-02", "RickyGervais-02", "WonderWoman-02", "PennTeller-02", "Urkel-02", "JimGaffigan-02", "WeirdAl-02", "Sia-02", "KeenanThompson-02", "Batman-02"],
      cameosVillains: ["V-1", "V-2", "V-3", "V-4", "V-5", "V-6", "V-7", "V-8", "V-9", "V-10", "V-11", "V-12", "V-13"],
      cameosGang: ["Daphne-01", "Fred-01", "Velma-01", "Shaggy-01", "Scooby-01", "Daphne-02", "Fred-02", "Velma-02", "Shaggy-02", "Scooby-02"],
      // "V-2-2", 
      physics: {
        // "Accuracy" of physics (higher means more accurate but more CPU)
        positionIterations: 6,
        velocityIterations: 4,
        constraintIterations: 1,
        // World properties
        gravity: 1.2,
        speed: 0.8,
        // Game mechanics
        hitForce: 0.6,
        hitForceMax: 74
      },
      levelDifficultyRamp: 25,
      generator: {
        x_width: 80,
        // 80
        y_height: 30,
        // 10 / 30
        change_y_odds: 30,
        // 33
        ground_friction: 5000,
        y_height_range: 20,
        change_y_odds_range: 15
      }
    },
    classes: {
      "BG-Base": {
        states: {
          "BG-01": ["BG/BG-Base/BG-01"],
          "BG-02": ["BG/BG-Base/BG-02"],
          "BG-03": ["BG/BG-Base/BG-03"],
          "BG-04": ["BG/BG-Base/BG-04"],
          "BG-05": ["BG/BG-Base/BG-05"],
          "BG-06": ["BG/BG-Base/BG-06"],
          "BG-07": ["BG/BG-Base/BG-07"],
          "BG-08": ["BG/BG-Base/BG-08"],
          "BG-09": ["BG/BG-Base/BG-09"],
          "BG-10": ["BG/BG-Base/BG-10"],
          "BG-11": ["BG/BG-Base/BG-11"],
          "BG-12": ["BG/BG-Base/BG-12"],
          "BG-13": ["BG/BG-Base/BG-13"],
          "BG-14": ["BG/BG-Base/BG-14"]
        },
        scale: [1.525, 1.525, 1],
        //2.3
        pointerEvents: false,
        physics: false
      },
      "BG-Frame": {
        states: {
          "idle": ["BG/BG-Frame"]
        },
        scale: [1.525, 1.525, 1],
        //2.3
        pointerEvents: false,
        physics: false
      },
      "BG-Moon": {
        states: {
          "idle": ["BG/BG-Moon"]
        },
        scale: [1.525, 1.525, 1],
        //2.3
        pointerEvents: false,
        physics: false
      },
      "BG-Moon-Overlay": {
        states: {
          "idle": ["BG/BG-Moon-Overlay"]
        },
        scale: [1.525, 1.525, 1],
        //2.3
        pointerEvents: false,
        physics: false
      },
      "BG-Fog": {
        states: {
          "idle": ["BG/BG-Fog"]
        },
        scale: [1.525 * 4, 1.525 * 4, 1],
        //2.3
        pointerEvents: false,
        physics: false,
        behavior: Fog
      },
      "CH-Scooby": {
        states: {
          "idle": ["CH/SD-STATIC"],
          "BLINK": ["CH/SD-BLINK"],
          "CHEW-A": ["CH/SD-CHEW-A"],
          "CHEW-B": ["CH/SD-CHEW-B"],
          "REVERSE": ["CH/SD-REVERSE"],
          "RUTROH": ["CH/SD-RUTROH"],
          "SMACK": ["CH/SD-SMACK"],
          "STATIC": ["CH/SD-STATIC"],
          "TILT": ["CH/SD-TILT"],
          "TILTSMILE": ["CH/SD-TILTSMILE"],
          "WAG-A": ["CH/SD-WAG-A"],
          "WAG-B": ["CH/SD-WAG-B"],
          "WAG": ["CH/SD-WAG-A", "CH/SD-WAG-B"]
        },
        scale: [0.6434599156118143, 0.6434599156118143, 1],
        //2.3
        pointerEvents: false,
        physics: true,
        body: {
          shape: "rectangle",
          width: 71,
          height: 154,
          options: {
            isStatic: true
          }
        },
        behavior: Scooby
      },
      "FX-Heart": {
        states: {
          "heartA": ["FX/FX-HEART-A"],
          "heartB": ["FX/FX-HEART-B"]
        },
        scale: [1.525, 1.525, 1],
        pointerEvents: false,
        physics: false,
        state: "heartA"
      },
      "OB-Snack": {
        states: {
          "idle": ["OB/OB-Snack-2", "OB/OB-Snack-3", "OB/OB-Snack-4", "OB/OB-Snack-5", "OB/OB-Snack-6"]
        },
        scale: [1, 1, 1],
        pointerEvents: false,
        physics: true,
        body: {
          shape: "circle",
          radius: 16,
          options: {
            density: 1.0,
            gravityScale: 1,
            friction: 10000,
            frictionAir: 0,
            frictionStatic: 10000,
            restitution: 0.55,
            sleepThreshold: 60
          }
        },
        behavior: Snack
      },
      "SK-Boo": {
        states: {
          "idle": ["UI/SK-BOO-LOOP"],
          "reset": ["UI/SK-BOO-PRESS-VANISH"]
        },
        scale: [1.525, 1.525, 1],
        pointerEvents: false,
        physics: false,
        behavior: Boo
      },
      "SK-Boo-Dust": {
        states: {
          "idle": ["UI/SK-FX-DUST"]
        },
        scale: [1.525, 1.525, 1],
        pointerEvents: false,
        physics: false
      },
      "SK-Arm": {
        states: {
          "idle": ["UI/SK-ARM"]
        },
        scale: [1.525, 1.525, 1],
        pointerEvents: false,
        physics: false
      },
      "IN-Arm": {
        states: {
          "idle": ["UI/IN-ARM"]
        },
        scale: [1.525, 1.525, 1],
        pointerEvents: false,
        physics: false,
        behavior: Instructions
      },
      "IN-COOKIE": {
        states: {
          "idle": ["UI/IN-COOKIE"]
        },
        scale: [1.525, 1.525, 1],
        pointerEvents: false,
        physics: false
      },
      "UI-Toasty": {
        states: {
          "idle": ["CO/CH-Batman-01"],
          "WandaSykes-01": ["CO/CH-WandaSykes-01"],
          "WandaSykes-02": ["CO/CH-WandaSykes-02"],
          "WeirdAl-01": ["CO/CH-WeirdAl-01"],
          "WeirdAl-02": ["CO/CH-WeirdAl-02"],
          "WonderWoman-01": ["CO/CH-WonderWoman-01"],
          "WonderWoman-02": ["CO/CH-WonderWoman-02"],
          "AbeLincoln-01": ["CO/CH-AbeLincoln-01"],
          "AbeLincoln-02": ["CO/CH-AbeLincoln-02"],
          "Batman-01": ["CO/CH-Batman-01"],
          "Batman-02": ["CO/CH-Batman-02"],
          "ChrisPaul-01": ["CO/CH-ChrisPaul-01"],
          "ChrisPaul-02": ["CO/CH-ChrisPaul-02"],
          "JimGaffigan-01": ["CO/CH-JimGaffigan-01"],
          "JimGaffigan-02": ["CO/CH-JimGaffigan-02"],
          "KeenanThompson-01": ["CO/CH-KeenanThompson-01"],
          "KeenanThompson-02": ["CO/CH-KeenanThompson-02"],
          "PennTeller-01": ["CO/CH-PennTeller-01"],
          "PennTeller-02": ["CO/CH-PennTeller-02"],
          "RickyGervais-01": ["CO/CH-RickyGervais-01"],
          "RickyGervais-02": ["CO/CH-RickyGervais-02"],
          "SherlockHolmes-01": ["CO/CH-SherlockHolmes-01"],
          "SherlockHolmes-02": ["CO/CH-SherlockHolmes-02"],
          "Sia-01": ["CO/CH-Sia-01"],
          "Sia-02": ["CO/CH-Sia-02"],
          "Urkel-01": ["CO/CH-Urkel-01"],
          "Urkel-02": ["CO/CH-Urkel-02"],
          "Daphne-01": ["CO/CH-Daphne-01"],
          "Daphne-02": ["CO/CH-Daphne-02"],
          "Fred-01": ["CO/CH-Fred-01"],
          "Fred-02": ["CO/CH-Fred-02"],
          "Scooby-01": ["CO/CH-Scooby-01"],
          "Scooby-02": ["CO/CH-Scooby-02"],
          "Shaggy-01": ["CO/CH-Shaggy-01"],
          "Shaggy-02": ["CO/CH-Shaggy-02"],
          "Velma-01": ["CO/CH-Velma-01"],
          "Velma-02": ["CO/CH-Velma-02"],
          "Scooby-Shaggy": ["CO/CH-Scooby-Shaggy"],
          "V-1": ["CO/V-1"],
          "V-2": ["CO/V-2"],
          "V-2-2": ["CO/V-2-2"],
          "V-3": ["CO/V-3"],
          "V-4": ["CO/V-4"],
          "V-5": ["CO/V-5"],
          "V-6": ["CO/V-6"],
          "V-7": ["CO/V-7"],
          "V-8": ["CO/V-8"],
          "V-9": ["CO/V-9"],
          "V-10": ["CO/V-10"],
          "V-11": ["CO/V-11"],
          "V-12": ["CO/V-12"],
          "V-13": ["CO/V-13"]
        },
        scale: [1.525, 1.525, 1],
        pointerEvents: false,
        physics: false,
        behavior: Toasty
      },
      "UI-Arrow": {
        states: {
          "idle": ["UI/UI-Arrow"]
        },
        scale: [1.5, 1.5, 1],
        pointerEvents: false,
        physics: false
      },
      "UI-Cursor": {
        states: {
          "idle": ["UI/UI-Arrow-Circle"]
        },
        scale: [1.5 / 2, 1.5 / 2, 1],
        pointerEvents: false,
        physics: false,
        behavior: Cursor
      },
      "UI-Cursor-Arm": {
        states: {
          "idle": ["UI/UI-Arrow-Arm"]
        },
        scale: [1.5 / 2, 1.5 / 2, 1],
        pointerEvents: false,
        physics: false
      },
      "UI-Cursor-Tip": {
        states: {
          "idle": ["UI/UI-Arrow-Tip"]
        },
        scale: [1.5 / 2, 1.5 / 2, 1],
        pointerEvents: false,
        physics: false
      },
      "UI-Heart": {
        states: {
          "idle": ["UI/UI-Heart"]
        },
        scale: [1.85, 1.85, 1],
        physics: false
      },
      "UI-Hearts": {
        states: {
          "idle": ["UI/UI-Hearts"]
        },
        scale: [1.5, 1.5, 1],
        physics: false
      },
      "UI-Trophy": {
        states: {
          "idle": ["UI/TC-UI-Trophy"]
        },
        scale: [0.93, 0.93, 1],
        pointerEvents: false,
        physics: false
      },
      "UI-Letterbox": {
        states: {
          "idle": ["OB/OB-Floor"]
        },
        scale: [30, 2, 1],
        HSV: [-1, -1, -1],
        physics: false
      },
      "UI-Fade": {
        states: {
          "idle": ["OB/OB-Floor"]
        },
        scale: [30, 30, 1],
        HSV: [0, -1, -1],
        physics: false
      },
      "TC-BG-Cookies": {
        states: {
          "idle": ["TC/TC-BG-Cookies"]
        },
        scale: [1.525, 1.525, 1],
        physics: false
      },
      "TC-BG-Credits": {
        states: {
          "idle": ["TC/TC-BG-Credits"]
        },
        scale: [1.525, 1.525, 1],
        physics: false
      },
      "TC-BG-Hills": {
        states: {
          "idle": ["TC/TC-BG-Hills"]
        },
        scale: [1.525, 1.525, 1],
        physics: false
      },
      "TC-BG-Sky": {
        states: {
          "idle": ["TC/TC-BG-Sky"]
        },
        scale: [1.525, 1.525, 1],
        physics: false
      },
      "TC-Button": {
        states: {
          "idle": ["TC/TC-Button-Blue"]
        },
        scale: [1.525, 1.525, 1],
        physics: false
      },
      "TC-SW": {
        states: {
          "idle": ["TC/TC-SW"]
        },
        scale: [1.525, 1.525, 1],
        physics: false
      },
      "TC-MU": {
        states: {
          "idle": ["TC/TC-MU"]
        },
        scale: [1.525, 1.525, 1],
        physics: false
      },
      "TC-SD": {
        states: {
          "idle": ["TC/TC-SD"]
        },
        scale: [1.525, 1.525, 1],
        physics: false
      },
      "TC-BO": {
        states: {
          "idle": ["TC/TC-BO"]
        },
        scale: [1.525, 1.525, 1],
        physics: false
      },
      "TC-LA": {
        states: {
          "idle": ["TC/TC-LA"]
        },
        scale: [1.525, 1.525, 1],
        physics: false
      }
    }
  };

  var MATERIAL$2 = new MaterialSpriteColorized();
  var RETRY_TIMEOUT = 1000;
  var MINIMUM_TIME = 165000;
  var LOADER_BAR_OFFSET_X = 200;
  var COLOR_YELLOW = [255 / 255, 235 / 255, 53 / 255];
  var FRAMES_A = "LOAD-A-SM-INTRO=1,1,1,1,2,3,9,9,9,3,4,5,6,7,8,E";
  var FRAMES_B = "LOAD-A-SM=1,2,3,4,5,6,7,8,E";
  var FRAMES_C = "LOAD-A-SM=1,2,3,4,5,6,7,8,E"; // const FRAMES_C = "LOAD-B-LG=1,2,3,4,5,7,1,4,5,6,7,4,E";

  var FRAMES_D = "LOAD-C-END=1,3,1,2,1,P1,E";
  var FRAMES_CHARACTER = "LOAD-SD-INTRO=7,1,2,3,4,5,6,6,3,2,1,E";

  var ScenePreloader =
  /*#__PURE__*/
  function (_Onyx$Scene) {
    _inherits(ScenePreloader, _Onyx$Scene);

    function ScenePreloader() {
      var _this;

      _classCallCheck(this, ScenePreloader);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(ScenePreloader).call(this));
      _this.renderPasses = [new RenderPass({
        viewportClear: true
      })];
      _this.complete = false;
      _this.currentPercent = 0; // To start off with some loaded

      _this.sprites = {};
      _this.assets = {};
      return _this;
    }

    _createClass(ScenePreloader, [{
      key: "onload",
      value: function onload() {
        var _this$viewports$0$cle,
            _this2 = this;

        _get(_getPrototypeOf(ScenePreloader.prototype), "onload", this).call(this); // So titlescreen can know if to use wipe


        game.preloader = "boomerang";
        console.log("%c ".concat(CONFIG.meta.title, " v.").concat(CONFIG.meta.version, " "), 'background: #222; color: #bada55; font-weight: bold');
        console.log('%c Created by THIS IS POP ', 'background: #EA177E; color: #FFF; font-weight: bold'); // Listen for mouse/touch events

        this.viewports[0].listenForMouseEvents({
          scene: game.router.map.game.module,
          renderPick: false
        });
        this.renderPasses = [new RenderPass()];
        this.progress = 0;
        var totalAssets = assets.images.length + assets.audio.music.length + assets.audio.sfx.length + assets.spritesheets.length + assets.videos.length;
        var totalLoaded = 0;

        (_this$viewports$0$cle = this.viewports[0].clearColor).set.apply(_this$viewports$0$cle, COLOR_YELLOW);

        this.showBackgroundGraphics().then(function () {
          _this2.preloadTextures(assets, function (progress, noCompleted) {
            _this2.showProgress((noCompleted + totalLoaded) / totalAssets);
          }, function () {
            totalLoaded += assets.images.length;

            _this2.preloadMusic(assets, function (progress, noCompleted) {
              _this2.showProgress((noCompleted + totalLoaded) / totalAssets);
            }, function () {
              totalLoaded += assets.audio.music.length;

              _this2.preloadSFX(assets, function (progress, noCompleted) {
                _this2.showProgress((noCompleted + totalLoaded) / totalAssets);
              }, function () {
                totalLoaded += assets.audio.sfx.length;

                _this2.preloadSpritesheets(assets, function (progress, noCompleted) {
                  //TODO
                  _this2.showProgress((totalLoaded + noCompleted) / totalAssets);
                }, function () {
                  totalLoaded += assets.spritesheets.length;

                  _this2.preloadVideos(assets, function (progress, noCompleted) {
                    _this2.showProgress((totalLoaded + noCompleted) / totalAssets);
                  }, function () {
                    totalLoaded += assets.videos.length;

                    _this2.showProgress(totalLoaded / totalAssets);
                  });
                });
              });
            });
          });
        });
      }
    }, {
      key: "update",
      value: function update() {
        var _get2;

        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        (_get2 = _get(_getPrototypeOf(ScenePreloader.prototype), "update", this)).call.apply(_get2, [this].concat(args)); // Update percent


        if (this.currentPercent < this.progress * 100) {
          this.currentPercent += (this.progress * 100 - this.currentPercent) / 5;
          this.currentPercent = Math.ceil(this.currentPercent);
        }

        var screenHeight = this.viewports[0].orthoHeight;
        var screenWidth = screenHeight * (16 / 9);
        if (this.sprites.bar) this.sprites.bar.components[0].transform.x = LOADER_BAR_OFFSET_X + this.currentPercent * 3.52;

        if (this.sprites["bar-blue"]) {
          // if(this.progress >= 1) this.sprites["bar-yellow"].visible = false;
          // let transform = this.sprites["bar-blue"].transform;
          // transform.x += LOADER_BAR_SPEED;
          // if(transform.x >= screenWidth) transform.x = -width;
          this.sprites["bar-blue"].transform.x = -1 + this.currentPercent / 100 * screenWidth * 2;
          this.sprites["bar-magenta"].transform.x = -1 + this.currentPercent / 100 * screenWidth * 2;
          if (this.currentPercent >= 50) this.sprites["bar-yellow"].visible = false;
        }

        if (this.complete || router.clock.stats.currentGameTime < MINIMUM_TIME) return;

        if (this.currentPercent >= 100 && !this.complete) {
          this.currentPercent = 100;
          this.complete = true;
          this.onLoadComplete();
        }
      }
    }, {
      key: "onLoadComplete",
      value: function () {
        var _onLoadComplete = _asyncToGenerator(
        /*#__PURE__*/
        regeneratorRuntime.mark(function _callee() {
          var _this3 = this;

          return regeneratorRuntime.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  _context.next = 2;
                  return this.hideLogo();

                case 2:
                  // return; // To halt at 100%
                  // game.showLoadingMask();
                  this.setTimeout(function () {
                    _this3.spriteModel.mesh.material.diffuseTexture.unload(_this3.viewports[0]);

                    router.navigate('title');
                  }, 150);

                case 3:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee, this);
        }));

        function onLoadComplete() {
          return _onLoadComplete.apply(this, arguments);
        }

        return onLoadComplete;
      }()
    }, {
      key: "showBackgroundGraphics",
      value: function () {
        var _showBackgroundGraphics = _asyncToGenerator(
        /*#__PURE__*/
        regeneratorRuntime.mark(function _callee2() {
          var _this$viewports$0$cle2;

          var screenHeight, screenWidth, scale, logo, introChar;
          return regeneratorRuntime.wrap(function _callee2$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  this.camera = new Camera({
                    projectionType: "orthographic",
                    transform: new Transform({
                      position: [0, 0, 99]
                    })
                  });
                  this.add(this.camera);
                  this.viewports[0].bindToCamera(this.camera);
                  screenHeight = this.viewports[0].orthoHeight;
                  screenWidth = screenHeight * (16 / 9);
                  scale = this.viewports[0].orthoHeight / 576;
                  game.materialColorized = MATERIAL$2;
                  _context2.next = 9;
                  return this.newSprite("logo", FRAMES_A, 0, 0, 0, 2, [scale, scale, 1]);

                case 9:
                  logo = _context2.sent;
                  this.setTimeout(function () {
                    logo.components[0].currentAnimation.play();
                  }, 1000);

                  logo.components[0].currentAnimation.onComplete = function () {
                    logo.components[0].playAnimation(FRAMES_B);

                    logo.components[0].currentAnimation.onComplete = function () {
                      logo.components[0].playAnimation(FRAMES_C);
                    };
                  };

                  _context2.next = 14;
                  return this.newSprite("background", "LOAD-BG", 0, 0, 0, 0, [scale, scale, 1]);

                case 14:
                  _context2.next = 16;
                  return this.newSprite("bar-blue", "LOAD-X-BARS", 0, 0, 0, 1, [scale, scale, 1]);

                case 16:
                  _context2.next = 18;
                  return this.newSprite("bar-magenta", "LOAD-X-BARS", 1, -screenWidth, 0, 2, [scale, scale, 1]);

                case 18:
                  _context2.next = 20;
                  return this.newSprite("bar-yellow", "LOAD-X-BARS", 2, -screenWidth, 0, 2, [scale, scale, 1]);

                case 20:
                  _context2.next = 22;
                  return this.newSprite("intro-char", FRAMES_CHARACTER, 0, 0, 0, 2, [scale, scale, 1]);

                case 22:
                  introChar = _context2.sent;
                  this.setTimeout(function () {
                    introChar.components[0].currentAnimation.play();
                  }, 1000);

                  introChar.components[0].currentAnimation.onComplete = function () {
                    introChar.visible = false;
                  };

                  (_this$viewports$0$cle2 = this.viewports[0].clearColor).set.apply(_this$viewports$0$cle2, COLOR_YELLOW); // await this.newSprite("bar-background-1", 0, 0, 0, 0, [screenScaleX, screenScaleY, 1]);
                  // await this.newSprite("bar-background-2", 0, -LOADER_BAR_WIDTH + LOADER_BAR_EXTRUDE_X, 0, 0, [screenScaleX, screenScaleY, 1]);
                  // await this.newSprite("bar", 1, 0, 0, 1, [screenScaleX, screenScaleY, 1]);
                  // await this.newSprite("overlay-mask-l", 1, -545, 0, 1, [screenScaleX, screenScaleY, 1]);
                  // await this.newSprite("overlay-mask-r", 1,  555, 0, 1, [screenScaleX, screenScaleY, 1]);
                  // await this.newSprite("overlay", 2, 0, 0, 2, [screenScaleX, screenScaleY, 1]);


                case 26:
                case "end":
                  return _context2.stop();
              }
            }
          }, _callee2, this);
        }));

        function showBackgroundGraphics() {
          return _showBackgroundGraphics.apply(this, arguments);
        }

        return showBackgroundGraphics;
      }()
    }, {
      key: "newSprite",
      value: function () {
        var _newSprite = _asyncToGenerator(
        /*#__PURE__*/
        regeneratorRuntime.mark(function _callee3(label) {
          var _this4 = this;

          var anim,
              frame,
              x,
              y,
              z,
              scale,
              speed,
              model,
              parsedName,
              _args3 = arguments;
          return regeneratorRuntime.wrap(function _callee3$(_context3) {
            while (1) {
              switch (_context3.prev = _context3.next) {
                case 0:
                  anim = _args3.length > 1 && _args3[1] !== undefined ? _args3[1] : "";
                  frame = _args3.length > 2 && _args3[2] !== undefined ? _args3[2] : 0;
                  x = _args3.length > 3 && _args3[3] !== undefined ? _args3[3] : 0;
                  y = _args3.length > 4 && _args3[4] !== undefined ? _args3[4] : 0;
                  z = _args3.length > 5 && _args3[5] !== undefined ? _args3[5] : 0;
                  scale = _args3.length > 6 && _args3[6] !== undefined ? _args3[6] : [1, 1, 1];
                  speed = _args3.length > 7 && _args3[7] !== undefined ? _args3[7] : 1000 / 20;

                  if (this.spriteModel) {
                    _context3.next = 11;
                    break;
                  }

                  _context3.next = 10;
                  return ImportSpriteFromTexturePacker.load({
                    src: "res/textures/boomerang-preloader.json",
                    autoplay: false,
                    speed: speed,
                    defaultPivot: [0, 0],
                    pixelsPerUnit: 1,
                    minFilter: "LINEAR_MIPMAP_NEAREST",
                    magFilter: "LINEAR"
                  });

                case 10:
                  this.spriteModel = _context3.sent;

                case 11:
                  model = ImportSpriteFromTexturePacker.cloneSprite(this.spriteModel, true);
                  _context3.next = 14;
                  return model.loadTextures();

                case 14:
                  model.mesh.material = game.materialColorized;
                  model.transform = new Transform({
                    position: [x, y, z],
                    scale: scale
                  }); // Parse animation sequence from folder title

                  parsedName = anim.split("=")[0];

                  if (parsedName !== anim) {
                    (function () {
                      var animation = model.animations[anim]; // Set speeds

                      var _iteratorNormalCompletion = true;
                      var _didIteratorError = false;
                      var _iteratorError = undefined;

                      try {
                        for (var _iterator = animation.frames[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                          var _frame = _step.value;
                          _frame.speed = speed;
                        } // Set frame order
                        // Clone, sort, and clear...

                      } catch (err) {
                        _didIteratorError = true;
                        _iteratorError = err;
                      } finally {
                        try {
                          if (!_iteratorNormalCompletion && _iterator["return"] != null) {
                            _iterator["return"]();
                          }
                        } finally {
                          if (_didIteratorError) {
                            throw _iteratorError;
                          }
                        }
                      }

                      var frames = animation.frames.sort(function (a, b) {
                        if (a.name < b.name) return -1;
                        if (a.name > b.name) return 1;
                        return 0;
                      });

                      if (anim.indexOf("=") > -1) {
                        // Parse order
                        var sequenceArr = anim.split("=")[1].split(","); // frames.sort((a, b) => {return a.name < b.name});

                        if (!isNaN(sequenceArr[0])) animation.frames = [];
                        var _iteratorNormalCompletion2 = true;
                        var _didIteratorError2 = false;
                        var _iteratorError2 = undefined;

                        try {
                          for (var _iterator2 = sequenceArr[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                            var step = _step2.value;

                            if (step == '') {
                              // console.warn('space');
                              continue;
                            }

                            ;

                            (function () {
                              switch (step[0].toUpperCase()) {
                                case 'E':
                                case 'S':
                                  animation.loop = false;
                                  break;

                                case 'P':
                                  var frame = animation.frames[animation.frames.length - 1];
                                  var range = step.replace("P", "").split("-");

                                  if (!range[1]) {
                                    frame.speed = range[0] * 1000;
                                  } else {
                                    frame.onStart = function () {
                                      frame.speed = (Math.random() * range[1] + range[0]) * 1000;
                                    };
                                  }

                                  break;

                                case 'R':
                                  var frameIndex = step.replace("R", "") - 1;

                                  animation.frames[animation.frames.length - 1].onComplete = function () {
                                    animation.setFrame(frameIndex);
                                  };

                                  break;

                                case 'L':
                                  animation.loop = true;
                                  break;

                                case 'I':
                                  animation.frames[animation.frames.length - 1].onComplete = function () {
                                    _this4.state = "idle";
                                  };

                                  break;

                                case 'V':
                                  animation.frames[animation.frames.length - 1].onComplete = function () {
                                    _this4.visible = false;
                                  };

                                  break;

                                default:
                                  animation.frames.push(Object.assign({}, frames[step - 1]));
                              }
                            })();
                          }
                        } catch (err) {
                          _didIteratorError2 = true;
                          _iteratorError2 = err;
                        } finally {
                          try {
                            if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
                              _iterator2["return"]();
                            }
                          } finally {
                            if (_didIteratorError2) {
                              throw _iteratorError2;
                            }
                          }
                        }
                      }

                      model.animations[anim] = new SpriteAnimation(animation, model); //Object.assign({}, animation);

                      animation = model.animations[anim];
                    })();
                  }

                  model.selectAnimation(anim);
                  if (model.currentAnimation && frame) model.currentAnimation.setFrame(frame);
                  this.sprites[label] = new Entity({
                    components: [model]
                  });
                  this.add(this.sprites[label]);
                  return _context3.abrupt("return", this.sprites[label]);

                case 23:
                case "end":
                  return _context3.stop();
              }
            }
          }, _callee3, this);
        }));

        function newSprite(_x) {
          return _newSprite.apply(this, arguments);
        }

        return newSprite;
      }()
    }, {
      key: "hideLogo",
      value: function () {
        var _hideLogo = _asyncToGenerator(
        /*#__PURE__*/
        regeneratorRuntime.mark(function _callee5() {
          var _this5 = this;

          return regeneratorRuntime.wrap(function _callee5$(_context5) {
            while (1) {
              switch (_context5.prev = _context5.next) {
                case 0:
                  return _context5.abrupt("return", new Promise(
                  /*#__PURE__*/
                  function () {
                    var _ref = _asyncToGenerator(
                    /*#__PURE__*/
                    regeneratorRuntime.mark(function _callee4(resolve, reject) {
                      return regeneratorRuntime.wrap(function _callee4$(_context4) {
                        while (1) {
                          switch (_context4.prev = _context4.next) {
                            case 0:
                              _this5.sprites['logo'].components[0].playAnimation(FRAMES_D);

                              _this5.sprites['logo'].components[0].currentAnimation.onComplete = function () {
                                _this5.sprites['logo'].components[0].currentAnimation.pause();

                                _this5.sprites['logo'].components[0].currentAnimation.setFrame(0); // this.setTimeout(() => {
                                // this.sprites['logo'].setTween({
                                // 	propParent: this.sprites['logo'],
                                // 	property: "opacity",
                                // 	from: 1,
                                // 	to: 0,
                                // 	duration: 100,
                                // 	onComplete: () => {


                                resolve(); // 	}
                                // });
                                // }, 1000);
                              };

                            case 2:
                            case "end":
                              return _context4.stop();
                          }
                        }
                      }, _callee4);
                    }));

                    return function (_x2, _x3) {
                      return _ref.apply(this, arguments);
                    };
                  }()));

                case 1:
                case "end":
                  return _context5.stop();
              }
            }
          }, _callee5);
        }));

        function hideLogo() {
          return _hideLogo.apply(this, arguments);
        }

        return hideLogo;
      }()
    }, {
      key: "preloadTextures",
      value: function preloadTextures(assets, progressCallback, completeCallback) {
        var _this6 = this;

        var preloader = new Preloader();
        preloader.preloadTextures(assets.images, progressCallback, [this.viewports[0], this.viewports[0].mouseEventViewport], {
          flipY: false,
          minFilter: "LINEAR_MIPMAP_NEAREST",
          magFilter: "LINEAR"
        }).then(function (loaded) {
          // this.assets = loaded;
          if (completeCallback) completeCallback();
          game.textures = loaded;
        })["catch"](function (e) {
          console.log(e);
          window.setTimeout(function () {
            _this6.preloadTextures(assets, progressCallback, completeCallback);
          }, RETRY_TIMEOUT);
        });
      }
    }, {
      key: "preloadSpritesheets",
      value: function preloadSpritesheets(assets, progressCallback, completeCallback) {
        var _this7 = this;

        var pending = 0;
        var failed = false;

        for (var i = 0; i < assets.spritesheets.length; i++) {
          pending++;

          (function (src) {
            ImportSpriteFromTexturePacker.load({
              src: src,
              material: MATERIAL$2,
              minFilter: "LINEAR_MIPMAP_NEAREST",
              magFilter: "LINEAR",
              autoplay: false,
              speed: 1000 / 24,
              defaultPivot: [0, 0],
              pixelsPerUnit: 1,
              textures: game.textures
            }).then(
            /*#__PURE__*/
            function () {
              var _ref2 = _asyncToGenerator(
              /*#__PURE__*/
              regeneratorRuntime.mark(function _callee6(model) {
                var name, percent;
                return regeneratorRuntime.wrap(function _callee6$(_context6) {
                  while (1) {
                    switch (_context6.prev = _context6.next) {
                      case 0:
                        name = src.split("/").pop().replace(".png", "");
                        game.spritesheets[name] = model;
                        pending--; // await model.loadTextures();

                        if (progressCallback) {
                          percent = (assets.spritesheets.length - pending) / assets.spritesheets.length;
                          progressCallback(percent, assets.spritesheets.length - pending);
                        }

                        if (!pending) {
                          if (completeCallback) completeCallback();
                        }

                      case 5:
                      case "end":
                        return _context6.stop();
                    }
                  }
                }, _callee6);
              }));

              return function (_x4) {
                return _ref2.apply(this, arguments);
              };
            }())["catch"](function (e) {
              if (failed) return;
              failed = true;
              console.log(e);
              window.setTimeout(function () {
                _this7.preloadSpritesheets(assets, progressCallback, completeCallback);
              }, RETRY_TIMEOUT);
            });
          })(assets.spritesheets[i]);
        }
      }
    }, {
      key: "preloadMusic",
      value: function preloadMusic(assets, progressCallback, completeCallback) {
        var _this8 = this;

        var pending = 0;
        var failed = false;

        for (var i = 0; i < assets.audio.music.length; i++) {
          pending++;
          var musicName = assets.audio.music[i].split("/").pop().replace(".mp3", "");
          game.music[musicName] = new Howl({
            src: [assets.audio.music[i], assets.audio.music[i].replace(".mp3", ".ogg")],
            // volume: 0.5,
            // html5: (isiOS())?true:false,
            loop: true,
            onload: function onload() {
              pending--;

              if (progressCallback) {
                var percent = (assets.audio.music.length - pending) / assets.audio.music.length;
                progressCallback(percent, assets.audio.music.length - pending);
              }

              if (!pending) {
                if (completeCallback) completeCallback();
              }
            },
            onloaderror: function onloaderror(err) {
              if (failed) return;
              failed = true;
              console.warn("Failed to load music. " + err);
              window.setTimeout(function () {
                console.warn("Retrying music load.");

                _this8.preloadMusic(assets, progressCallback, completeCallback);
              }, RETRY_TIMEOUT);
            }
          });
        }
      }
    }, {
      key: "preloadSFX",
      value: function preloadSFX(assets, progressCallback, completeCallback) {
        var _this9 = this;

        var pending = 0;
        var failed = false;

        for (var i = 0; i < assets.audio.sfx.length; i++) {
          pending++;
          var sfxName = assets.audio.sfx[i].split("/").pop().replace(".mp3", "");
          game.sfx[sfxName] = new Howl({
            src: [assets.audio.sfx[i], assets.audio.sfx[i].replace(".mp3", ".ogg")],
            html5: navigator.isCocoonJS ? true : false,
            // volume: 0.5,
            onload: function onload() {
              pending--;

              if (progressCallback) {
                var percent = (assets.audio.sfx.length - pending) / assets.audio.sfx.length;
                progressCallback(percent, assets.audio.sfx.length - pending);
              }

              if (!pending) {
                if (completeCallback) completeCallback();
              }
            },
            onloaderror: function onloaderror(err) {
              if (failed) return;
              failed = true;
              console.warn("Failed to load sound effects. " + err);
              window.setTimeout(function () {
                console.warn("Retrying sound effects load.");

                _this9.preloadSFX(assets, progressCallback, completeCallback);
              }, RETRY_TIMEOUT);
            }
          });
        }
      }
    }, {
      key: "preloadVideos",
      value: function preloadVideos(assets, progressCallback, completeCallback) {
        var _this10 = this;

        var pending = 0;
        var failed = false;
        var platform = "web";

        if (navigator.app) {
          platform = cordova.platformId.toLowerCase();
        }

        var _loop = function _loop() {
          pending++;
          var videoName = assets.videos[i].split("/").pop().replace(".webm", "").replace(".mp4", "");
          var videoURL = assets.videos[i];
          req = new XMLHttpRequest();

          req.onload = function () {
            // Onload is triggered even on 404
            // so we need to check the status code
            if (this.status === 200) {
              // Video is now downloaded
              // and we can set it as source on the video element
              // video.src = vid;
              if (platform === "ios") {
                game.videos[videoName] = videoURL;
              } else {
                var videoBlob = this.response;
                game.videos[videoName] = URL.createObjectURL(videoBlob); // IE10+
              }

              pending--;

              if (progressCallback) {
                var percent = (assets.videos.length - pending) / assets.videos.length;
                progressCallback(percent, assets.videos.length - pending);
              }

              if (!pending) {
                if (completeCallback) completeCallback();
              }
            }
          };

          req.onerror = function () {
            // Error
            if (failed) return;
            failed = true;
            window.setTimeout(function () {
              _this10.preloadVideos(assets, progressCallback, completeCallback);
            }, RETRY_TIMEOUT);
          };

          req.responseType = 'blob';
          req.open('GET', assets.videos[i], true);
          req.send();
        };

        for (var i = 0; i < assets.videos.length; i++) {
          var req;

          _loop();
        }
      }
    }, {
      key: "showProgress",
      value: function showProgress(percent) {
        this.progress = percent; // console.log(percent);
      }
    }]);

    return ScenePreloader;
  }(Scene);

  var LETTERBOX_Y_TOP_SHOWN = 862;
  var LETTERBOX_Y_TOP_HIDDEN = 910;
  var LETTERBOX_Y_BOTTOM_SHOWN = -10;
  var LETTERBOX_Y_BOTTOM_HIDDEN = -58;

  var TransitionOverlay =
  /*#__PURE__*/
  function (_Entity) {
    _inherits(TransitionOverlay, _Entity);

    function TransitionOverlay() {
      var _this;

      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref$isShowingLetterb = _ref.isShowingLetterbox,
          isShowingLetterbox = _ref$isShowingLetterb === void 0 ? false : _ref$isShowingLetterb,
          _ref$isFaded = _ref.isFaded,
          isFaded = _ref$isFaded === void 0 ? false : _ref$isFaded;

      _classCallCheck(this, TransitionOverlay);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(TransitionOverlay).apply(this, arguments));
      _this.constructorName = "TransitionOverlay";
      _this.pointerEvents = false;
      _this.isShowingLetterbox = isShowingLetterbox;
      _this.isFaded = isFaded;
      return _this;
    }

    _createClass(TransitionOverlay, [{
      key: "onSpawn",
      value: function onSpawn() {
        _get(_getPrototypeOf(TransitionOverlay.prototype), "onSpawn", this).apply(this, arguments);

        this.fadeOverlay = this.parentScene.addActor({
          cls: "UI-Fade",
          position: [-700, 120, 0.1],
          opacity: this.isFaded ? 1 : 0
        }, false);
        this.fadeOverlay.pointerEvents = false;
        this.addComponent(this.fadeOverlay);
        this.letterboxTop = this.parentScene.addActor({
          cls: "UI-Letterbox",
          position: [-700, this.isShowingLetterbox ? LETTERBOX_Y_TOP_SHOWN : LETTERBOX_Y_TOP_HIDDEN, 0.2]
        }, false);
        this.addComponent(this.letterboxTop);
        this.letterboxBottom = this.parentScene.addActor({
          cls: "UI-Letterbox",
          position: [-700, this.isShowingLetterbox ? LETTERBOX_Y_BOTTOM_SHOWN : LETTERBOX_Y_BOTTOM_HIDDEN, 0.2]
        }, false);
        this.addComponent(this.letterboxBottom);
      }
    }, {
      key: "fadeIn",
      value: function fadeIn(onComplete) {
        this.setTween({
          propParent: this.fadeOverlay,
          property: "opacity",
          from: this.fadeOverlay.opacity,
          to: 0,
          method: "easeIn",
          duration: 125,
          onComplete: onComplete
        });
      }
    }, {
      key: "fadeOut",
      value: function fadeOut(onComplete) {
        this.setTween({
          propParent: this.fadeOverlay,
          property: "opacity",
          from: this.fadeOverlay.opacity,
          to: 1,
          method: "easeIn",
          duration: 125,
          onComplete: onComplete
        });
      }
    }, {
      key: "showLetterbox",
      value: function showLetterbox(onComplete) {
        if (this.isShowingLetterbox) return;
        this.isShowingLetterbox = true;
        this.setTween({
          propParent: this.letterboxBottom.transform,
          property: "y",
          from: this.letterboxBottom.transform.y,
          to: LETTERBOX_Y_BOTTOM_SHOWN,
          method: "easeIn",
          duration: 500,
          onComplete: onComplete
        });
        this.setTween({
          propParent: this.letterboxTop.transform,
          property: "y",
          from: this.letterboxTop.transform.y,
          to: LETTERBOX_Y_TOP_SHOWN,
          method: "easeIn",
          duration: 500
        });
      }
    }, {
      key: "hideLetterbox",
      value: function hideLetterbox(onComplete) {
        if (!this.isShowingLetterbox) return;
        this.isShowingLetterbox = false;
        this.setTween({
          propParent: this.letterboxBottom.transform,
          property: "y",
          from: this.letterboxBottom.transform.y,
          to: LETTERBOX_Y_BOTTOM_HIDDEN,
          method: "easeIn",
          duration: 1000,
          onComplete: onComplete
        });
        this.setTween({
          propParent: this.letterboxTop.transform,
          property: "y",
          from: this.letterboxTop.transform.y,
          to: LETTERBOX_Y_TOP_HIDDEN,
          method: "easeIn",
          duration: 1000
        });
      }
    }]);

    return TransitionOverlay;
  }(Entity);

  var MATERIAL$3 = new MaterialSpriteColorized();

  var GameTitle =
  /*#__PURE__*/
  function (_Onyx$Scene) {
    _inherits(GameTitle, _Onyx$Scene);

    function GameTitle() {
      var _this;

      _classCallCheck(this, GameTitle);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(GameTitle).call(this));
      _this.renderPasses = [new RenderPass({
        viewportClear: true
      })];
      _this.actors = {};
      _this.sprites = {};
      _this.mouseDown = false;
      _this.listenerClick = {
        handleEvent: function handleEvent(evt) {
          return _this.onClick(evt);
        }
      };
      return _this;
    }

    _createClass(GameTitle, [{
      key: "onload",
      value: function onload() {
        var _this2 = this;

        // this.viewports[0].id = 0; // Hotfix so it doesn't reload the textures (It's creating a new viewport object every scene)
        this.viewports = game.router.map.preloader.module.viewports; // this.viewports[0].listenForMouseEvents({ scene: game.router.map.title.module, renderPick: true });
        // this.viewports = game.router.map.preloader.module.viewports;
        // this.viewports[0].mouseEventHover = false;

        this.viewports[0].clearColor.set(0, 0, 0);
        var camera = new Camera({
          projectionType: "orthographic",
          transform: new Transform({
            position: [0, 0, 100]
          })
        });
        this.add(camera);
        this.viewports[0].bindToCamera(camera);
        this.renderPasses = [new RenderPass()];
        this.visible = false;
        this.loadScene().then(function () {
          _this2.visible = true;
          game.playRandomSFX(["SD-Organ-#"]);
          game.playMusic("SD-Aambient-01");
          game.router.map.game.module.music = game.playMusic("SD-Ambient");
          _this2.complete = false;

          _this2.transitionOverlay.fadeIn();
        });

        this.onKeyDown = function () {
          _this2.onClick();
        };

        window.addEventListener("keydown", this.onKeyDown);
        this.viewports[0].contextElement.addEventListener("mousedown", this.listenerClick);
        this.viewports[0].contextElement.addEventListener("touchstart", this.listenerClick);
      }
    }, {
      key: "onunload",
      value: function onunload() {
        this.entities = [];
        this.components = [];
        this.cameras = []; // this.viewports[0].bindToCamera();
        // this.viewports[0].removeMouseListenEvents({ scene: this });

        window.removeEventListener("keydown", this.onKeyDown);
        this.viewports[0].contextElement.removeEventListener("mousedown", this.listenerClick);
        this.viewports[0].contextElement.removeEventListener("touchstart", this.listenerClick);
        var texturesUsed = ["TC-Background", "TC-LOGO"];
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = game.textures[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var texture = _step.value;

            if (texturesUsed.indexOf(texture.src.replace("res/textures/", "").replace(".png", "")) >= 0) {
              texture.unload(this.viewports[0]);
              texture.unload(game.router.map.preloader.module.viewports[0]);
            }
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator["return"] != null) {
              _iterator["return"]();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
      }
    }, {
      key: "update",
      value: function update() {
        _get(_getPrototypeOf(GameTitle.prototype), "update", this).apply(this, arguments);

        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
          for (var _iterator2 = game.gamepads[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var gamepad = _step2.value;
            var _iteratorNormalCompletion3 = true;
            var _didIteratorError3 = false;
            var _iteratorError3 = undefined;

            try {
              for (var _iterator3 = gamepad.buttons[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                var button = _step3.value;
                if (button.pressed) this.onClick({
                  type: "gamepad",
                  button: button * 1
                });
              }
            } catch (err) {
              _didIteratorError3 = true;
              _iteratorError3 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
                  _iterator3["return"]();
                }
              } finally {
                if (_didIteratorError3) {
                  throw _iteratorError3;
                }
              }
            }
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
              _iterator2["return"]();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }
      }
    }, {
      key: "onMouseDown",
      value: function onMouseDown() {
        this.mouseDown = true; // this.button.state = "press";
        // this.cat.sprite.currentAnimation.setFrame(3);
        // game.playSFX('SO-ButtonPress');
      }
    }, {
      key: "onMouseUp",
      value: function onMouseUp() {
        this.mouseDown = false; // this.button.state = "idle";

        this.onClick();
        if (this.trophy) this.trophy.sprite.transform.y = 0;
      }
    }, {
      key: "onClick",
      value: function onClick(evt) {
        var _this3 = this;

        if (this.complete) return;
        this.complete = true;
        this.mouseDown = false; // this.button.state = "idle";

        if (evt && evt.type === "touchstart") game.router.map.game.module.mouseState.isTouch = true; // Unlock audio

        game.sfx["0000"].on('end', function () {
          game.playSFX("SD-Toasty-0" + Math.ceil(Math.random() * 3));

          _this3.transitionOverlay.fadeOut(function () {
            _this3.onunload(); // router.navigate('intro', { letterbox: true });


            router.navigate('game', {
              letterbox: true
            });
          });
        });
        game.playSFX("0000");
      }
    }, {
      key: "loadScene",
      value: function () {
        var _loadScene = _asyncToGenerator(
        /*#__PURE__*/
        regeneratorRuntime.mark(function _callee() {
          var _this4 = this;

          var screenHeight, screenWidth, scale, playerHasHighscore, text;
          return regeneratorRuntime.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  screenHeight = this.viewports[0].orthoHeight;
                  screenWidth = screenHeight * (16 / 9);
                  scale = [screenWidth / 1024, screenWidth / 1024, 1]; // this.newSprite({ src: "TC-Background", x: 0, y: 0, pivot: [0, 0], scale });

                  this.addActor({
                    cls: "TC-BG-Sky",
                    position: [0, 0, 0]
                  });
                  this.addActor({
                    cls: "TC-BG-Hills",
                    position: [0, 0, 1]
                  });
                  this.addActor({
                    cls: "TC-BG-Cookies",
                    position: [0, 0, 2]
                  });
                  this.addActor({
                    cls: "TC-BG-Credits",
                    position: [0, 0, 3]
                  });
                  this.addActor({
                    cls: "TC-BO",
                    position: [0, 0, 4]
                  });
                  this.addActor({
                    cls: "TC-SW",
                    position: [0, 0, 5]
                  });
                  this.addActor({
                    cls: "TC-MU",
                    position: [0, 0, 6]
                  });
                  this.addActor({
                    cls: "TC-LA",
                    position: [0, 0, 7]
                  });
                  this.addActor({
                    cls: "TC-SD",
                    position: [0, 0, 8]
                  });
                  this.addActor({
                    cls: "TC-Button",
                    position: [0, 0, 9]
                  });

                  if (game.preloader === "boomerang") {
                    this.wipe = this.addActor({
                      cls: "UI-Letterbox",
                      position: [400, -200, 51],
                      scale: [30, 60, 1],
                      rotation: [0, 0, 2.0771916953166105],
                      HSV: [0.575, 255 / 240, 255 / 145] // [339 / 360,  0.71, 0.42] // 0.79, 0.59

                    });
                    this.wipe.setTween({
                      propParent: this.wipe.transform,
                      property: "x",
                      from: this.wipe.transform.x,
                      to: 2500,
                      duration: 200,
                      onComplete: function onComplete() {
                        _this4.remove(_this4.wipe);
                      }
                    });
                  }
                  //     cls: "TC-MM",
                  //     position: [682, -8.5, 2],
                  // });;
                  // Arrow
                  // this.addActor({
                  //     cls: "UI-Arrow",
                  //     position: [1244, 256, 3]
                  // });

                  this.newSprite({
                    src: "TC-LOGO-Game",
                    x: 0,
                    y: 0,
                    z: 9,
                    pivot: [0, 0],
                    scale: scale
                  });
                  this.newSprite({
                    src: "TC-LOGO-Show",
                    x: 0,
                    y: 0,
                    z: 10,
                    pivot: [0, 0],
                    scale: scale
                  });
                  playerHasHighscore = window.localStorage.getItem("mm_ftp_highscore") && window.localStorage.getItem("mm_ftp_highscore") !== JSON.stringify(CONFIG.meta.defaultHighScores); // game.router.map.game.module.playerHasHighscore;
                  // this.addActor({
                  //     cls: "UI-Trophy",
                  //     position: [1184, 107, 3]
                  // });
                  // // Score text
                  // this.txtScore = new Text({
                  //     glyphSpriteSheet: game.spritesheets["mm-glyphs.json"],
                  //     glyphAnimation: "SD",
                  //     glyphCharacters: "0123456789^*,-H.+Xv",
                  //     text: game.router.map.game.module.highscores[0] + "",
                  //     align: "center",
                  //     alignVertical: "bottom",
                  //     tracking: -4,
                  // });
                  // this.txtScore.transform.xyz = [1257, 90, 80];
                  // this.txtScore.transform.sxyz = [0.8, 0.8, 0.8];
                  // this.add(this.txtScore);
                  // Version #


                  text = new Text({
                    glyphSpriteSheet: game.spritesheets["mm-glyphs.json"],
                    glyphAnimation: "SD-Glyphs-Version",
                    glyphCharacters: "0123456789-!.vx",
                    text: "v." + CONFIG.meta.version,
                    align: "left",
                    alignVertical: "bottom",
                    tracking: -4
                  });
                  text.transform.xyz = [65, 43, 8]; // text.transform.sxyz = [0.225, 0.225, 1];

                  text.HSV = [0, 0, -0.3];
                  this.add(text);
                  this.remove(this.frame);
                  this.frame = this.addActor({
                    cls: "BG-Frame",
                    position: [0, 0, 40]
                  }, true);
                  this.transitionOverlay = new TransitionOverlay({
                    isFaded: true
                  });
                  this.add(this.transitionOverlay);
                  this.transitionOverlay.fadeIn();
                  this.transitionOverlay.transform.xyz = [1300, 0, 50]; // TODO: Is Z backwards for fixed position?

                  this.transitionOverlay.transform.sxyz = [0.9, 0.9, 1]; // this.transitionOverlay.transform.positionFixed = true;

                  this.sortEntitiesByZ(true);

                case 32:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee, this);
        }));

        function loadScene() {
          return _loadScene.apply(this, arguments);
        }

        return loadScene;
      }()
    }, {
      key: "addActor",
      value: function addActor(actor) {
        var addToScene = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
        var actorClass = actor.cls;
        var newActor;

        if (CONFIG.classes[actorClass] === undefined) {
          console.log("Actor class \"".concat(actorClass, "\" does not exist."));
          return;
        }

        var behavior = actor.behavior !== undefined ? actor.behavior : CONFIG.classes[actorClass].behavior;

        if (behavior) {
          newActor = new behavior(CONFIG.classes[actorClass], actor);
        } else {
          newActor = new Actor(CONFIG.classes[actorClass], actor);
        }

        if (!this.actors[actorClass]) this.actors[actorClass] = [];
        this.actors[actorClass].push(newActor);
        if (addToScene) this.add(newActor);
        this.sortEntitiesByZ(true);
        if (this.overlay) this.entities.push(this.entities.splice(this.entities.indexOf(this.overlay), 1)[0]);
        return newActor;
      }
    }, {
      key: "removeActor",
      value: function removeActor(actor) {
        var removeFromScene = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
        if (!actor) return;
        var index = this.actors[actor.className].indexOf(actor);
        this.actors[actor.className].splice(index, 1);
        if (removeFromScene) this.remove(actor);
      }
    }, {
      key: "newSprite",
      value: function () {
        var _newSprite = _asyncToGenerator(
        /*#__PURE__*/
        regeneratorRuntime.mark(function _callee2(_ref) {
          var _ref$src, src, _ref$id, id, _ref$frame, _ref$x, x, _ref$y, y, _ref$z, z, _ref$scale, scale, _ref$pivot, pivot, _ref$visible, visible, onMouseDown, onMouseUp, texture, _iteratorNormalCompletion4, _didIteratorError4, _iteratorError4, _iterator4, _step4, t, sprite;

          return regeneratorRuntime.wrap(function _callee2$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  _ref$src = _ref.src, src = _ref$src === void 0 ? "" : _ref$src, _ref$id = _ref.id, id = _ref$id === void 0 ? src : _ref$id, _ref$frame = _ref.frame, _ref$x = _ref.x, x = _ref$x === void 0 ? 0 : _ref$x, _ref$y = _ref.y, y = _ref$y === void 0 ? 0 : _ref$y, _ref$z = _ref.z, z = _ref$z === void 0 ? 0 : _ref$z, _ref$scale = _ref.scale, scale = _ref$scale === void 0 ? [1, 1, 1] : _ref$scale, _ref$pivot = _ref.pivot, pivot = _ref$pivot === void 0 ? [0, 0] : _ref$pivot, _ref$visible = _ref.visible, visible = _ref$visible === void 0 ? true : _ref$visible, onMouseDown = _ref.onMouseDown, onMouseUp = _ref.onMouseUp;
                  _iteratorNormalCompletion4 = true;
                  _didIteratorError4 = false;
                  _iteratorError4 = undefined;
                  _context2.prev = 4;

                  for (_iterator4 = game.textures[Symbol.iterator](); !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
                    t = _step4.value;
                    if (t.src === "res/textures/" + src + ".png") texture = t;
                  }

                  _context2.next = 12;
                  break;

                case 8:
                  _context2.prev = 8;
                  _context2.t0 = _context2["catch"](4);
                  _didIteratorError4 = true;
                  _iteratorError4 = _context2.t0;

                case 12:
                  _context2.prev = 12;
                  _context2.prev = 13;

                  if (!_iteratorNormalCompletion4 && _iterator4["return"] != null) {
                    _iterator4["return"]();
                  }

                case 15:
                  _context2.prev = 15;

                  if (!_didIteratorError4) {
                    _context2.next = 18;
                    break;
                  }

                  throw _iteratorError4;

                case 18:
                  return _context2.finish(15);

                case 19:
                  return _context2.finish(12);

                case 20:
                  sprite = new Sprite({
                    id: id,
                    src: "res/textures/" + src + ".png",
                    pixelsPerUnit: 1,
                    minFilter: "LINEAR_MIPMAP_NEAREST",
                    magFilter: "LINEAR",
                    textures: [texture],
                    material: MATERIAL$3,
                    pivot: pivot
                  });
                  this.sprites[id] = new Entity({
                    components: [sprite],
                    transform: new Transform({
                      position: [x, y, z],
                      scale: scale
                    })
                  });
                  this.add(this.sprites[id]);
                  this.sprites[id].HSV = [0, 0, 0];
                  this.sprites[id].visible = visible;

                  if (onMouseDown) {
                    this.sprites[id].onMouseDown = onMouseDown;
                  }

                  if (onMouseUp) {
                    this.sprites[id].onMouseUp = onMouseUp;
                  }

                  if (!onMouseDown && !onMouseUp) this.sprites[id].pointerEvents = false;
                  return _context2.abrupt("return", this.sprites[id]);

                case 29:
                case "end":
                  return _context2.stop();
              }
            }
          }, _callee2, this, [[4, 8, 12, 20], [13,, 15, 19]]);
        }));

        function newSprite(_x) {
          return _newSprite.apply(this, arguments);
        }

        return newSprite;
      }()
    }]);

    return GameTitle;
  }(Scene);

  var SceneIntro =
  /*#__PURE__*/
  function (_Onyx$Scene) {
    _inherits(SceneIntro, _Onyx$Scene);

    function SceneIntro() {
      var _this;

      _classCallCheck(this, SceneIntro);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(SceneIntro).call(this));
      _this.renderPasses = [new RenderPass({
        viewportClear: true
      })];
      _this.actors = {};
      _this.sprites = {};
      _this.mouseDown = false;
      _this.gamepadButtonState = [];
      _this.listenerClick = {
        handleEvent: function handleEvent(evt) {
          return _this.onClick(evt);
        }
      };
      _this.listenerMouseDown = {
        handleEvent: function handleEvent(evt) {
          return _this.onMouseDown(evt);
        }
      };
      return _this;
    }

    _createClass(SceneIntro, [{
      key: "onload",
      value: function onload() {
        var _this2 = this;

        var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
            _ref$letterbox = _ref.letterbox,
            letterbox = _ref$letterbox === void 0 ? false : _ref$letterbox,
            _ref$fadeIn = _ref.fadeIn,
            fadeIn = _ref$fadeIn === void 0 ? false : _ref$fadeIn;

        // this.viewports[0].id = 0; // Hotfix so it doesn't reload the textures (It's creating a new viewport object every scene)
        this.viewports = game.router.map.preloader.module.viewports; // this.viewports[0].listenForMouseEvents({ scene: game.router.map.gameover.module, renderPick: true });
        // this.viewports = game.router.map.preloader.module.viewports;
        // this.viewports[0].mouseEventHover = false;

        this.gamepadButtonState = [];
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = game.gamepads[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var gamepad = _step.value;

            for (var i in gamepad.buttons) {
              this.gamepadButtonState[i] = gamepad.buttons[i].pressed;
            }
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator["return"] != null) {
              _iterator["return"]();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }

        this.isReady = false;
        this.renderPasses = [new RenderPass()];
        this.loadScene().then(function () {
          _this2.transitionOverlay = new TransitionOverlay({
            isShowingLetterbox: letterbox,
            isFaded: fadeIn
          });

          _this2.add(_this2.transitionOverlay);

          if (fadeIn) _this2.transitionOverlay.fadeIn();
          _this2.transitionOverlay.transform.xyz = [1300, 0, -10]; // TODO: Is Z backwards for fixed position?

          _this2.transitionOverlay.transform.sxyz = [0.9, 0.9, 1];
          _this2.transitionOverlay.transform.positionFixed = true;

          _this2.sortEntitiesByZ(true);

          if (_this2.transitionOverlay) _this2.entities.push(_this2.entities.splice(_this2.entities.indexOf(_this2.transitionOverlay), 1)[0]); // game.playMusic("AO-Music");

          _this2.complete = false;

          _this2.setTimeout(function () {
            _this2.animateScene();
          }, 32);
        });

        this.onKeyDown = function (evt) {
          if (evt.key === "Escape") _this2.isReady = true;

          _this2.onClick();
        };

        window.addEventListener("keydown", this.onKeyDown);
      }
    }, {
      key: "onunload",
      value: function onunload() {
        this.entities = [];
        this.cameras = [];
        this.components = []; // this.viewports[0].bindToCamera();

        this.viewports[0].removeMouseListenEvents({
          scene: this
        });
        window.removeEventListener("keydown", this.onKeyDown);

        for (var _i = 0, _Object$values = Object.values(this.actors); _i < _Object$values.length; _i++) {
          var actorClass = _Object$values[_i];
          var _iteratorNormalCompletion5 = true;
          var _didIteratorError5 = false;
          var _iteratorError5 = undefined;

          try {
            for (var _iterator5 = actorClass[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
              var actor = _step5.value;
              this.remove(actor);
            }
          } catch (err) {
            _didIteratorError5 = true;
            _iteratorError5 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion5 && _iterator5["return"] != null) {
                _iterator5["return"]();
              }
            } finally {
              if (_didIteratorError5) {
                throw _iteratorError5;
              }
            }
          }
        }

        this.remove(this.ui); // Remove any remaining text

        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
          for (var _iterator2 = this.entities[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var entity = _step2.value;

            if (entity instanceof Text) {
              this.remove(entity, true);
            }
          } // Remove any remaining tweens

        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
              _iterator2["return"]();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }

        var _iteratorNormalCompletion3 = true;
        var _didIteratorError3 = false;
        var _iteratorError3 = undefined;

        try {
          for (var _iterator3 = this.components[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
            var component = _step3.value;

            if (component instanceof Tween) {
              this.removeComponent(component);
            }
          } // Remove any remaining timers

        } catch (err) {
          _didIteratorError3 = true;
          _iteratorError3 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
              _iterator3["return"]();
            }
          } finally {
            if (_didIteratorError3) {
              throw _iteratorError3;
            }
          }
        }

        var _iteratorNormalCompletion4 = true;
        var _didIteratorError4 = false;
        var _iteratorError4 = undefined;

        try {
          for (var _iterator4 = this.components[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
            var _component = _step4.value;

            if (_component instanceof Timer) {
              this.removeComponent(_component);
            }
          } // Clear

        } catch (err) {
          _didIteratorError4 = true;
          _iteratorError4 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion4 && _iterator4["return"] != null) {
              _iterator4["return"]();
            }
          } finally {
            if (_didIteratorError4) {
              throw _iteratorError4;
            }
          }
        }

        this.actors = {};
      }
    }, {
      key: "update",
      value: function update() {
        _get(_getPrototypeOf(SceneIntro.prototype), "update", this).apply(this, arguments); // Poll gamepads


        var _iteratorNormalCompletion6 = true;
        var _didIteratorError6 = false;
        var _iteratorError6 = undefined;

        try {
          for (var _iterator6 = game.gamepads[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
            var gamepad = _step6.value;

            for (var i in gamepad.buttons) {
              var pressed = gamepad.buttons[i].pressed;

              if (this.gamepadButtonState[i] !== pressed) {
                this.gamepadButtonState[i] = pressed;

                if (pressed) {
                  // Dash
                  if (!CONFIG.meta.buttons.gamepad.skip.length || CONFIG.meta.buttons.gamepad.skip.indexOf(i * 1) > -1) {
                    this.isReady = true;
                    this.onClick({
                      type: "gamepad",
                      button: i
                    });
                  }
                }
              }
            }
          }
        } catch (err) {
          _didIteratorError6 = true;
          _iteratorError6 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion6 && _iterator6["return"] != null) {
              _iterator6["return"]();
            }
          } finally {
            if (_didIteratorError6) {
              throw _iteratorError6;
            }
          }
        }
      }
    }, {
      key: "onMouseDown",
      value: function onMouseDown() {
        this.mouseDown = true; // this.button.state = "press";
        // this.cat.sprite.currentAnimation.setFrame(3);
        // game.playSFX('SO-ButtonPress');
      }
    }, {
      key: "onMouseUp",
      value: function onMouseUp() {
        this.mouseDown = false; // this.button.state = "idle";

        this.onClick();
      }
    }, {
      key: "onClick",
      value: function onClick(trophy) {
        if (this.complete || !this.isReady) return;
        this.complete = true;
        this.mouseDown = false; // this.button.state = "idle";

        this.nextScene();
      }
    }, {
      key: "nextScene",
      value: function nextScene() {
        var _this3 = this;

        this.transitionOverlay.fadeOut(function () {
          _this3.onunload();

          router.navigate("game", {
            showInstructions: true
          });
        });
      }
    }, {
      key: "loadScene",
      value: function () {
        var _loadScene = _asyncToGenerator(
        /*#__PURE__*/
        regeneratorRuntime.mark(function _callee() {
          var camera;
          return regeneratorRuntime.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  camera = new Camera({
                    projectionType: "orthographic",
                    transform: new Transform({
                      position: [0, 0, 100]
                    })
                  });
                  this.add(camera);
                  this.viewports[0].bindToCamera(camera); // Background

                  this.bg = this.addActor({
                    cls: "IN-Sky",
                    position: [0, 0, 0],
                    scale: [3.15, 3.15, 3.05]
                  }); // Tower

                  this.tower = this.addActor({
                    cls: "IN-Tower",
                    position: [300, 0, 1]
                  }); // Dragon

                  this.dragon = this.addActor({
                    cls: "IN-Dragon",
                    position: [0, 0, 2]
                  }); // Ice

                  this.ice = this.addActor({
                    cls: "IN-Ice",
                    position: [0, 0, 2]
                  }); // ABBC

                  this.abbc = this.addActor({
                    cls: "IN-ABBC",
                    position: [0, 0, 3]
                  }); // MaoMao

                  this.maomao = this.addActor({
                    cls: "IN-MaoMao",
                    position: [0, 0, 3]
                  });

                case 9:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee, this);
        }));

        function loadScene() {
          return _loadScene.apply(this, arguments);
        }

        return loadScene;
      }()
    }, {
      key: "addActor",
      value: function addActor(actor) {
        var addToScene = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
        var actorClass = actor.cls;
        var newActor;

        if (CONFIG.classes[actorClass] === undefined) {
          console.log("Actor class \"".concat(actorClass, "\" does not exist."));
          return;
        }

        var behavior = actor.behavior !== undefined ? actor.behavior : CONFIG.classes[actorClass].behavior;

        if (behavior) {
          newActor = new behavior(CONFIG.classes[actorClass], actor);
        } else {
          newActor = new Actor(CONFIG.classes[actorClass], actor);
        }

        if (!this.actors[actorClass]) this.actors[actorClass] = [];
        this.actors[actorClass].push(newActor);
        if (addToScene) this.add(newActor);
        this.sortEntitiesByZ(true);
        if (this.transitionOverlay) this.entities.push(this.entities.splice(this.entities.indexOf(this.transitionOverlay), 1)[0]);
        return newActor;
      }
    }, {
      key: "removeActor",
      value: function removeActor(actor) {
        var removeFromScene = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
        if (!actor) return;
        var index = this.actors[actor.className].indexOf(actor);
        this.actors[actor.className].splice(index, 1);
        if (removeFromScene) this.remove(actor);
      }
    }, {
      key: "shakeCamera",
      value: function shakeCamera() {
        var _this4 = this;

        var force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 200;
        var decay = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.88;
        var speed = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 55;
        // let polarity = 1;
        var startX = this.cameras[0].transform.x;
        var startY = this.cameras[0].transform.y; // this.from + ((this.to - this.from) * this.method(this.percentComplete))

        var shake = this.setModulate(function (dt, progress, count) {
          progress = (progress - 0.5) * 2;
          var to = _this4.cameras[0].transform.y + force;
          var from = _this4.cameras[0].transform.y;
          var v = 0 + (force - 0) * (-Math.cos(progress * Math.PI) / 2 + 0); // var v = 0 + (Math.PI-0)*((-Math.cos(progress*Math.PI)/2) + 0);
          // var angle = (Math.PI / 2) * polarity;
          // var px = Math.cos(angle) * force;
          // var py = Math.sin(angle) * force;
          // this.cameras[0].transform.x = startX + px;

          _this4.cameras[0].transform.y = startY + v;
          force *= decay; // polarity *= -1;

          if (force < 0.1) {
            _this4.removeComponent(shake);

            _this4.cameras[0].transform.x = startX;
            _this4.cameras[0].transform.y = startY;
          }
        }, speed);
      }
    }, {
      key: "animateScene",
      value: function animateScene() {
        var _this5 = this;

        this.ice.visible = false; // Slide MaoMao left

        this.setTween({
          propParent: this.maomao.transform,
          property: "x",
          to: 0,
          from: 65,
          method: "easeIn",
          duration: 1583
        }); // Slide abbc left

        this.setTween({
          propParent: this.abbc.transform,
          property: "x",
          to: 0,
          from: 25,
          method: "easeIn",
          duration: 1583
        }); // Slide Dragon right

        this.setTween({
          propParent: this.dragon.transform,
          property: "x",
          to: 0,
          from: -25,
          method: "easeIn",
          duration: 2783
        }); // Slide Dragon up

        this.setTween({
          propParent: this.dragon.transform,
          property: "y",
          to: 0,
          from: -25,
          method: "easeIn",
          duration: 2783
        }); // Slide tower left
        // this.setTween({
        //     propParent: this.tower.transform,
        //     property: "x",
        //     to: 300,
        //     from: 292,
        //     method: "easeIn",
        //     duration: 1583
        // });
        // Slide Sky right

        this.setTween({
          propParent: this.bg.transform,
          property: "x",
          to: 0,
          from: -35,
          method: "linear",
          duration: 4000
        }); // this.setTimeout(() => {
        //     game.playSFX("IN-IceAttack");
        // }, 2383);

        this.dragon.sprite.currentAnimation.frames[15].onStart = function () {
          _this5.maomao.state = "jump";
          _this5.abbc.state = "jump";
          _this5.ice.visible = true;
          _this5.ice.state = "idle";
          game.playSFX("IN-IceAttack");

          _this5.abbc.sprite.currentAnimation.callback = function () {
            _this5.abbc.visible = false;
          };

          _this5.maomao.sprite.currentAnimation.callback = function () {
            _this5.setTimeout(function () {
              _this5.nextScene();
            }, 100);
          };
        };
      }
    }]);

    return SceneIntro;
  }(Scene);

  var VERTEX_SHADER$5 = "\n    attribute vec3 aVertexPosition;\n\n    // uniform mat4 uMVCPMatrix; // Model View Camera Projection Matrix\n    uniform mat4 uVMatrix;\n    uniform mat4 uMMatrix;\n    \n    void main(void) {\n        // gl_Position = uMVCPMatrix * vec4(aVertexPosition, 1.0);\n        gl_Position = uVMatrix * uMMatrix * vec4(aVertexPosition, 1.0);\n    }\n";
  var FRAG_SHADER$4 = "\n    #extension GL_OES_standard_derivatives: enable\n\n    #ifdef GL_FRAGMENT_PRECISION_HIGH\n        precision highp float;\n    #else\n        precision mediump float;\n    #endif\n\n    // uniform sampler2D uDiffuseTexture;\n\n    void main(void) {\n        gl_FragColor = vec4(.1, .1, .1, 1.);\n        \n        if(gl_FragColor.a == 0.0) discard;\n    }\n";

  var MaterialGround =
  /*#__PURE__*/
  function (_Onyx$Material) {
    _inherits(MaterialGround, _Onyx$Material);

    function MaterialGround() {
      var _this;

      _classCallCheck(this, MaterialGround);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(MaterialGround).apply(this, arguments));
      _this.vertexShader = VERTEX_SHADER$5;
      _this.fragmentShader = FRAG_SHADER$4;
      _this.blend = true;
      _this.depthTest = true;
      _this.cullFace = false;
      return _this;
    }

    _createClass(MaterialGround, [{
      key: "render",
      value: function render(dt, scene, viewport, camera, stack, viewMatrix, modelMatrix, frameBufferTextureStack) {
        // Set uniforms (uMVMatrix, etc...)
        _get(_getPrototypeOf(MaterialGround.prototype), "render", this).call(this, dt, scene, viewport, camera, stack, viewMatrix, modelMatrix, frameBufferTextureStack);
      }
    }]);

    return MaterialGround;
  }(Material);

  var materialGround = new MaterialGround();
  var room_height = 610;
  var room_width = 1365;

  var Ground =
  /*#__PURE__*/
  function (_Onyx$Entity) {
    _inherits(Ground, _Onyx$Entity);

    function Ground() {
      var _this;

      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref$x_width = _ref.x_width,
          x_width = _ref$x_width === void 0 ? CONFIG.meta.generator.x_width : _ref$x_width,
          _ref$y_height = _ref.y_height,
          y_height = _ref$y_height === void 0 ? CONFIG.meta.generator.y_height : _ref$y_height,
          _ref$change_y_odds = _ref.change_y_odds,
          change_y_odds = _ref$change_y_odds === void 0 ? CONFIG.meta.generator.change_y_odds : _ref$change_y_odds,
          _ref$ground_friction = _ref.ground_friction,
          ground_friction = _ref$ground_friction === void 0 ? CONFIG.meta.generator.ground_friction : _ref$ground_friction,
          seed = _ref.seed;

      _classCallCheck(this, Ground);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(Ground).apply(this, arguments));
      _this.random = new Math.seedrandom(seed);
      _this.pointerEvents = false; // Global variables

      _this.x_width = x_width;
      _this.y_height = y_height;
      _this.change_y_odds = change_y_odds;
      _this.ground_friction = ground_friction; // Generate segments

      var segments = _this.generate();

      _this.segments = {
        x: segments.segx,
        y: segments.segy
      };
      _this.scoobySegment = segments.scooby_segment;
      _this.ballSegment = segments.ball_segment;
      _this.height = room_height;
      _this.width = room_width; // Flatten for earcut
      // e.g. [segx[0],segy[0], segx[1],segy[1], segx[2],segy[2], ...]
      // and build polygon (for physics ground body)

      var coordinates = [];
      _this.groundPolygonVertices = [];

      for (var i = 0; i < segments.segx.length - 1; i++) {
        coordinates.push(segments.segx[i]);
        coordinates.push(segments.segy[i]);

        _this.groundPolygonVertices.push({
          x: segments.segx[i],
          y: segments.segy[i]
        });
      } // Get triangulation indices from earcut


      var indicies = earcut(coordinates, [], 2); // Convert indicies to vertices (for GPU performance)

      var vertexArray = new Float32Array(indicies.length * 3);

      for (var _i = 0; _i < indicies.length; _i++) {
        vertexArray[_i * 3 + 0] = coordinates[indicies[_i] * 2 + 0];
        vertexArray[_i * 3 + 1] = coordinates[indicies[_i] * 2 + 1];
        vertexArray[_i * 3 + 2] = 0; // Flip Y

        vertexArray[_i * 3 + 1] = room_height - vertexArray[_i * 3 + 1];
      } // console.log(segments);
      // console.table(coordinates);
      // console.table(indicies);
      // console.table(vertexArray);


      var result = _this.addPhysicsBody();

      if (!result) return _possibleConstructorReturn(_this, _construct(Ground, Array.prototype.slice.call(arguments))); // Try again if it failed to create the physics body

      _this.mesh = new Mesh({
        material: materialGround,
        vertices: vertexArray // Draw lines
        // drawMode: "LINE_STRIP"

      });

      _this.mesh.invalidate();

      _this.addComponent(_this.mesh);

      return _this;
    }

    _createClass(Ground, [{
      key: "addPhysicsBody",
      value: function addPhysicsBody() {
        this.physicsEnabled = true; // Determine body dimensions to determine center

        var tBody = Matter.Bodies.fromVertices(0, 0, this.groundPolygonVertices, {
          friction: this.ground_friction,
          isStatic: true
        }); // TODO: Sometimes body isn't created?

        if (!tBody) {
          return console.error("Couldn't create body", this.groundPolygonVertices);
        }

        var minX = Infinity;
        var maxX = 0;
        var minY = Infinity;
        var maxY = 0;
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = tBody.parts[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var part = _step.value;
            var _iteratorNormalCompletion2 = true;
            var _didIteratorError2 = false;
            var _iteratorError2 = undefined;

            try {
              for (var _iterator2 = part.vertices[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                var vertex = _step2.value;
                minX = Math.min(minX, vertex.x);
                maxX = Math.max(maxX, vertex.x);
                minY = Math.min(minX, vertex.y);
                maxY = Math.max(maxY, vertex.y);
              }
            } catch (err) {
              _didIteratorError2 = true;
              _iteratorError2 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
                  _iterator2["return"]();
                }
              } finally {
                if (_didIteratorError2) {
                  throw _iteratorError2;
                }
              }
            }
          } // Create new body at correct position

        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator["return"] != null) {
              _iterator["return"]();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }

        this.body = Matter.Bodies.fromVertices(-minX, //this.transform.x,
        -maxY, //this.transform.y,
        this.groundPolygonVertices, {
          friction: this.ground_friction,
          isStatic: true
        });
        this.body.parentEntity = this;
        this.body.prevVelocity = {
          x: 0,
          y: 0
        };
        return this.body;
      }
    }, {
      key: "onSpawn",
      value: function onSpawn() {
        _get(_getPrototypeOf(Ground.prototype), "onSpawn", this).apply(this, arguments);

        Matter.World.add(this.parentScene.matterEngine.world, [this.body]);
      }
    }, {
      key: "onDestroy",
      value: function onDestroy() {
        _get(_getPrototypeOf(Ground.prototype), "onDestroy", this).apply(this, arguments);

        if (this.body) {
          Matter.World.remove(this.parentScene.matterEngine.world, this.body);
        }
      }
      /**
       * Returns a random integer between 0 and n. This includes n if n itself is an integer value.
       * @param {*} n The upper range from which the random number will be selected.
       */

    }, {
      key: "irandom",
      value: function irandom(n) {
        return this.random() * n | 0;
      }
      /**
       * Randomly chooses one of of a set of arguments.
       * @param {*} val0 An input value that can be string, integer, variable or constant.
       */

    }, {
      key: "choose",
      value: function choose() {
        // For clarity
        var choices = arguments;
        return choices[this.random() * choices.length | 0];
      }
    }, {
      key: "generate",
      value: function generate() {
        var x = 2;
        var y = room_height / 2 + this.irandom(room_height / 3) - this.irandom(room_height / 6);
        var segx = [];
        var segy = [];
        var segments = 0;
        segx[0] = x;
        segy[0] = y;
        var scooby_segment = -1;
        var ball_segment = -1;
        var ball_segment_range_min = 200; //(this.x_width / 5) * 1;

        var scooby_segment_range_min = 1000; //(this.x_width / 5) * 2;

        var minChangeX = this.x_width / 2;
        var maxChangeX = this.x_width;
        var minChangeY = this.y_height / 2;
        var maxChangeY = this.y_height;
        var change_y_odds = this.change_y_odds / 100;
        var spike_odds = 0;
        var changedYLast = true;

        while (x < room_width) {
          // If X hasn't made it to the right side of the screen, keep going...
          segments += 1;
          var xChange = 0;
          var yChange = 0; // Determine xChange

          xChange = this.random() * (maxChangeX - minChangeX) + minChangeX; // Possible wall

          if (!changedYLast && this.random() > 0.95 && ball_segment > 0 && segments > ball_segment + 1) xChange = 0.01; // Overhang
          // if(changedYLast < 0 && this.random() > 0.5){
          //     xChange *= -1;
          // }
          // Determine Y change
          // Change at all?

          var canChange = ball_segment < segments + 1; // !changedYLast && 

          if (canChange && this.random() < change_y_odds) {
            // How much?
            var heightScale = this.irandom(this.y_height) - this.irandom(this.y_height / 2);
            if (heightScale == 0) heightScale = this.choose(-1, 1);
            y += this.choose(10, 10, 10, 10, 20, 20, 30, 40) * heightScale;

            if (y > room_height - room_height / 5) {
              y = room_height - room_height / 5;
              y -= Math.abs(this.choose(10, 10, 10, 10, 20, 20, 30) * (heightScale / 2));
            }

            if (y < 0) {
              y = 0;
              y += Math.abs(this.choose(10, 10, 10, 10, 20, 20, 30) * (heightScale / 2));
            } // If near ball, reduce max amount


            if (segments <= ball_segment + 1) yChange = Math.min(yChange, minChangeY);
            changedYLast = 1; // Up or down?

            if (this.random() > 0.5) {
              yChange *= -1;
              changedYLast = -1;
            }
          } else {
            // Chance of "spike" (short X)
            if (this.random() < spike_odds && scooby_segment < segments + 1) {
              // && ball_segment < segments + 1
              xChange /= 10;
              spike_odds = -1;
            } else {
              spike_odds += this.choose(0, 4, 8) / 10;
            }

            changedYLast = false;
          } // Apply changes


          x += xChange;
          y += yChange; // Cap

          y = Math.max(Math.min(y, room_height - 100), 0); // Determine if ball or scooby segment

          if (ball_segment === -1 && x > ball_segment_range_min && !changedYLast) ball_segment = segments;
          if (scooby_segment === -1 && x > scooby_segment_range_min && !changedYLast) scooby_segment = segments;
          segx[segments] = x;
          segy[segments] = y;
        } // Finish and close the polygon


        segments += 1;
        segx[segments] = room_width - 2;
        segy[segments] = room_height - 2;
        segments += 1;
        segx[segments] = 2;
        segy[segments] = room_height - 2;
        segments += 1;
        segx[segments] = segx[0];
        segy[segments] = segy[0];
        return {
          segx: segx,
          segy: segy,
          count: segments,
          scooby_segment: scooby_segment,
          ball_segment: ball_segment
        };
      }
    }, {
      key: "generateN",
      value: function generateN() {
        var x = 2;
        var y = room_height / 2 + this.irandom(room_height / 3) - this.irandom(room_height / 6);
        var segx = [];
        var segy = [];
        /*
        segments = 8;
          for (let i=0;i<=segments;i+=1) {
            segx[i] = x+i*(room_width/segments);
            segy[i] = y;
        }
        */

        var generateSegment = false; // for(let i=0; i<=512; i+=1) {
        //     segx[i] = -1;
        //     segy[i] = -1;
        // }
        // ^ Not sure if we need this ^

        var segments = 0;
        segx[0] = x;
        segy[0] = y;
        var spike_odds = 0;
        var done = false;
        var scooby_segment = -1;
        var ball_segment = -1;

        while (!done) {
          var change_y_odds = this.change_y_odds; // If X hasn't made it to the right side of the screen, keep going...

          if (x < room_width) {
            generateSegment = true;
          } else {
            done = true;
            segx[segments] = room_width - 2; // close the polygon

            segments += 1;
            segx[segments] = room_width - 2;
            segy[segments] = room_height - 2;
            segments += 1;
            segx[segments] = 2;
            segy[segments] = room_height - 2;
            segments += 1;
            segx[segments] = segx[0];
            segy[segments] = segy[0];
          }

          if (generateSegment) {
            var madeSpike = false;
            segments += 1;

            if (this.irandom(100) > spike_odds) {
              x += this.irandom(this.x_width) + this.irandom(this.x_width / 2); // change_y_odds = 100;

              spike_odds += this.choose(0, 4, 8);
            } else {
              madeSpike = true;
              spike_odds = -10;
            }

            if (this.irandom(100) < change_y_odds || madeSpike && change_y_odds > 10) {
              //heightScale = max(1,(this.irandom(10)-this.irandom(5)))*this.choose(1,2,3);
              var heightScale = this.irandom(this.y_height) - this.irandom(this.y_height / 2);
              if (heightScale == 0) heightScale = this.choose(-1, 1);
              y += this.choose(10, 10, 10, 10, 20, 20, 30, 40) * heightScale;

              if (y > room_height - room_height / 5) {
                y = room_height - room_height / 5;
                y -= Math.abs(this.choose(10, 10, 10, 10, 20, 20, 30) * (heightScale / 2));
              }

              if (y < 0) {
                y = 0;
                y += Math.abs(this.choose(10, 10, 10, 10, 20, 20, 30) * (heightScale / 2));
              }
            } else {
              if (ball_segment == -1 && segments > 3) {
                ball_segment = segments;
              } else {
                if (scooby_segment == -1 && x > room_width * .666) {
                  scooby_segment = segments;
                }
              }
            }

            segx[segments] = x;
            segy[segments] = y;
            generateSegment = false;
          }
        }

        return {
          segx: segx,
          segy: segy,
          count: segments,
          scooby_segment: scooby_segment,
          ball_segment: ball_segment // if(keyboard_check_pressed(ord("R")) || mouse_check_button_pressed(mb_any) game_restart();
          // if(keyboard_check_pressed(vk_escape) game_end();
          // if(keyboard_check(ord("Y"))){
          //     if(keyboard_check(vk_shift)){
          //         if(this.change_y_odds > 0 this.change_y_odds -= );
          //     } else {
          //         if(this.change_y_odds < 100 this.change_y_odds += );
          //     }
          // }
          // if(keyboard_check(ord("W"))){
          //     if(keyboard_check(vk_shift)){
          //         if(this.x_width > 20 this.x_width -= );
          //     } else {
          //         if(this.x_width < 250 this.x_width += );
          //     }
          // }
          // if(keyboard_check(ord("H"))){
          //     if(keyboard_check(vk_shift)){
          //         if(this.y_height > 0 this.y_height -= );
          //     } else {
          //         if(this.y_height < 50 this.y_height += );
          //     }
          // }

        };
      }
    }]);

    return Ground;
  }(Entity);

  /**
   * dat-gui JavaScript Controller Library
   * http://code.google.com/p/dat-gui
   *
   * Copyright 2011 Data Arts Team, Google Creative Lab
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   */
  function ___$insertStyle(css) {
    if (!css) {
      return;
    }

    if (typeof window === 'undefined') {
      return;
    }

    var style = document.createElement('style');
    style.setAttribute('type', 'text/css');
    style.innerHTML = css;
    document.head.appendChild(style);
    return css;
  }

  function colorToString(color, forceCSSHex) {
    var colorFormat = color.__state.conversionName.toString();

    var r = Math.round(color.r);
    var g = Math.round(color.g);
    var b = Math.round(color.b);
    var a = color.a;
    var h = Math.round(color.h);
    var s = color.s.toFixed(1);
    var v = color.v.toFixed(1);

    if (forceCSSHex || colorFormat === 'THREE_CHAR_HEX' || colorFormat === 'SIX_CHAR_HEX') {
      var str = color.hex.toString(16);

      while (str.length < 6) {
        str = '0' + str;
      }

      return '#' + str;
    } else if (colorFormat === 'CSS_RGB') {
      return 'rgb(' + r + ',' + g + ',' + b + ')';
    } else if (colorFormat === 'CSS_RGBA') {
      return 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';
    } else if (colorFormat === 'HEX') {
      return '0x' + color.hex.toString(16);
    } else if (colorFormat === 'RGB_ARRAY') {
      return '[' + r + ',' + g + ',' + b + ']';
    } else if (colorFormat === 'RGBA_ARRAY') {
      return '[' + r + ',' + g + ',' + b + ',' + a + ']';
    } else if (colorFormat === 'RGB_OBJ') {
      return '{r:' + r + ',g:' + g + ',b:' + b + '}';
    } else if (colorFormat === 'RGBA_OBJ') {
      return '{r:' + r + ',g:' + g + ',b:' + b + ',a:' + a + '}';
    } else if (colorFormat === 'HSV_OBJ') {
      return '{h:' + h + ',s:' + s + ',v:' + v + '}';
    } else if (colorFormat === 'HSVA_OBJ') {
      return '{h:' + h + ',s:' + s + ',v:' + v + ',a:' + a + '}';
    }

    return 'unknown format';
  }

  var ARR_EACH = Array.prototype.forEach;
  var ARR_SLICE = Array.prototype.slice;
  var Common = {
    BREAK: {},
    extend: function extend(target) {
      this.each(ARR_SLICE.call(arguments, 1), function (obj) {
        var keys = this.isObject(obj) ? Object.keys(obj) : [];
        keys.forEach(function (key) {
          if (!this.isUndefined(obj[key])) {
            target[key] = obj[key];
          }
        }.bind(this));
      }, this);
      return target;
    },
    defaults: function defaults(target) {
      this.each(ARR_SLICE.call(arguments, 1), function (obj) {
        var keys = this.isObject(obj) ? Object.keys(obj) : [];
        keys.forEach(function (key) {
          if (this.isUndefined(target[key])) {
            target[key] = obj[key];
          }
        }.bind(this));
      }, this);
      return target;
    },
    compose: function compose() {
      var toCall = ARR_SLICE.call(arguments);
      return function () {
        var args = ARR_SLICE.call(arguments);

        for (var i = toCall.length - 1; i >= 0; i--) {
          args = [toCall[i].apply(this, args)];
        }

        return args[0];
      };
    },
    each: function each(obj, itr, scope) {
      if (!obj) {
        return;
      }

      if (ARR_EACH && obj.forEach && obj.forEach === ARR_EACH) {
        obj.forEach(itr, scope);
      } else if (obj.length === obj.length + 0) {
        var key = void 0;
        var l = void 0;

        for (key = 0, l = obj.length; key < l; key++) {
          if (key in obj && itr.call(scope, obj[key], key) === this.BREAK) {
            return;
          }
        }
      } else {
        for (var _key in obj) {
          if (itr.call(scope, obj[_key], _key) === this.BREAK) {
            return;
          }
        }
      }
    },
    defer: function defer(fnc) {
      setTimeout(fnc, 0);
    },
    debounce: function debounce(func, threshold, callImmediately) {
      var timeout = void 0;
      return function () {
        var obj = this;
        var args = arguments;

        function delayed() {
          timeout = null;
          if (!callImmediately) func.apply(obj, args);
        }

        var callNow = callImmediately || !timeout;
        clearTimeout(timeout);
        timeout = setTimeout(delayed, threshold);

        if (callNow) {
          func.apply(obj, args);
        }
      };
    },
    toArray: function toArray(obj) {
      if (obj.toArray) return obj.toArray();
      return ARR_SLICE.call(obj);
    },
    isUndefined: function isUndefined(obj) {
      return obj === undefined;
    },
    isNull: function isNull(obj) {
      return obj === null;
    },
    isNaN: function (_isNaN) {
      function isNaN(_x) {
        return _isNaN.apply(this, arguments);
      }

      isNaN.toString = function () {
        return _isNaN.toString();
      };

      return isNaN;
    }(function (obj) {
      return isNaN(obj);
    }),
    isArray: Array.isArray || function (obj) {
      return obj.constructor === Array;
    },
    isObject: function isObject(obj) {
      return obj === Object(obj);
    },
    isNumber: function isNumber(obj) {
      return obj === obj + 0;
    },
    isString: function isString(obj) {
      return obj === obj + '';
    },
    isBoolean: function isBoolean(obj) {
      return obj === false || obj === true;
    },
    isFunction: function isFunction(obj) {
      return obj instanceof Function;
    }
  };
  var INTERPRETATIONS = [{
    litmus: Common.isString,
    conversions: {
      THREE_CHAR_HEX: {
        read: function read(original) {
          var test = original.match(/^#([A-F0-9])([A-F0-9])([A-F0-9])$/i);

          if (test === null) {
            return false;
          }

          return {
            space: 'HEX',
            hex: parseInt('0x' + test[1].toString() + test[1].toString() + test[2].toString() + test[2].toString() + test[3].toString() + test[3].toString(), 0)
          };
        },
        write: colorToString
      },
      SIX_CHAR_HEX: {
        read: function read(original) {
          var test = original.match(/^#([A-F0-9]{6})$/i);

          if (test === null) {
            return false;
          }

          return {
            space: 'HEX',
            hex: parseInt('0x' + test[1].toString(), 0)
          };
        },
        write: colorToString
      },
      CSS_RGB: {
        read: function read(original) {
          var test = original.match(/^rgb\(\s*(.+)\s*,\s*(.+)\s*,\s*(.+)\s*\)/);

          if (test === null) {
            return false;
          }

          return {
            space: 'RGB',
            r: parseFloat(test[1]),
            g: parseFloat(test[2]),
            b: parseFloat(test[3])
          };
        },
        write: colorToString
      },
      CSS_RGBA: {
        read: function read(original) {
          var test = original.match(/^rgba\(\s*(.+)\s*,\s*(.+)\s*,\s*(.+)\s*,\s*(.+)\s*\)/);

          if (test === null) {
            return false;
          }

          return {
            space: 'RGB',
            r: parseFloat(test[1]),
            g: parseFloat(test[2]),
            b: parseFloat(test[3]),
            a: parseFloat(test[4])
          };
        },
        write: colorToString
      }
    }
  }, {
    litmus: Common.isNumber,
    conversions: {
      HEX: {
        read: function read(original) {
          return {
            space: 'HEX',
            hex: original,
            conversionName: 'HEX'
          };
        },
        write: function write(color) {
          return color.hex;
        }
      }
    }
  }, {
    litmus: Common.isArray,
    conversions: {
      RGB_ARRAY: {
        read: function read(original) {
          if (original.length !== 3) {
            return false;
          }

          return {
            space: 'RGB',
            r: original[0],
            g: original[1],
            b: original[2]
          };
        },
        write: function write(color) {
          return [color.r, color.g, color.b];
        }
      },
      RGBA_ARRAY: {
        read: function read(original) {
          if (original.length !== 4) return false;
          return {
            space: 'RGB',
            r: original[0],
            g: original[1],
            b: original[2],
            a: original[3]
          };
        },
        write: function write(color) {
          return [color.r, color.g, color.b, color.a];
        }
      }
    }
  }, {
    litmus: Common.isObject,
    conversions: {
      RGBA_OBJ: {
        read: function read(original) {
          if (Common.isNumber(original.r) && Common.isNumber(original.g) && Common.isNumber(original.b) && Common.isNumber(original.a)) {
            return {
              space: 'RGB',
              r: original.r,
              g: original.g,
              b: original.b,
              a: original.a
            };
          }

          return false;
        },
        write: function write(color) {
          return {
            r: color.r,
            g: color.g,
            b: color.b,
            a: color.a
          };
        }
      },
      RGB_OBJ: {
        read: function read(original) {
          if (Common.isNumber(original.r) && Common.isNumber(original.g) && Common.isNumber(original.b)) {
            return {
              space: 'RGB',
              r: original.r,
              g: original.g,
              b: original.b
            };
          }

          return false;
        },
        write: function write(color) {
          return {
            r: color.r,
            g: color.g,
            b: color.b
          };
        }
      },
      HSVA_OBJ: {
        read: function read(original) {
          if (Common.isNumber(original.h) && Common.isNumber(original.s) && Common.isNumber(original.v) && Common.isNumber(original.a)) {
            return {
              space: 'HSV',
              h: original.h,
              s: original.s,
              v: original.v,
              a: original.a
            };
          }

          return false;
        },
        write: function write(color) {
          return {
            h: color.h,
            s: color.s,
            v: color.v,
            a: color.a
          };
        }
      },
      HSV_OBJ: {
        read: function read(original) {
          if (Common.isNumber(original.h) && Common.isNumber(original.s) && Common.isNumber(original.v)) {
            return {
              space: 'HSV',
              h: original.h,
              s: original.s,
              v: original.v
            };
          }

          return false;
        },
        write: function write(color) {
          return {
            h: color.h,
            s: color.s,
            v: color.v
          };
        }
      }
    }
  }];
  var result = void 0;
  var toReturn = void 0;

  var interpret = function interpret() {
    toReturn = false;
    var original = arguments.length > 1 ? Common.toArray(arguments) : arguments[0];
    Common.each(INTERPRETATIONS, function (family) {
      if (family.litmus(original)) {
        Common.each(family.conversions, function (conversion, conversionName) {
          result = conversion.read(original);

          if (toReturn === false && result !== false) {
            toReturn = result;
            result.conversionName = conversionName;
            result.conversion = conversion;
            return Common.BREAK;
          }
        });
        return Common.BREAK;
      }
    });
    return toReturn;
  };

  var tmpComponent = void 0;
  var ColorMath = {
    hsv_to_rgb: function hsv_to_rgb(h, s, v) {
      var hi = Math.floor(h / 60) % 6;
      var f = h / 60 - Math.floor(h / 60);
      var p = v * (1.0 - s);
      var q = v * (1.0 - f * s);
      var t = v * (1.0 - (1.0 - f) * s);
      var c = [[v, t, p], [q, v, p], [p, v, t], [p, q, v], [t, p, v], [v, p, q]][hi];
      return {
        r: c[0] * 255,
        g: c[1] * 255,
        b: c[2] * 255
      };
    },
    rgb_to_hsv: function rgb_to_hsv(r, g, b) {
      var min = Math.min(r, g, b);
      var max = Math.max(r, g, b);
      var delta = max - min;
      var h = void 0;
      var s = void 0;

      if (max !== 0) {
        s = delta / max;
      } else {
        return {
          h: NaN,
          s: 0,
          v: 0
        };
      }

      if (r === max) {
        h = (g - b) / delta;
      } else if (g === max) {
        h = 2 + (b - r) / delta;
      } else {
        h = 4 + (r - g) / delta;
      }

      h /= 6;

      if (h < 0) {
        h += 1;
      }

      return {
        h: h * 360,
        s: s,
        v: max / 255
      };
    },
    rgb_to_hex: function rgb_to_hex(r, g, b) {
      var hex = this.hex_with_component(0, 2, r);
      hex = this.hex_with_component(hex, 1, g);
      hex = this.hex_with_component(hex, 0, b);
      return hex;
    },
    component_from_hex: function component_from_hex(hex, componentIndex) {
      return hex >> componentIndex * 8 & 0xFF;
    },
    hex_with_component: function hex_with_component(hex, componentIndex, value) {
      return value << (tmpComponent = componentIndex * 8) | hex & ~(0xFF << tmpComponent);
    }
  };

  var _typeof$1 = typeof Symbol === "function" && _typeof(Symbol.iterator) === "symbol" ? function (obj) {
    return _typeof(obj);
  } : function (obj) {
    return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof(obj);
  };

  var classCallCheck = function classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  };

  var createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();

  var get = function get(object, property, receiver) {
    if (object === null) object = Function.prototype;
    var desc = Object.getOwnPropertyDescriptor(object, property);

    if (desc === undefined) {
      var parent = Object.getPrototypeOf(object);

      if (parent === null) {
        return undefined;
      } else {
        return get(parent, property, receiver);
      }
    } else if ("value" in desc) {
      return desc.value;
    } else {
      var getter = desc.get;

      if (getter === undefined) {
        return undefined;
      }

      return getter.call(receiver);
    }
  };

  var inherits = function inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + _typeof(superClass));
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  };

  var possibleConstructorReturn = function possibleConstructorReturn(self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return call && (_typeof(call) === "object" || typeof call === "function") ? call : self;
  };

  var Color$1 = function () {
    function Color() {
      classCallCheck(this, Color);
      this.__state = interpret.apply(this, arguments);

      if (this.__state === false) {
        throw new Error('Failed to interpret color arguments');
      }

      this.__state.a = this.__state.a || 1;
    }

    createClass(Color, [{
      key: 'toString',
      value: function toString() {
        return colorToString(this);
      }
    }, {
      key: 'toHexString',
      value: function toHexString() {
        return colorToString(this, true);
      }
    }, {
      key: 'toOriginal',
      value: function toOriginal() {
        return this.__state.conversion.write(this);
      }
    }]);
    return Color;
  }();

  function defineRGBComponent(target, component, componentHexIndex) {
    Object.defineProperty(target, component, {
      get: function get$$1() {
        if (this.__state.space === 'RGB') {
          return this.__state[component];
        }

        Color$1.recalculateRGB(this, component, componentHexIndex);
        return this.__state[component];
      },
      set: function set$$1(v) {
        if (this.__state.space !== 'RGB') {
          Color$1.recalculateRGB(this, component, componentHexIndex);
          this.__state.space = 'RGB';
        }

        this.__state[component] = v;
      }
    });
  }

  function defineHSVComponent(target, component) {
    Object.defineProperty(target, component, {
      get: function get$$1() {
        if (this.__state.space === 'HSV') {
          return this.__state[component];
        }

        Color$1.recalculateHSV(this);
        return this.__state[component];
      },
      set: function set$$1(v) {
        if (this.__state.space !== 'HSV') {
          Color$1.recalculateHSV(this);
          this.__state.space = 'HSV';
        }

        this.__state[component] = v;
      }
    });
  }

  Color$1.recalculateRGB = function (color, component, componentHexIndex) {
    if (color.__state.space === 'HEX') {
      color.__state[component] = ColorMath.component_from_hex(color.__state.hex, componentHexIndex);
    } else if (color.__state.space === 'HSV') {
      Common.extend(color.__state, ColorMath.hsv_to_rgb(color.__state.h, color.__state.s, color.__state.v));
    } else {
      throw new Error('Corrupted color state');
    }
  };

  Color$1.recalculateHSV = function (color) {
    var result = ColorMath.rgb_to_hsv(color.r, color.g, color.b);
    Common.extend(color.__state, {
      s: result.s,
      v: result.v
    });

    if (!Common.isNaN(result.h)) {
      color.__state.h = result.h;
    } else if (Common.isUndefined(color.__state.h)) {
      color.__state.h = 0;
    }
  };

  Color$1.COMPONENTS = ['r', 'g', 'b', 'h', 's', 'v', 'hex', 'a'];
  defineRGBComponent(Color$1.prototype, 'r', 2);
  defineRGBComponent(Color$1.prototype, 'g', 1);
  defineRGBComponent(Color$1.prototype, 'b', 0);
  defineHSVComponent(Color$1.prototype, 'h');
  defineHSVComponent(Color$1.prototype, 's');
  defineHSVComponent(Color$1.prototype, 'v');
  Object.defineProperty(Color$1.prototype, 'a', {
    get: function get$$1() {
      return this.__state.a;
    },
    set: function set$$1(v) {
      this.__state.a = v;
    }
  });
  Object.defineProperty(Color$1.prototype, 'hex', {
    get: function get$$1() {
      if (this.__state.space !== 'HEX') {
        this.__state.hex = ColorMath.rgb_to_hex(this.r, this.g, this.b);
        this.__state.space = 'HEX';
      }

      return this.__state.hex;
    },
    set: function set$$1(v) {
      this.__state.space = 'HEX';
      this.__state.hex = v;
    }
  });

  var Controller = function () {
    function Controller(object, property) {
      classCallCheck(this, Controller);
      this.initialValue = object[property];
      this.domElement = document.createElement('div');
      this.object = object;
      this.property = property;
      this.__onChange = undefined;
      this.__onFinishChange = undefined;
    }

    createClass(Controller, [{
      key: 'onChange',
      value: function onChange(fnc) {
        this.__onChange = fnc;
        return this;
      }
    }, {
      key: 'onFinishChange',
      value: function onFinishChange(fnc) {
        this.__onFinishChange = fnc;
        return this;
      }
    }, {
      key: 'setValue',
      value: function setValue(newValue) {
        this.object[this.property] = newValue;

        if (this.__onChange) {
          this.__onChange.call(this, newValue);
        }

        this.updateDisplay();
        return this;
      }
    }, {
      key: 'getValue',
      value: function getValue() {
        return this.object[this.property];
      }
    }, {
      key: 'updateDisplay',
      value: function updateDisplay() {
        return this;
      }
    }, {
      key: 'isModified',
      value: function isModified() {
        return this.initialValue !== this.getValue();
      }
    }]);
    return Controller;
  }();

  var EVENT_MAP = {
    HTMLEvents: ['change'],
    MouseEvents: ['click', 'mousemove', 'mousedown', 'mouseup', 'mouseover'],
    KeyboardEvents: ['keydown']
  };
  var EVENT_MAP_INV = {};
  Common.each(EVENT_MAP, function (v, k) {
    Common.each(v, function (e) {
      EVENT_MAP_INV[e] = k;
    });
  });
  var CSS_VALUE_PIXELS = /(\d+(\.\d+)?)px/;

  function cssValueToPixels(val) {
    if (val === '0' || Common.isUndefined(val)) {
      return 0;
    }

    var match = val.match(CSS_VALUE_PIXELS);

    if (!Common.isNull(match)) {
      return parseFloat(match[1]);
    }

    return 0;
  }

  var dom = {
    makeSelectable: function makeSelectable(elem, selectable) {
      if (elem === undefined || elem.style === undefined) return;
      elem.onselectstart = selectable ? function () {
        return false;
      } : function () {};
      elem.style.MozUserSelect = selectable ? 'auto' : 'none';
      elem.style.KhtmlUserSelect = selectable ? 'auto' : 'none';
      elem.unselectable = selectable ? 'on' : 'off';
    },
    makeFullscreen: function makeFullscreen(elem, hor, vert) {
      var vertical = vert;
      var horizontal = hor;

      if (Common.isUndefined(horizontal)) {
        horizontal = true;
      }

      if (Common.isUndefined(vertical)) {
        vertical = true;
      }

      elem.style.position = 'absolute';

      if (horizontal) {
        elem.style.left = 0;
        elem.style.right = 0;
      }

      if (vertical) {
        elem.style.top = 0;
        elem.style.bottom = 0;
      }
    },
    fakeEvent: function fakeEvent(elem, eventType, pars, aux) {
      var params = pars || {};
      var className = EVENT_MAP_INV[eventType];

      if (!className) {
        throw new Error('Event type ' + eventType + ' not supported.');
      }

      var evt = document.createEvent(className);

      switch (className) {
        case 'MouseEvents':
          {
            var clientX = params.x || params.clientX || 0;
            var clientY = params.y || params.clientY || 0;
            evt.initMouseEvent(eventType, params.bubbles || false, params.cancelable || true, window, params.clickCount || 1, 0, 0, clientX, clientY, false, false, false, false, 0, null);
            break;
          }

        case 'KeyboardEvents':
          {
            var init = evt.initKeyboardEvent || evt.initKeyEvent;
            Common.defaults(params, {
              cancelable: true,
              ctrlKey: false,
              altKey: false,
              shiftKey: false,
              metaKey: false,
              keyCode: undefined,
              charCode: undefined
            });
            init(eventType, params.bubbles || false, params.cancelable, window, params.ctrlKey, params.altKey, params.shiftKey, params.metaKey, params.keyCode, params.charCode);
            break;
          }

        default:
          {
            evt.initEvent(eventType, params.bubbles || false, params.cancelable || true);
            break;
          }
      }

      Common.defaults(evt, aux);
      elem.dispatchEvent(evt);
    },
    bind: function bind(elem, event, func, newBool) {
      var bool = newBool || false;

      if (elem.addEventListener) {
        elem.addEventListener(event, func, bool);
      } else if (elem.attachEvent) {
        elem.attachEvent('on' + event, func);
      }

      return dom;
    },
    unbind: function unbind(elem, event, func, newBool) {
      var bool = newBool || false;

      if (elem.removeEventListener) {
        elem.removeEventListener(event, func, bool);
      } else if (elem.detachEvent) {
        elem.detachEvent('on' + event, func);
      }

      return dom;
    },
    addClass: function addClass(elem, className) {
      if (elem.className === undefined) {
        elem.className = className;
      } else if (elem.className !== className) {
        var classes = elem.className.split(/ +/);

        if (classes.indexOf(className) === -1) {
          classes.push(className);
          elem.className = classes.join(' ').replace(/^\s+/, '').replace(/\s+$/, '');
        }
      }

      return dom;
    },
    removeClass: function removeClass(elem, className) {
      if (className) {
        if (elem.className === className) {
          elem.removeAttribute('class');
        } else {
          var classes = elem.className.split(/ +/);
          var index = classes.indexOf(className);

          if (index !== -1) {
            classes.splice(index, 1);
            elem.className = classes.join(' ');
          }
        }
      } else {
        elem.className = undefined;
      }

      return dom;
    },
    hasClass: function hasClass(elem, className) {
      return new RegExp('(?:^|\\s+)' + className + '(?:\\s+|$)').test(elem.className) || false;
    },
    getWidth: function getWidth(elem) {
      var style = getComputedStyle(elem);
      return cssValueToPixels(style['border-left-width']) + cssValueToPixels(style['border-right-width']) + cssValueToPixels(style['padding-left']) + cssValueToPixels(style['padding-right']) + cssValueToPixels(style.width);
    },
    getHeight: function getHeight(elem) {
      var style = getComputedStyle(elem);
      return cssValueToPixels(style['border-top-width']) + cssValueToPixels(style['border-bottom-width']) + cssValueToPixels(style['padding-top']) + cssValueToPixels(style['padding-bottom']) + cssValueToPixels(style.height);
    },
    getOffset: function getOffset(el) {
      var elem = el;
      var offset = {
        left: 0,
        top: 0
      };

      if (elem.offsetParent) {
        do {
          offset.left += elem.offsetLeft;
          offset.top += elem.offsetTop;
          elem = elem.offsetParent;
        } while (elem);
      }

      return offset;
    },
    isActive: function isActive(elem) {
      return elem === document.activeElement && (elem.type || elem.href);
    }
  };

  var BooleanController = function (_Controller) {
    inherits(BooleanController, _Controller);

    function BooleanController(object, property) {
      classCallCheck(this, BooleanController);

      var _this2 = possibleConstructorReturn(this, (BooleanController.__proto__ || Object.getPrototypeOf(BooleanController)).call(this, object, property));

      var _this = _this2;
      _this2.__prev = _this2.getValue();
      _this2.__checkbox = document.createElement('input');

      _this2.__checkbox.setAttribute('type', 'checkbox');

      function onChange() {
        _this.setValue(!_this.__prev);
      }

      dom.bind(_this2.__checkbox, 'change', onChange, false);

      _this2.domElement.appendChild(_this2.__checkbox);

      _this2.updateDisplay();

      return _this2;
    }

    createClass(BooleanController, [{
      key: 'setValue',
      value: function setValue(v) {
        var toReturn = get(BooleanController.prototype.__proto__ || Object.getPrototypeOf(BooleanController.prototype), 'setValue', this).call(this, v);

        if (this.__onFinishChange) {
          this.__onFinishChange.call(this, this.getValue());
        }

        this.__prev = this.getValue();
        return toReturn;
      }
    }, {
      key: 'updateDisplay',
      value: function updateDisplay() {
        if (this.getValue() === true) {
          this.__checkbox.setAttribute('checked', 'checked');

          this.__checkbox.checked = true;
          this.__prev = true;
        } else {
          this.__checkbox.checked = false;
          this.__prev = false;
        }

        return get(BooleanController.prototype.__proto__ || Object.getPrototypeOf(BooleanController.prototype), 'updateDisplay', this).call(this);
      }
    }]);
    return BooleanController;
  }(Controller);

  var OptionController = function (_Controller) {
    inherits(OptionController, _Controller);

    function OptionController(object, property, opts) {
      classCallCheck(this, OptionController);

      var _this2 = possibleConstructorReturn(this, (OptionController.__proto__ || Object.getPrototypeOf(OptionController)).call(this, object, property));

      var options = opts;
      var _this = _this2;
      _this2.__select = document.createElement('select');

      if (Common.isArray(options)) {
        var map = {};
        Common.each(options, function (element) {
          map[element] = element;
        });
        options = map;
      }

      Common.each(options, function (value, key) {
        var opt = document.createElement('option');
        opt.innerHTML = key;
        opt.setAttribute('value', value);

        _this.__select.appendChild(opt);
      });

      _this2.updateDisplay();

      dom.bind(_this2.__select, 'change', function () {
        var desiredValue = this.options[this.selectedIndex].value;

        _this.setValue(desiredValue);
      });

      _this2.domElement.appendChild(_this2.__select);

      return _this2;
    }

    createClass(OptionController, [{
      key: 'setValue',
      value: function setValue(v) {
        var toReturn = get(OptionController.prototype.__proto__ || Object.getPrototypeOf(OptionController.prototype), 'setValue', this).call(this, v);

        if (this.__onFinishChange) {
          this.__onFinishChange.call(this, this.getValue());
        }

        return toReturn;
      }
    }, {
      key: 'updateDisplay',
      value: function updateDisplay() {
        if (dom.isActive(this.__select)) return this;
        this.__select.value = this.getValue();
        return get(OptionController.prototype.__proto__ || Object.getPrototypeOf(OptionController.prototype), 'updateDisplay', this).call(this);
      }
    }]);
    return OptionController;
  }(Controller);

  var StringController = function (_Controller) {
    inherits(StringController, _Controller);

    function StringController(object, property) {
      classCallCheck(this, StringController);

      var _this2 = possibleConstructorReturn(this, (StringController.__proto__ || Object.getPrototypeOf(StringController)).call(this, object, property));

      var _this = _this2;

      function onChange() {
        _this.setValue(_this.__input.value);
      }

      function onBlur() {
        if (_this.__onFinishChange) {
          _this.__onFinishChange.call(_this, _this.getValue());
        }
      }

      _this2.__input = document.createElement('input');

      _this2.__input.setAttribute('type', 'text');

      dom.bind(_this2.__input, 'keyup', onChange);
      dom.bind(_this2.__input, 'change', onChange);
      dom.bind(_this2.__input, 'blur', onBlur);
      dom.bind(_this2.__input, 'keydown', function (e) {
        if (e.keyCode === 13) {
          this.blur();
        }
      });

      _this2.updateDisplay();

      _this2.domElement.appendChild(_this2.__input);

      return _this2;
    }

    createClass(StringController, [{
      key: 'updateDisplay',
      value: function updateDisplay() {
        if (!dom.isActive(this.__input)) {
          this.__input.value = this.getValue();
        }

        return get(StringController.prototype.__proto__ || Object.getPrototypeOf(StringController.prototype), 'updateDisplay', this).call(this);
      }
    }]);
    return StringController;
  }(Controller);

  function numDecimals(x) {
    var _x = x.toString();

    if (_x.indexOf('.') > -1) {
      return _x.length - _x.indexOf('.') - 1;
    }

    return 0;
  }

  var NumberController = function (_Controller) {
    inherits(NumberController, _Controller);

    function NumberController(object, property, params) {
      classCallCheck(this, NumberController);

      var _this = possibleConstructorReturn(this, (NumberController.__proto__ || Object.getPrototypeOf(NumberController)).call(this, object, property));

      var _params = params || {};

      _this.__min = _params.min;
      _this.__max = _params.max;
      _this.__step = _params.step;

      if (Common.isUndefined(_this.__step)) {
        if (_this.initialValue === 0) {
          _this.__impliedStep = 1;
        } else {
          _this.__impliedStep = Math.pow(10, Math.floor(Math.log(Math.abs(_this.initialValue)) / Math.LN10)) / 10;
        }
      } else {
        _this.__impliedStep = _this.__step;
      }

      _this.__precision = numDecimals(_this.__impliedStep);
      return _this;
    }

    createClass(NumberController, [{
      key: 'setValue',
      value: function setValue(v) {
        var _v = v;

        if (this.__min !== undefined && _v < this.__min) {
          _v = this.__min;
        } else if (this.__max !== undefined && _v > this.__max) {
          _v = this.__max;
        }

        if (this.__step !== undefined && _v % this.__step !== 0) {
          _v = Math.round(_v / this.__step) * this.__step;
        }

        return get(NumberController.prototype.__proto__ || Object.getPrototypeOf(NumberController.prototype), 'setValue', this).call(this, _v);
      }
    }, {
      key: 'min',
      value: function min(minValue) {
        this.__min = minValue;
        return this;
      }
    }, {
      key: 'max',
      value: function max(maxValue) {
        this.__max = maxValue;
        return this;
      }
    }, {
      key: 'step',
      value: function step(stepValue) {
        this.__step = stepValue;
        this.__impliedStep = stepValue;
        this.__precision = numDecimals(stepValue);
        return this;
      }
    }]);
    return NumberController;
  }(Controller);

  function roundToDecimal(value, decimals) {
    var tenTo = Math.pow(10, decimals);
    return Math.round(value * tenTo) / tenTo;
  }

  var NumberControllerBox = function (_NumberController) {
    inherits(NumberControllerBox, _NumberController);

    function NumberControllerBox(object, property, params) {
      classCallCheck(this, NumberControllerBox);

      var _this2 = possibleConstructorReturn(this, (NumberControllerBox.__proto__ || Object.getPrototypeOf(NumberControllerBox)).call(this, object, property, params));

      _this2.__truncationSuspended = false;
      var _this = _this2;
      var prevY = void 0;

      function onChange() {
        var attempted = parseFloat(_this.__input.value);

        if (!Common.isNaN(attempted)) {
          _this.setValue(attempted);
        }
      }

      function onFinish() {
        if (_this.__onFinishChange) {
          _this.__onFinishChange.call(_this, _this.getValue());
        }
      }

      function onBlur() {
        onFinish();
      }

      function onMouseDrag(e) {
        var diff = prevY - e.clientY;

        _this.setValue(_this.getValue() + diff * _this.__impliedStep);

        prevY = e.clientY;
      }

      function onMouseUp() {
        dom.unbind(window, 'mousemove', onMouseDrag);
        dom.unbind(window, 'mouseup', onMouseUp);
        onFinish();
      }

      function onMouseDown(e) {
        dom.bind(window, 'mousemove', onMouseDrag);
        dom.bind(window, 'mouseup', onMouseUp);
        prevY = e.clientY;
      }

      _this2.__input = document.createElement('input');

      _this2.__input.setAttribute('type', 'text');

      dom.bind(_this2.__input, 'change', onChange);
      dom.bind(_this2.__input, 'blur', onBlur);
      dom.bind(_this2.__input, 'mousedown', onMouseDown);
      dom.bind(_this2.__input, 'keydown', function (e) {
        if (e.keyCode === 13) {
          _this.__truncationSuspended = true;
          this.blur();
          _this.__truncationSuspended = false;
          onFinish();
        }
      });

      _this2.updateDisplay();

      _this2.domElement.appendChild(_this2.__input);

      return _this2;
    }

    createClass(NumberControllerBox, [{
      key: 'updateDisplay',
      value: function updateDisplay() {
        this.__input.value = this.__truncationSuspended ? this.getValue() : roundToDecimal(this.getValue(), this.__precision);
        return get(NumberControllerBox.prototype.__proto__ || Object.getPrototypeOf(NumberControllerBox.prototype), 'updateDisplay', this).call(this);
      }
    }]);
    return NumberControllerBox;
  }(NumberController);

  function map(v, i1, i2, o1, o2) {
    return o1 + (o2 - o1) * ((v - i1) / (i2 - i1));
  }

  var NumberControllerSlider = function (_NumberController) {
    inherits(NumberControllerSlider, _NumberController);

    function NumberControllerSlider(object, property, min, max, step) {
      classCallCheck(this, NumberControllerSlider);

      var _this2 = possibleConstructorReturn(this, (NumberControllerSlider.__proto__ || Object.getPrototypeOf(NumberControllerSlider)).call(this, object, property, {
        min: min,
        max: max,
        step: step
      }));

      var _this = _this2;
      _this2.__background = document.createElement('div');
      _this2.__foreground = document.createElement('div');
      dom.bind(_this2.__background, 'mousedown', onMouseDown);
      dom.bind(_this2.__background, 'touchstart', onTouchStart);
      dom.addClass(_this2.__background, 'slider');
      dom.addClass(_this2.__foreground, 'slider-fg');

      function onMouseDown(e) {
        document.activeElement.blur();
        dom.bind(window, 'mousemove', onMouseDrag);
        dom.bind(window, 'mouseup', onMouseUp);
        onMouseDrag(e);
      }

      function onMouseDrag(e) {
        e.preventDefault();

        var bgRect = _this.__background.getBoundingClientRect();

        _this.setValue(map(e.clientX, bgRect.left, bgRect.right, _this.__min, _this.__max));

        return false;
      }

      function onMouseUp() {
        dom.unbind(window, 'mousemove', onMouseDrag);
        dom.unbind(window, 'mouseup', onMouseUp);

        if (_this.__onFinishChange) {
          _this.__onFinishChange.call(_this, _this.getValue());
        }
      }

      function onTouchStart(e) {
        if (e.touches.length !== 1) {
          return;
        }

        dom.bind(window, 'touchmove', onTouchMove);
        dom.bind(window, 'touchend', onTouchEnd);
        onTouchMove(e);
      }

      function onTouchMove(e) {
        var clientX = e.touches[0].clientX;

        var bgRect = _this.__background.getBoundingClientRect();

        _this.setValue(map(clientX, bgRect.left, bgRect.right, _this.__min, _this.__max));
      }

      function onTouchEnd() {
        dom.unbind(window, 'touchmove', onTouchMove);
        dom.unbind(window, 'touchend', onTouchEnd);

        if (_this.__onFinishChange) {
          _this.__onFinishChange.call(_this, _this.getValue());
        }
      }

      _this2.updateDisplay();

      _this2.__background.appendChild(_this2.__foreground);

      _this2.domElement.appendChild(_this2.__background);

      return _this2;
    }

    createClass(NumberControllerSlider, [{
      key: 'updateDisplay',
      value: function updateDisplay() {
        var pct = (this.getValue() - this.__min) / (this.__max - this.__min);

        this.__foreground.style.width = pct * 100 + '%';
        return get(NumberControllerSlider.prototype.__proto__ || Object.getPrototypeOf(NumberControllerSlider.prototype), 'updateDisplay', this).call(this);
      }
    }]);
    return NumberControllerSlider;
  }(NumberController);

  var FunctionController = function (_Controller) {
    inherits(FunctionController, _Controller);

    function FunctionController(object, property, text) {
      classCallCheck(this, FunctionController);

      var _this2 = possibleConstructorReturn(this, (FunctionController.__proto__ || Object.getPrototypeOf(FunctionController)).call(this, object, property));

      var _this = _this2;
      _this2.__button = document.createElement('div');
      _this2.__button.innerHTML = text === undefined ? 'Fire' : text;
      dom.bind(_this2.__button, 'click', function (e) {
        e.preventDefault();

        _this.fire();

        return false;
      });
      dom.addClass(_this2.__button, 'button');

      _this2.domElement.appendChild(_this2.__button);

      return _this2;
    }

    createClass(FunctionController, [{
      key: 'fire',
      value: function fire() {
        if (this.__onChange) {
          this.__onChange.call(this);
        }

        this.getValue().call(this.object);

        if (this.__onFinishChange) {
          this.__onFinishChange.call(this, this.getValue());
        }
      }
    }]);
    return FunctionController;
  }(Controller);

  var ColorController = function (_Controller) {
    inherits(ColorController, _Controller);

    function ColorController(object, property) {
      classCallCheck(this, ColorController);

      var _this2 = possibleConstructorReturn(this, (ColorController.__proto__ || Object.getPrototypeOf(ColorController)).call(this, object, property));

      _this2.__color = new Color$1(_this2.getValue());
      _this2.__temp = new Color$1(0);
      var _this = _this2;
      _this2.domElement = document.createElement('div');
      dom.makeSelectable(_this2.domElement, false);
      _this2.__selector = document.createElement('div');
      _this2.__selector.className = 'selector';
      _this2.__saturation_field = document.createElement('div');
      _this2.__saturation_field.className = 'saturation-field';
      _this2.__field_knob = document.createElement('div');
      _this2.__field_knob.className = 'field-knob';
      _this2.__field_knob_border = '2px solid ';
      _this2.__hue_knob = document.createElement('div');
      _this2.__hue_knob.className = 'hue-knob';
      _this2.__hue_field = document.createElement('div');
      _this2.__hue_field.className = 'hue-field';
      _this2.__input = document.createElement('input');
      _this2.__input.type = 'text';
      _this2.__input_textShadow = '0 1px 1px ';
      dom.bind(_this2.__input, 'keydown', function (e) {
        if (e.keyCode === 13) {
          onBlur.call(this);
        }
      });
      dom.bind(_this2.__input, 'blur', onBlur);
      dom.bind(_this2.__selector, 'mousedown', function () {
        dom.addClass(this, 'drag').bind(window, 'mouseup', function () {
          dom.removeClass(_this.__selector, 'drag');
        });
      });
      dom.bind(_this2.__selector, 'touchstart', function () {
        dom.addClass(this, 'drag').bind(window, 'touchend', function () {
          dom.removeClass(_this.__selector, 'drag');
        });
      });
      var valueField = document.createElement('div');
      Common.extend(_this2.__selector.style, {
        width: '122px',
        height: '102px',
        padding: '3px',
        backgroundColor: '#222',
        boxShadow: '0px 1px 3px rgba(0,0,0,0.3)'
      });
      Common.extend(_this2.__field_knob.style, {
        position: 'absolute',
        width: '12px',
        height: '12px',
        border: _this2.__field_knob_border + (_this2.__color.v < 0.5 ? '#fff' : '#000'),
        boxShadow: '0px 1px 3px rgba(0,0,0,0.5)',
        borderRadius: '12px',
        zIndex: 1
      });
      Common.extend(_this2.__hue_knob.style, {
        position: 'absolute',
        width: '15px',
        height: '2px',
        borderRight: '4px solid #fff',
        zIndex: 1
      });
      Common.extend(_this2.__saturation_field.style, {
        width: '100px',
        height: '100px',
        border: '1px solid #555',
        marginRight: '3px',
        display: 'inline-block',
        cursor: 'pointer'
      });
      Common.extend(valueField.style, {
        width: '100%',
        height: '100%',
        background: 'none'
      });
      linearGradient(valueField, 'top', 'rgba(0,0,0,0)', '#000');
      Common.extend(_this2.__hue_field.style, {
        width: '15px',
        height: '100px',
        border: '1px solid #555',
        cursor: 'ns-resize',
        position: 'absolute',
        top: '3px',
        right: '3px'
      });
      hueGradient(_this2.__hue_field);
      Common.extend(_this2.__input.style, {
        outline: 'none',
        textAlign: 'center',
        color: '#fff',
        border: 0,
        fontWeight: 'bold',
        textShadow: _this2.__input_textShadow + 'rgba(0,0,0,0.7)'
      });
      dom.bind(_this2.__saturation_field, 'mousedown', fieldDown);
      dom.bind(_this2.__saturation_field, 'touchstart', fieldDown);
      dom.bind(_this2.__field_knob, 'mousedown', fieldDown);
      dom.bind(_this2.__field_knob, 'touchstart', fieldDown);
      dom.bind(_this2.__hue_field, 'mousedown', fieldDownH);
      dom.bind(_this2.__hue_field, 'touchstart', fieldDownH);

      function fieldDown(e) {
        setSV(e);
        dom.bind(window, 'mousemove', setSV);
        dom.bind(window, 'touchmove', setSV);
        dom.bind(window, 'mouseup', fieldUpSV);
        dom.bind(window, 'touchend', fieldUpSV);
      }

      function fieldDownH(e) {
        setH(e);
        dom.bind(window, 'mousemove', setH);
        dom.bind(window, 'touchmove', setH);
        dom.bind(window, 'mouseup', fieldUpH);
        dom.bind(window, 'touchend', fieldUpH);
      }

      function fieldUpSV() {
        dom.unbind(window, 'mousemove', setSV);
        dom.unbind(window, 'touchmove', setSV);
        dom.unbind(window, 'mouseup', fieldUpSV);
        dom.unbind(window, 'touchend', fieldUpSV);
        onFinish();
      }

      function fieldUpH() {
        dom.unbind(window, 'mousemove', setH);
        dom.unbind(window, 'touchmove', setH);
        dom.unbind(window, 'mouseup', fieldUpH);
        dom.unbind(window, 'touchend', fieldUpH);
        onFinish();
      }

      function onBlur() {
        var i = interpret(this.value);

        if (i !== false) {
          _this.__color.__state = i;

          _this.setValue(_this.__color.toOriginal());
        } else {
          this.value = _this.__color.toString();
        }
      }

      function onFinish() {
        if (_this.__onFinishChange) {
          _this.__onFinishChange.call(_this, _this.__color.toOriginal());
        }
      }

      _this2.__saturation_field.appendChild(valueField);

      _this2.__selector.appendChild(_this2.__field_knob);

      _this2.__selector.appendChild(_this2.__saturation_field);

      _this2.__selector.appendChild(_this2.__hue_field);

      _this2.__hue_field.appendChild(_this2.__hue_knob);

      _this2.domElement.appendChild(_this2.__input);

      _this2.domElement.appendChild(_this2.__selector);

      _this2.updateDisplay();

      function setSV(e) {
        if (e.type.indexOf('touch') === -1) {
          e.preventDefault();
        }

        var fieldRect = _this.__saturation_field.getBoundingClientRect();

        var _ref = e.touches && e.touches[0] || e,
            clientX = _ref.clientX,
            clientY = _ref.clientY;

        var s = (clientX - fieldRect.left) / (fieldRect.right - fieldRect.left);
        var v = 1 - (clientY - fieldRect.top) / (fieldRect.bottom - fieldRect.top);

        if (v > 1) {
          v = 1;
        } else if (v < 0) {
          v = 0;
        }

        if (s > 1) {
          s = 1;
        } else if (s < 0) {
          s = 0;
        }

        _this.__color.v = v;
        _this.__color.s = s;

        _this.setValue(_this.__color.toOriginal());

        return false;
      }

      function setH(e) {
        if (e.type.indexOf('touch') === -1) {
          e.preventDefault();
        }

        var fieldRect = _this.__hue_field.getBoundingClientRect();

        var _ref2 = e.touches && e.touches[0] || e,
            clientY = _ref2.clientY;

        var h = 1 - (clientY - fieldRect.top) / (fieldRect.bottom - fieldRect.top);

        if (h > 1) {
          h = 1;
        } else if (h < 0) {
          h = 0;
        }

        _this.__color.h = h * 360;

        _this.setValue(_this.__color.toOriginal());

        return false;
      }

      return _this2;
    }

    createClass(ColorController, [{
      key: 'updateDisplay',
      value: function updateDisplay() {
        var i = interpret(this.getValue());

        if (i !== false) {
          var mismatch = false;
          Common.each(Color$1.COMPONENTS, function (component) {
            if (!Common.isUndefined(i[component]) && !Common.isUndefined(this.__color.__state[component]) && i[component] !== this.__color.__state[component]) {
              mismatch = true;
              return {};
            }
          }, this);

          if (mismatch) {
            Common.extend(this.__color.__state, i);
          }
        }

        Common.extend(this.__temp.__state, this.__color.__state);
        this.__temp.a = 1;
        var flip = this.__color.v < 0.5 || this.__color.s > 0.5 ? 255 : 0;

        var _flip = 255 - flip;

        Common.extend(this.__field_knob.style, {
          marginLeft: 100 * this.__color.s - 7 + 'px',
          marginTop: 100 * (1 - this.__color.v) - 7 + 'px',
          backgroundColor: this.__temp.toHexString(),
          border: this.__field_knob_border + 'rgb(' + flip + ',' + flip + ',' + flip + ')'
        });
        this.__hue_knob.style.marginTop = (1 - this.__color.h / 360) * 100 + 'px';
        this.__temp.s = 1;
        this.__temp.v = 1;
        linearGradient(this.__saturation_field, 'left', '#fff', this.__temp.toHexString());
        this.__input.value = this.__color.toString();
        Common.extend(this.__input.style, {
          backgroundColor: this.__color.toHexString(),
          color: 'rgb(' + flip + ',' + flip + ',' + flip + ')',
          textShadow: this.__input_textShadow + 'rgba(' + _flip + ',' + _flip + ',' + _flip + ',.7)'
        });
      }
    }]);
    return ColorController;
  }(Controller);

  var vendors = ['-moz-', '-o-', '-webkit-', '-ms-', ''];

  function linearGradient(elem, x, a, b) {
    elem.style.background = '';
    Common.each(vendors, function (vendor) {
      elem.style.cssText += 'background: ' + vendor + 'linear-gradient(' + x + ', ' + a + ' 0%, ' + b + ' 100%); ';
    });
  }

  function hueGradient(elem) {
    elem.style.background = '';
    elem.style.cssText += 'background: -moz-linear-gradient(top,  #ff0000 0%, #ff00ff 17%, #0000ff 34%, #00ffff 50%, #00ff00 67%, #ffff00 84%, #ff0000 100%);';
    elem.style.cssText += 'background: -webkit-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);';
    elem.style.cssText += 'background: -o-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);';
    elem.style.cssText += 'background: -ms-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);';
    elem.style.cssText += 'background: linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);';
  }

  var css = {
    load: function load(url, indoc) {
      var doc = indoc || document;
      var link = doc.createElement('link');
      link.type = 'text/css';
      link.rel = 'stylesheet';
      link.href = url;
      doc.getElementsByTagName('head')[0].appendChild(link);
    },
    inject: function inject(cssContent, indoc) {
      var doc = indoc || document;
      var injected = document.createElement('style');
      injected.type = 'text/css';
      injected.innerHTML = cssContent;
      var head = doc.getElementsByTagName('head')[0];

      try {
        head.appendChild(injected);
      } catch (e) {}
    }
  };
  var saveDialogContents = "<div id=\"dg-save\" class=\"dg dialogue\">\n\n  Here's the new load parameter for your <code>GUI</code>'s constructor:\n\n  <textarea id=\"dg-new-constructor\"></textarea>\n\n  <div id=\"dg-save-locally\">\n\n    <input id=\"dg-local-storage\" type=\"checkbox\"/> Automatically save\n    values to <code>localStorage</code> on exit.\n\n    <div id=\"dg-local-explain\">The values saved to <code>localStorage</code> will\n      override those passed to <code>dat.GUI</code>'s constructor. This makes it\n      easier to work incrementally, but <code>localStorage</code> is fragile,\n      and your friends may not see the same values you do.\n\n    </div>\n\n  </div>\n\n</div>";

  var ControllerFactory = function ControllerFactory(object, property) {
    var initialValue = object[property];

    if (Common.isArray(arguments[2]) || Common.isObject(arguments[2])) {
      return new OptionController(object, property, arguments[2]);
    }

    if (Common.isNumber(initialValue)) {
      if (Common.isNumber(arguments[2]) && Common.isNumber(arguments[3])) {
        if (Common.isNumber(arguments[4])) {
          return new NumberControllerSlider(object, property, arguments[2], arguments[3], arguments[4]);
        }

        return new NumberControllerSlider(object, property, arguments[2], arguments[3]);
      }

      if (Common.isNumber(arguments[4])) {
        return new NumberControllerBox(object, property, {
          min: arguments[2],
          max: arguments[3],
          step: arguments[4]
        });
      }

      return new NumberControllerBox(object, property, {
        min: arguments[2],
        max: arguments[3]
      });
    }

    if (Common.isString(initialValue)) {
      return new StringController(object, property);
    }

    if (Common.isFunction(initialValue)) {
      return new FunctionController(object, property, '');
    }

    if (Common.isBoolean(initialValue)) {
      return new BooleanController(object, property);
    }

    return null;
  };

  function requestAnimationFrame$1(callback) {
    setTimeout(callback, 1000 / 60);
  }

  var requestAnimationFrame$1$1 = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || requestAnimationFrame$1;

  var CenteredDiv = function () {
    function CenteredDiv() {
      classCallCheck(this, CenteredDiv);
      this.backgroundElement = document.createElement('div');
      Common.extend(this.backgroundElement.style, {
        backgroundColor: 'rgba(0,0,0,0.8)',
        top: 0,
        left: 0,
        display: 'none',
        zIndex: '1000',
        opacity: 0,
        WebkitTransition: 'opacity 0.2s linear',
        transition: 'opacity 0.2s linear'
      });
      dom.makeFullscreen(this.backgroundElement);
      this.backgroundElement.style.position = 'fixed';
      this.domElement = document.createElement('div');
      Common.extend(this.domElement.style, {
        position: 'fixed',
        display: 'none',
        zIndex: '1001',
        opacity: 0,
        WebkitTransition: '-webkit-transform 0.2s ease-out, opacity 0.2s linear',
        transition: 'transform 0.2s ease-out, opacity 0.2s linear'
      });
      document.body.appendChild(this.backgroundElement);
      document.body.appendChild(this.domElement);

      var _this = this;

      dom.bind(this.backgroundElement, 'click', function () {
        _this.hide();
      });
    }

    createClass(CenteredDiv, [{
      key: 'show',
      value: function show() {
        var _this = this;

        this.backgroundElement.style.display = 'block';
        this.domElement.style.display = 'block';
        this.domElement.style.opacity = 0;
        this.domElement.style.webkitTransform = 'scale(1.1)';
        this.layout();
        Common.defer(function () {
          _this.backgroundElement.style.opacity = 1;
          _this.domElement.style.opacity = 1;
          _this.domElement.style.webkitTransform = 'scale(1)';
        });
      }
    }, {
      key: 'hide',
      value: function hide() {
        var _this = this;

        var hide = function hide() {
          _this.domElement.style.display = 'none';
          _this.backgroundElement.style.display = 'none';
          dom.unbind(_this.domElement, 'webkitTransitionEnd', hide);
          dom.unbind(_this.domElement, 'transitionend', hide);
          dom.unbind(_this.domElement, 'oTransitionEnd', hide);
        };

        dom.bind(this.domElement, 'webkitTransitionEnd', hide);
        dom.bind(this.domElement, 'transitionend', hide);
        dom.bind(this.domElement, 'oTransitionEnd', hide);
        this.backgroundElement.style.opacity = 0;
        this.domElement.style.opacity = 0;
        this.domElement.style.webkitTransform = 'scale(1.1)';
      }
    }, {
      key: 'layout',
      value: function layout() {
        this.domElement.style.left = window.innerWidth / 2 - dom.getWidth(this.domElement) / 2 + 'px';
        this.domElement.style.top = window.innerHeight / 2 - dom.getHeight(this.domElement) / 2 + 'px';
      }
    }]);
    return CenteredDiv;
  }();

  var styleSheet = ___$insertStyle(".dg ul{list-style:none;margin:0;padding:0;width:100%;clear:both}.dg.ac{position:fixed;top:0;left:0;right:0;height:0;z-index:0}.dg:not(.ac) .main{overflow:hidden}.dg.main{-webkit-transition:opacity .1s linear;-o-transition:opacity .1s linear;-moz-transition:opacity .1s linear;transition:opacity .1s linear}.dg.main.taller-than-window{overflow-y:auto}.dg.main.taller-than-window .close-button{opacity:1;margin-top:-1px;border-top:1px solid #2c2c2c}.dg.main ul.closed .close-button{opacity:1 !important}.dg.main:hover .close-button,.dg.main .close-button.drag{opacity:1}.dg.main .close-button{-webkit-transition:opacity .1s linear;-o-transition:opacity .1s linear;-moz-transition:opacity .1s linear;transition:opacity .1s linear;border:0;line-height:19px;height:20px;cursor:pointer;text-align:center;background-color:#000}.dg.main .close-button.close-top{position:relative}.dg.main .close-button.close-bottom{position:absolute}.dg.main .close-button:hover{background-color:#111}.dg.a{float:right;margin-right:15px;overflow-y:visible}.dg.a.has-save>ul.close-top{margin-top:0}.dg.a.has-save>ul.close-bottom{margin-top:27px}.dg.a.has-save>ul.closed{margin-top:0}.dg.a .save-row{top:0;z-index:1002}.dg.a .save-row.close-top{position:relative}.dg.a .save-row.close-bottom{position:fixed}.dg li{-webkit-transition:height .1s ease-out;-o-transition:height .1s ease-out;-moz-transition:height .1s ease-out;transition:height .1s ease-out;-webkit-transition:overflow .1s linear;-o-transition:overflow .1s linear;-moz-transition:overflow .1s linear;transition:overflow .1s linear}.dg li:not(.folder){cursor:auto;height:27px;line-height:27px;padding:0 4px 0 5px}.dg li.folder{padding:0;border-left:4px solid rgba(0,0,0,0)}.dg li.title{cursor:pointer;margin-left:-4px}.dg .closed li:not(.title),.dg .closed ul li,.dg .closed ul li>*{height:0;overflow:hidden;border:0}.dg .cr{clear:both;padding-left:3px;height:27px;overflow:hidden}.dg .property-name{cursor:default;float:left;clear:left;width:40%;overflow:hidden;text-overflow:ellipsis}.dg .c{float:left;width:60%;position:relative}.dg .c input[type=text]{border:0;margin-top:4px;padding:3px;width:100%;float:right}.dg .has-slider input[type=text]{width:30%;margin-left:0}.dg .slider{float:left;width:66%;margin-left:-5px;margin-right:0;height:19px;margin-top:4px}.dg .slider-fg{height:100%}.dg .c input[type=checkbox]{margin-top:7px}.dg .c select{margin-top:5px}.dg .cr.function,.dg .cr.function .property-name,.dg .cr.function *,.dg .cr.boolean,.dg .cr.boolean *{cursor:pointer}.dg .cr.color{overflow:visible}.dg .selector{display:none;position:absolute;margin-left:-9px;margin-top:23px;z-index:10}.dg .c:hover .selector,.dg .selector.drag{display:block}.dg li.save-row{padding:0}.dg li.save-row .button{display:inline-block;padding:0px 6px}.dg.dialogue{background-color:#222;width:460px;padding:15px;font-size:13px;line-height:15px}#dg-new-constructor{padding:10px;color:#222;font-family:Monaco, monospace;font-size:10px;border:0;resize:none;box-shadow:inset 1px 1px 1px #888;word-wrap:break-word;margin:12px 0;display:block;width:440px;overflow-y:scroll;height:100px;position:relative}#dg-local-explain{display:none;font-size:11px;line-height:17px;border-radius:3px;background-color:#333;padding:8px;margin-top:10px}#dg-local-explain code{font-size:10px}#dat-gui-save-locally{display:none}.dg{color:#eee;font:11px 'Lucida Grande', sans-serif;text-shadow:0 -1px 0 #111}.dg.main::-webkit-scrollbar{width:5px;background:#1a1a1a}.dg.main::-webkit-scrollbar-corner{height:0;display:none}.dg.main::-webkit-scrollbar-thumb{border-radius:5px;background:#676767}.dg li:not(.folder){background:#1a1a1a;border-bottom:1px solid #2c2c2c}.dg li.save-row{line-height:25px;background:#dad5cb;border:0}.dg li.save-row select{margin-left:5px;width:108px}.dg li.save-row .button{margin-left:5px;margin-top:1px;border-radius:2px;font-size:9px;line-height:7px;padding:4px 4px 5px 4px;background:#c5bdad;color:#fff;text-shadow:0 1px 0 #b0a58f;box-shadow:0 -1px 0 #b0a58f;cursor:pointer}.dg li.save-row .button.gears{background:#c5bdad url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAANCAYAAAB/9ZQ7AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAQJJREFUeNpiYKAU/P//PwGIC/ApCABiBSAW+I8AClAcgKxQ4T9hoMAEUrxx2QSGN6+egDX+/vWT4e7N82AMYoPAx/evwWoYoSYbACX2s7KxCxzcsezDh3evFoDEBYTEEqycggWAzA9AuUSQQgeYPa9fPv6/YWm/Acx5IPb7ty/fw+QZblw67vDs8R0YHyQhgObx+yAJkBqmG5dPPDh1aPOGR/eugW0G4vlIoTIfyFcA+QekhhHJhPdQxbiAIguMBTQZrPD7108M6roWYDFQiIAAv6Aow/1bFwXgis+f2LUAynwoIaNcz8XNx3Dl7MEJUDGQpx9gtQ8YCueB+D26OECAAQDadt7e46D42QAAAABJRU5ErkJggg==) 2px 1px no-repeat;height:7px;width:8px}.dg li.save-row .button:hover{background-color:#bab19e;box-shadow:0 -1px 0 #b0a58f}.dg li.folder{border-bottom:0}.dg li.title{padding-left:16px;background:#000 url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlI+hKgFxoCgAOw==) 6px 10px no-repeat;cursor:pointer;border-bottom:1px solid rgba(255,255,255,0.2)}.dg .closed li.title{background-image:url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlGIWqMCbWAEAOw==)}.dg .cr.boolean{border-left:3px solid #806787}.dg .cr.color{border-left:3px solid}.dg .cr.function{border-left:3px solid #e61d5f}.dg .cr.number{border-left:3px solid #2FA1D6}.dg .cr.number input[type=text]{color:#2FA1D6}.dg .cr.string{border-left:3px solid #1ed36f}.dg .cr.string input[type=text]{color:#1ed36f}.dg .cr.function:hover,.dg .cr.boolean:hover{background:#111}.dg .c input[type=text]{background:#303030;outline:none}.dg .c input[type=text]:hover{background:#3c3c3c}.dg .c input[type=text]:focus{background:#494949;color:#fff}.dg .c .slider{background:#303030;cursor:ew-resize}.dg .c .slider-fg{background:#2FA1D6;max-width:100%}.dg .c .slider:hover{background:#3c3c3c}.dg .c .slider:hover .slider-fg{background:#44abda}\n");

  css.inject(styleSheet);
  var CSS_NAMESPACE = 'dg';
  var HIDE_KEY_CODE = 72;
  var CLOSE_BUTTON_HEIGHT = 20;
  var DEFAULT_DEFAULT_PRESET_NAME = 'Default';

  var SUPPORTS_LOCAL_STORAGE = function () {
    try {
      return !!window.localStorage;
    } catch (e) {
      return false;
    }
  }();

  var SAVE_DIALOGUE = void 0;
  var autoPlaceVirgin = true;
  var autoPlaceContainer = void 0;
  var hide = false;
  var hideableGuis = [];

  var GUI = function GUI(pars) {
    var _this = this;

    var params = pars || {};
    this.domElement = document.createElement('div');
    this.__ul = document.createElement('ul');
    this.domElement.appendChild(this.__ul);
    dom.addClass(this.domElement, CSS_NAMESPACE);
    this.__folders = {};
    this.__controllers = [];
    this.__rememberedObjects = [];
    this.__rememberedObjectIndecesToControllers = [];
    this.__listening = [];
    params = Common.defaults(params, {
      closeOnTop: false,
      autoPlace: true,
      width: GUI.DEFAULT_WIDTH
    });
    params = Common.defaults(params, {
      resizable: params.autoPlace,
      hideable: params.autoPlace
    });

    if (!Common.isUndefined(params.load)) {
      if (params.preset) {
        params.load.preset = params.preset;
      }
    } else {
      params.load = {
        preset: DEFAULT_DEFAULT_PRESET_NAME
      };
    }

    if (Common.isUndefined(params.parent) && params.hideable) {
      hideableGuis.push(this);
    }

    params.resizable = Common.isUndefined(params.parent) && params.resizable;

    if (params.autoPlace && Common.isUndefined(params.scrollable)) {
      params.scrollable = true;
    }

    var useLocalStorage = SUPPORTS_LOCAL_STORAGE && localStorage.getItem(getLocalStorageHash(this, 'isLocal')) === 'true';
    var saveToLocalStorage = void 0;
    var titleRow = void 0;
    Object.defineProperties(this, {
      parent: {
        get: function get$$1() {
          return params.parent;
        }
      },
      scrollable: {
        get: function get$$1() {
          return params.scrollable;
        }
      },
      autoPlace: {
        get: function get$$1() {
          return params.autoPlace;
        }
      },
      closeOnTop: {
        get: function get$$1() {
          return params.closeOnTop;
        }
      },
      preset: {
        get: function get$$1() {
          if (_this.parent) {
            return _this.getRoot().preset;
          }

          return params.load.preset;
        },
        set: function set$$1(v) {
          if (_this.parent) {
            _this.getRoot().preset = v;
          } else {
            params.load.preset = v;
          }

          setPresetSelectIndex(this);

          _this.revert();
        }
      },
      width: {
        get: function get$$1() {
          return params.width;
        },
        set: function set$$1(v) {
          params.width = v;
          setWidth(_this, v);
        }
      },
      name: {
        get: function get$$1() {
          return params.name;
        },
        set: function set$$1(v) {
          params.name = v;

          if (titleRow) {
            titleRow.innerHTML = params.name;
          }
        }
      },
      closed: {
        get: function get$$1() {
          return params.closed;
        },
        set: function set$$1(v) {
          params.closed = v;

          if (params.closed) {
            dom.addClass(_this.__ul, GUI.CLASS_CLOSED);
          } else {
            dom.removeClass(_this.__ul, GUI.CLASS_CLOSED);
          }

          this.onResize();

          if (_this.__closeButton) {
            _this.__closeButton.innerHTML = v ? GUI.TEXT_OPEN : GUI.TEXT_CLOSED;
          }
        }
      },
      load: {
        get: function get$$1() {
          return params.load;
        }
      },
      useLocalStorage: {
        get: function get$$1() {
          return useLocalStorage;
        },
        set: function set$$1(bool) {
          if (SUPPORTS_LOCAL_STORAGE) {
            useLocalStorage = bool;

            if (bool) {
              dom.bind(window, 'unload', saveToLocalStorage);
            } else {
              dom.unbind(window, 'unload', saveToLocalStorage);
            }

            localStorage.setItem(getLocalStorageHash(_this, 'isLocal'), bool);
          }
        }
      }
    });

    if (Common.isUndefined(params.parent)) {
      this.closed = params.closed || false;
      dom.addClass(this.domElement, GUI.CLASS_MAIN);
      dom.makeSelectable(this.domElement, false);

      if (SUPPORTS_LOCAL_STORAGE) {
        if (useLocalStorage) {
          _this.useLocalStorage = true;
          var savedGui = localStorage.getItem(getLocalStorageHash(this, 'gui'));

          if (savedGui) {
            params.load = JSON.parse(savedGui);
          }
        }
      }

      this.__closeButton = document.createElement('div');
      this.__closeButton.innerHTML = GUI.TEXT_CLOSED;
      dom.addClass(this.__closeButton, GUI.CLASS_CLOSE_BUTTON);

      if (params.closeOnTop) {
        dom.addClass(this.__closeButton, GUI.CLASS_CLOSE_TOP);
        this.domElement.insertBefore(this.__closeButton, this.domElement.childNodes[0]);
      } else {
        dom.addClass(this.__closeButton, GUI.CLASS_CLOSE_BOTTOM);
        this.domElement.appendChild(this.__closeButton);
      }

      dom.bind(this.__closeButton, 'click', function () {
        _this.closed = !_this.closed;
      });
    } else {
      if (params.closed === undefined) {
        params.closed = true;
      }

      var titleRowName = document.createTextNode(params.name);
      dom.addClass(titleRowName, 'controller-name');
      titleRow = addRow(_this, titleRowName);

      var onClickTitle = function onClickTitle(e) {
        e.preventDefault();
        _this.closed = !_this.closed;
        return false;
      };

      dom.addClass(this.__ul, GUI.CLASS_CLOSED);
      dom.addClass(titleRow, 'title');
      dom.bind(titleRow, 'click', onClickTitle);

      if (!params.closed) {
        this.closed = false;
      }
    }

    if (params.autoPlace) {
      if (Common.isUndefined(params.parent)) {
        if (autoPlaceVirgin) {
          autoPlaceContainer = document.createElement('div');
          dom.addClass(autoPlaceContainer, CSS_NAMESPACE);
          dom.addClass(autoPlaceContainer, GUI.CLASS_AUTO_PLACE_CONTAINER);
          document.body.appendChild(autoPlaceContainer);
          autoPlaceVirgin = false;
        }

        autoPlaceContainer.appendChild(this.domElement);
        dom.addClass(this.domElement, GUI.CLASS_AUTO_PLACE);
      }

      if (!this.parent) {
        setWidth(_this, params.width);
      }
    }

    this.__resizeHandler = function () {
      _this.onResizeDebounced();
    };

    dom.bind(window, 'resize', this.__resizeHandler);
    dom.bind(this.__ul, 'webkitTransitionEnd', this.__resizeHandler);
    dom.bind(this.__ul, 'transitionend', this.__resizeHandler);
    dom.bind(this.__ul, 'oTransitionEnd', this.__resizeHandler);
    this.onResize();

    if (params.resizable) {
      addResizeHandle(this);
    }

    saveToLocalStorage = function saveToLocalStorage() {
      if (SUPPORTS_LOCAL_STORAGE && localStorage.getItem(getLocalStorageHash(_this, 'isLocal')) === 'true') {
        localStorage.setItem(getLocalStorageHash(_this, 'gui'), JSON.stringify(_this.getSaveObject()));
      }
    };

    this.saveToLocalStorageIfPossible = saveToLocalStorage;

    function resetWidth() {
      var root = _this.getRoot();

      root.width += 1;
      Common.defer(function () {
        root.width -= 1;
      });
    }

    if (!params.parent) {
      resetWidth();
    }
  };

  GUI.toggleHide = function () {
    hide = !hide;
    Common.each(hideableGuis, function (gui) {
      gui.domElement.style.display = hide ? 'none' : '';
    });
  };

  GUI.CLASS_AUTO_PLACE = 'a';
  GUI.CLASS_AUTO_PLACE_CONTAINER = 'ac';
  GUI.CLASS_MAIN = 'main';
  GUI.CLASS_CONTROLLER_ROW = 'cr';
  GUI.CLASS_TOO_TALL = 'taller-than-window';
  GUI.CLASS_CLOSED = 'closed';
  GUI.CLASS_CLOSE_BUTTON = 'close-button';
  GUI.CLASS_CLOSE_TOP = 'close-top';
  GUI.CLASS_CLOSE_BOTTOM = 'close-bottom';
  GUI.CLASS_DRAG = 'drag';
  GUI.DEFAULT_WIDTH = 245;
  GUI.TEXT_CLOSED = 'Close Controls';
  GUI.TEXT_OPEN = 'Open Controls';

  GUI._keydownHandler = function (e) {
    if (document.activeElement.type !== 'text' && (e.which === HIDE_KEY_CODE || e.keyCode === HIDE_KEY_CODE)) {
      GUI.toggleHide();
    }
  };

  dom.bind(window, 'keydown', GUI._keydownHandler, false);
  Common.extend(GUI.prototype, {
    add: function add(object, property) {
      return _add(this, object, property, {
        factoryArgs: Array.prototype.slice.call(arguments, 2)
      });
    },
    addColor: function addColor(object, property) {
      return _add(this, object, property, {
        color: true
      });
    },
    remove: function remove(controller) {
      this.__ul.removeChild(controller.__li);

      this.__controllers.splice(this.__controllers.indexOf(controller), 1);

      var _this = this;

      Common.defer(function () {
        _this.onResize();
      });
    },
    destroy: function destroy() {
      if (this.parent) {
        throw new Error('Only the root GUI should be removed with .destroy(). ' + 'For subfolders, use gui.removeFolder(folder) instead.');
      }

      if (this.autoPlace) {
        autoPlaceContainer.removeChild(this.domElement);
      }

      var _this = this;

      Common.each(this.__folders, function (subfolder) {
        _this.removeFolder(subfolder);
      });
      dom.unbind(window, 'keydown', GUI._keydownHandler, false);
      removeListeners(this);
    },
    addFolder: function addFolder(name) {
      if (this.__folders[name] !== undefined) {
        throw new Error('You already have a folder in this GUI by the' + ' name "' + name + '"');
      }

      var newGuiParams = {
        name: name,
        parent: this
      };
      newGuiParams.autoPlace = this.autoPlace;

      if (this.load && this.load.folders && this.load.folders[name]) {
        newGuiParams.closed = this.load.folders[name].closed;
        newGuiParams.load = this.load.folders[name];
      }

      var gui = new GUI(newGuiParams);
      this.__folders[name] = gui;
      var li = addRow(this, gui.domElement);
      dom.addClass(li, 'folder');
      return gui;
    },
    removeFolder: function removeFolder(folder) {
      this.__ul.removeChild(folder.domElement.parentElement);

      delete this.__folders[folder.name];

      if (this.load && this.load.folders && this.load.folders[folder.name]) {
        delete this.load.folders[folder.name];
      }

      removeListeners(folder);

      var _this = this;

      Common.each(folder.__folders, function (subfolder) {
        folder.removeFolder(subfolder);
      });
      Common.defer(function () {
        _this.onResize();
      });
    },
    open: function open() {
      this.closed = false;
    },
    close: function close() {
      this.closed = true;
    },
    hide: function hide() {
      this.domElement.style.display = 'none';
    },
    show: function show() {
      this.domElement.style.display = '';
    },
    onResize: function onResize() {
      var root = this.getRoot();

      if (root.scrollable) {
        var top = dom.getOffset(root.__ul).top;
        var h = 0;
        Common.each(root.__ul.childNodes, function (node) {
          if (!(root.autoPlace && node === root.__save_row)) {
            h += dom.getHeight(node);
          }
        });

        if (window.innerHeight - top - CLOSE_BUTTON_HEIGHT < h) {
          dom.addClass(root.domElement, GUI.CLASS_TOO_TALL);
          root.__ul.style.height = window.innerHeight - top - CLOSE_BUTTON_HEIGHT + 'px';
        } else {
          dom.removeClass(root.domElement, GUI.CLASS_TOO_TALL);
          root.__ul.style.height = 'auto';
        }
      }

      if (root.__resize_handle) {
        Common.defer(function () {
          root.__resize_handle.style.height = root.__ul.offsetHeight + 'px';
        });
      }

      if (root.__closeButton) {
        root.__closeButton.style.width = root.width + 'px';
      }
    },
    onResizeDebounced: Common.debounce(function () {
      this.onResize();
    }, 50),
    remember: function remember() {
      if (Common.isUndefined(SAVE_DIALOGUE)) {
        SAVE_DIALOGUE = new CenteredDiv();
        SAVE_DIALOGUE.domElement.innerHTML = saveDialogContents;
      }

      if (this.parent) {
        throw new Error('You can only call remember on a top level GUI.');
      }

      var _this = this;

      Common.each(Array.prototype.slice.call(arguments), function (object) {
        if (_this.__rememberedObjects.length === 0) {
          addSaveMenu(_this);
        }

        if (_this.__rememberedObjects.indexOf(object) === -1) {
          _this.__rememberedObjects.push(object);
        }
      });

      if (this.autoPlace) {
        setWidth(this, this.width);
      }
    },
    getRoot: function getRoot() {
      var gui = this;

      while (gui.parent) {
        gui = gui.parent;
      }

      return gui;
    },
    getSaveObject: function getSaveObject() {
      var toReturn = this.load;
      toReturn.closed = this.closed;

      if (this.__rememberedObjects.length > 0) {
        toReturn.preset = this.preset;

        if (!toReturn.remembered) {
          toReturn.remembered = {};
        }

        toReturn.remembered[this.preset] = getCurrentPreset(this);
      }

      toReturn.folders = {};
      Common.each(this.__folders, function (element, key) {
        toReturn.folders[key] = element.getSaveObject();
      });
      return toReturn;
    },
    save: function save() {
      if (!this.load.remembered) {
        this.load.remembered = {};
      }

      this.load.remembered[this.preset] = getCurrentPreset(this);
      markPresetModified(this, false);
      this.saveToLocalStorageIfPossible();
    },
    saveAs: function saveAs(presetName) {
      if (!this.load.remembered) {
        this.load.remembered = {};
        this.load.remembered[DEFAULT_DEFAULT_PRESET_NAME] = getCurrentPreset(this, true);
      }

      this.load.remembered[presetName] = getCurrentPreset(this);
      this.preset = presetName;
      addPresetOption(this, presetName, true);
      this.saveToLocalStorageIfPossible();
    },
    revert: function revert(gui) {
      Common.each(this.__controllers, function (controller) {
        if (!this.getRoot().load.remembered) {
          controller.setValue(controller.initialValue);
        } else {
          recallSavedValue(gui || this.getRoot(), controller);
        }

        if (controller.__onFinishChange) {
          controller.__onFinishChange.call(controller, controller.getValue());
        }
      }, this);
      Common.each(this.__folders, function (folder) {
        folder.revert(folder);
      });

      if (!gui) {
        markPresetModified(this.getRoot(), false);
      }
    },
    listen: function listen(controller) {
      var init = this.__listening.length === 0;

      this.__listening.push(controller);

      if (init) {
        updateDisplays(this.__listening);
      }
    },
    updateDisplay: function updateDisplay() {
      Common.each(this.__controllers, function (controller) {
        controller.updateDisplay();
      });
      Common.each(this.__folders, function (folder) {
        folder.updateDisplay();
      });
    }
  });

  function addRow(gui, newDom, liBefore) {
    var li = document.createElement('li');

    if (newDom) {
      li.appendChild(newDom);
    }

    if (liBefore) {
      gui.__ul.insertBefore(li, liBefore);
    } else {
      gui.__ul.appendChild(li);
    }

    gui.onResize();
    return li;
  }

  function removeListeners(gui) {
    dom.unbind(window, 'resize', gui.__resizeHandler);

    if (gui.saveToLocalStorageIfPossible) {
      dom.unbind(window, 'unload', gui.saveToLocalStorageIfPossible);
    }
  }

  function markPresetModified(gui, modified) {
    var opt = gui.__preset_select[gui.__preset_select.selectedIndex];

    if (modified) {
      opt.innerHTML = opt.value + '*';
    } else {
      opt.innerHTML = opt.value;
    }
  }

  function augmentController(gui, li, controller) {
    controller.__li = li;
    controller.__gui = gui;
    Common.extend(controller, {
      options: function options(_options) {
        if (arguments.length > 1) {
          var nextSibling = controller.__li.nextElementSibling;
          controller.remove();
          return _add(gui, controller.object, controller.property, {
            before: nextSibling,
            factoryArgs: [Common.toArray(arguments)]
          });
        }

        if (Common.isArray(_options) || Common.isObject(_options)) {
          var _nextSibling = controller.__li.nextElementSibling;
          controller.remove();
          return _add(gui, controller.object, controller.property, {
            before: _nextSibling,
            factoryArgs: [_options]
          });
        }
      },
      name: function name(_name) {
        controller.__li.firstElementChild.firstElementChild.innerHTML = _name;
        return controller;
      },
      listen: function listen() {
        controller.__gui.listen(controller);

        return controller;
      },
      remove: function remove() {
        controller.__gui.remove(controller);

        return controller;
      }
    });

    if (controller instanceof NumberControllerSlider) {
      var box = new NumberControllerBox(controller.object, controller.property, {
        min: controller.__min,
        max: controller.__max,
        step: controller.__step
      });
      Common.each(['updateDisplay', 'onChange', 'onFinishChange', 'step', 'min', 'max'], function (method) {
        var pc = controller[method];
        var pb = box[method];

        controller[method] = box[method] = function () {
          var args = Array.prototype.slice.call(arguments);
          pb.apply(box, args);
          return pc.apply(controller, args);
        };
      });
      dom.addClass(li, 'has-slider');
      controller.domElement.insertBefore(box.domElement, controller.domElement.firstElementChild);
    } else if (controller instanceof NumberControllerBox) {
      var r = function r(returned) {
        if (Common.isNumber(controller.__min) && Common.isNumber(controller.__max)) {
          var oldName = controller.__li.firstElementChild.firstElementChild.innerHTML;
          var wasListening = controller.__gui.__listening.indexOf(controller) > -1;
          controller.remove();

          var newController = _add(gui, controller.object, controller.property, {
            before: controller.__li.nextElementSibling,
            factoryArgs: [controller.__min, controller.__max, controller.__step]
          });

          newController.name(oldName);
          if (wasListening) newController.listen();
          return newController;
        }

        return returned;
      };

      controller.min = Common.compose(r, controller.min);
      controller.max = Common.compose(r, controller.max);
    } else if (controller instanceof BooleanController) {
      dom.bind(li, 'click', function () {
        dom.fakeEvent(controller.__checkbox, 'click');
      });
      dom.bind(controller.__checkbox, 'click', function (e) {
        e.stopPropagation();
      });
    } else if (controller instanceof FunctionController) {
      dom.bind(li, 'click', function () {
        dom.fakeEvent(controller.__button, 'click');
      });
      dom.bind(li, 'mouseover', function () {
        dom.addClass(controller.__button, 'hover');
      });
      dom.bind(li, 'mouseout', function () {
        dom.removeClass(controller.__button, 'hover');
      });
    } else if (controller instanceof ColorController) {
      dom.addClass(li, 'color');
      controller.updateDisplay = Common.compose(function (val) {
        li.style.borderLeftColor = controller.__color.toString();
        return val;
      }, controller.updateDisplay);
      controller.updateDisplay();
    }

    controller.setValue = Common.compose(function (val) {
      if (gui.getRoot().__preset_select && controller.isModified()) {
        markPresetModified(gui.getRoot(), true);
      }

      return val;
    }, controller.setValue);
  }

  function recallSavedValue(gui, controller) {
    var root = gui.getRoot();

    var matchedIndex = root.__rememberedObjects.indexOf(controller.object);

    if (matchedIndex !== -1) {
      var controllerMap = root.__rememberedObjectIndecesToControllers[matchedIndex];

      if (controllerMap === undefined) {
        controllerMap = {};
        root.__rememberedObjectIndecesToControllers[matchedIndex] = controllerMap;
      }

      controllerMap[controller.property] = controller;

      if (root.load && root.load.remembered) {
        var presetMap = root.load.remembered;
        var preset = void 0;

        if (presetMap[gui.preset]) {
          preset = presetMap[gui.preset];
        } else if (presetMap[DEFAULT_DEFAULT_PRESET_NAME]) {
          preset = presetMap[DEFAULT_DEFAULT_PRESET_NAME];
        } else {
          return;
        }

        if (preset[matchedIndex] && preset[matchedIndex][controller.property] !== undefined) {
          var value = preset[matchedIndex][controller.property];
          controller.initialValue = value;
          controller.setValue(value);
        }
      }
    }
  }

  function _add(gui, object, property, params) {
    if (object[property] === undefined) {
      throw new Error('Object "' + object + '" has no property "' + property + '"');
    }

    var controller = void 0;

    if (params.color) {
      controller = new ColorController(object, property);
    } else {
      var factoryArgs = [object, property].concat(params.factoryArgs);
      controller = ControllerFactory.apply(gui, factoryArgs);
    }

    if (params.before instanceof Controller) {
      params.before = params.before.__li;
    }

    recallSavedValue(gui, controller);
    dom.addClass(controller.domElement, 'c');
    var name = document.createElement('span');
    dom.addClass(name, 'property-name');
    name.innerHTML = controller.property;
    var container = document.createElement('div');
    container.appendChild(name);
    container.appendChild(controller.domElement);
    var li = addRow(gui, container, params.before);
    dom.addClass(li, GUI.CLASS_CONTROLLER_ROW);

    if (controller instanceof ColorController) {
      dom.addClass(li, 'color');
    } else {
      dom.addClass(li, _typeof$1(controller.getValue()));
    }

    augmentController(gui, li, controller);

    gui.__controllers.push(controller);

    return controller;
  }

  function getLocalStorageHash(gui, key) {
    return document.location.href + '.' + key;
  }

  function addPresetOption(gui, name, setSelected) {
    var opt = document.createElement('option');
    opt.innerHTML = name;
    opt.value = name;

    gui.__preset_select.appendChild(opt);

    if (setSelected) {
      gui.__preset_select.selectedIndex = gui.__preset_select.length - 1;
    }
  }

  function showHideExplain(gui, explain) {
    explain.style.display = gui.useLocalStorage ? 'block' : 'none';
  }

  function addSaveMenu(gui) {
    var div = gui.__save_row = document.createElement('li');
    dom.addClass(gui.domElement, 'has-save');

    gui.__ul.insertBefore(div, gui.__ul.firstChild);

    dom.addClass(div, 'save-row');
    var gears = document.createElement('span');
    gears.innerHTML = '&nbsp;';
    dom.addClass(gears, 'button gears');
    var button = document.createElement('span');
    button.innerHTML = 'Save';
    dom.addClass(button, 'button');
    dom.addClass(button, 'save');
    var button2 = document.createElement('span');
    button2.innerHTML = 'New';
    dom.addClass(button2, 'button');
    dom.addClass(button2, 'save-as');
    var button3 = document.createElement('span');
    button3.innerHTML = 'Revert';
    dom.addClass(button3, 'button');
    dom.addClass(button3, 'revert');
    var select = gui.__preset_select = document.createElement('select');

    if (gui.load && gui.load.remembered) {
      Common.each(gui.load.remembered, function (value, key) {
        addPresetOption(gui, key, key === gui.preset);
      });
    } else {
      addPresetOption(gui, DEFAULT_DEFAULT_PRESET_NAME, false);
    }

    dom.bind(select, 'change', function () {
      for (var index = 0; index < gui.__preset_select.length; index++) {
        gui.__preset_select[index].innerHTML = gui.__preset_select[index].value;
      }

      gui.preset = this.value;
    });
    div.appendChild(select);
    div.appendChild(gears);
    div.appendChild(button);
    div.appendChild(button2);
    div.appendChild(button3);

    if (SUPPORTS_LOCAL_STORAGE) {
      var explain = document.getElementById('dg-local-explain');
      var localStorageCheckBox = document.getElementById('dg-local-storage');
      var saveLocally = document.getElementById('dg-save-locally');
      saveLocally.style.display = 'block';

      if (localStorage.getItem(getLocalStorageHash(gui, 'isLocal')) === 'true') {
        localStorageCheckBox.setAttribute('checked', 'checked');
      }

      showHideExplain(gui, explain);
      dom.bind(localStorageCheckBox, 'change', function () {
        gui.useLocalStorage = !gui.useLocalStorage;
        showHideExplain(gui, explain);
      });
    }

    var newConstructorTextArea = document.getElementById('dg-new-constructor');
    dom.bind(newConstructorTextArea, 'keydown', function (e) {
      if (e.metaKey && (e.which === 67 || e.keyCode === 67)) {
        SAVE_DIALOGUE.hide();
      }
    });
    dom.bind(gears, 'click', function () {
      newConstructorTextArea.innerHTML = JSON.stringify(gui.getSaveObject(), undefined, 2);
      SAVE_DIALOGUE.show();
      newConstructorTextArea.focus();
      newConstructorTextArea.select();
    });
    dom.bind(button, 'click', function () {
      gui.save();
    });
    dom.bind(button2, 'click', function () {
      var presetName = prompt('Enter a new preset name.');

      if (presetName) {
        gui.saveAs(presetName);
      }
    });
    dom.bind(button3, 'click', function () {
      gui.revert();
    });
  }

  function addResizeHandle(gui) {
    var pmouseX = void 0;
    gui.__resize_handle = document.createElement('div');
    Common.extend(gui.__resize_handle.style, {
      width: '6px',
      marginLeft: '-3px',
      height: '200px',
      cursor: 'ew-resize',
      position: 'absolute'
    });

    function drag(e) {
      e.preventDefault();
      gui.width += pmouseX - e.clientX;
      gui.onResize();
      pmouseX = e.clientX;
      return false;
    }

    function dragStop() {
      dom.removeClass(gui.__closeButton, GUI.CLASS_DRAG);
      dom.unbind(window, 'mousemove', drag);
      dom.unbind(window, 'mouseup', dragStop);
    }

    function dragStart(e) {
      e.preventDefault();
      pmouseX = e.clientX;
      dom.addClass(gui.__closeButton, GUI.CLASS_DRAG);
      dom.bind(window, 'mousemove', drag);
      dom.bind(window, 'mouseup', dragStop);
      return false;
    }

    dom.bind(gui.__resize_handle, 'mousedown', dragStart);
    dom.bind(gui.__closeButton, 'mousedown', dragStart);
    gui.domElement.insertBefore(gui.__resize_handle, gui.domElement.firstElementChild);
  }

  function setWidth(gui, w) {
    gui.domElement.style.width = w + 'px';

    if (gui.__save_row && gui.autoPlace) {
      gui.__save_row.style.width = w + 'px';
    }

    if (gui.__closeButton) {
      gui.__closeButton.style.width = w + 'px';
    }
  }

  function getCurrentPreset(gui, useInitialValues) {
    var toReturn = {};
    Common.each(gui.__rememberedObjects, function (val, index) {
      var savedValues = {};
      var controllerMap = gui.__rememberedObjectIndecesToControllers[index];
      Common.each(controllerMap, function (controller, property) {
        savedValues[property] = useInitialValues ? controller.initialValue : controller.getValue();
      });
      toReturn[index] = savedValues;
    });
    return toReturn;
  }

  function setPresetSelectIndex(gui) {
    for (var index = 0; index < gui.__preset_select.length; index++) {
      if (gui.__preset_select[index].value === gui.preset) {
        gui.__preset_select.selectedIndex = index;
      }
    }
  }

  function updateDisplays(controllerArray) {
    if (controllerArray.length !== 0) {
      requestAnimationFrame$1$1.call(window, function () {
        updateDisplays(controllerArray);
      });
    }

    Common.each(controllerArray, function (c) {
      c.updateDisplay();
    });
  }

  window.debug = false;
  window.debugPolygons = false;
  var PHYSICS_ENABLED = true;
  var BKG_SFX_MIN = 10000;
  var BKG_SFX_MAX = 20000;
  var pBeta = 0;
  var pGamma = 0;

  var Game =
  /*#__PURE__*/
  function (_Onyx$Scene) {
    _inherits(Game, _Onyx$Scene);

    function Game() {
      var _this;

      _classCallCheck(this, Game);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(Game).call(this));
      _this.renderPasses = [new RenderPass({
        viewportClear: true
      })];
      _this.actors = {};
      _this.physicsEnabled = true;
      _this.mouseState = {
        isTouch: false,
        position: {
          x: 0,
          y: 0
        },
        downStart: {
          x: 0,
          y: 0
        },
        downEnd: {
          x: 0,
          y: 0
        },
        buttons: []
      };
      var savedStats = window.localStorage.getItem("sd_mm_stats");

      if (!savedStats) {
        savedStats = {
          inARow: 0,
          shotsTaken: 0,
          score: 0,
          levelsCompleted: 0
        };
      } else {
        savedStats = JSON.parse(savedStats);
      } // if(!savedHighScores){
      // 	this.highscores = [...CONFIG.meta.defaultHighScores];
      // }else{
      // 	this.highscores = JSON.parse(savedHighScores);
      // }


      _this.score = savedStats.score;
      _this.inARow = savedStats.inARow;
      _this.shotsTaken = savedStats.shotsTaken;
      _this.shotsTakenThisLevel = 0;
      _this.cookiesLeft = CONFIG.meta.startCookies;
      _this.ballRestCount = 0;
      _this.ballResting = false;
      _this.highscores = [];
      _this.bgsUsed = [];
      _this.cameosUsed = [];
      _this.cameosGangUsed = [];
      _this.allowCameos = false;
      _this.isLevelComplete = false;
      _this.levelsCompleted = savedStats.levelsCompleted;

      _this.selectNewBackground("BG-14");

      _this.cheats = {
        snackSize: 1,
        snackForce: 1
      };
      _this.listenerClick = {
        handleEvent: function handleEvent(evt) {
          return _this.onClick(evt);
        }
      };
      _this.listenerMove = {
        handleEvent: function handleEvent(evt) {
          return _this.onMouseMove(evt);
        }
      };
      return _this;
    }

    _createClass(Game, [{
      key: "onload",
      value: function onload() {
        var _this2 = this;

        // this.viewports[0].id = 0; // Hotfix so it doesn't reload the textures (It's creating a new viewport object every scene)
        this.viewports = game.router.map.preloader.module.viewports; // this.viewports[0].listenForMouseEvents({ scene: game.router.map.title.module, renderPick: true });
        // this.viewports = game.router.map.preloader.module.viewports;
        // this.viewports[0].mouseEventHover = false;

        this.viewports[0].clearColor.set(0, 0, 0);
        var camera = new Camera({
          projectionType: "orthographic",
          transform: new Transform({
            position: [0, 0, 100]
          })
        });
        this.add(camera);
        this.viewports[0].bindToCamera(camera);
        this.setupMatter();
        this.visible = false;
        this.loadScene().then(function () {
          // this.setTimeout(() => {
          // game.playMusic("AO-Music");
          // game.playMusic("SD-Aambient-01");
          // game.playRandomSFX(["SD-Organ-#"]);
          _this2.complete = false; // this.viewports[0].clearColor.set(111 / 255, 68 / 255, 141 / 255);

          _this2.visible = true;

          _this2.transitionOverlay.fadeIn(function () {
            _this2.setupInputListeners();
          }); // }, 500);

        });
        this.setTimeout(function () {
          return _this2.playBackgroundSFX();
        }, BKG_SFX_MIN + Math.random() * (BKG_SFX_MAX - BKG_SFX_MIN)); // 5 - 15 seconds

        if (!this.music) {
          this.music = game.playMusic("SD-Ambient");
        }

        if (!this.music2) {
          this.music2 = game.playMusic("SD-Rhythm");
          game.fadeMusic(this.music2, 0, undefined, 0);
        }
      }
    }, {
      key: "onunload",
      value: function onunload() {
        this.entities = [];
        this.components = [];
        this.cameras = []; // this.viewports[0].bindToCamera();
        // this.viewports[0].removeMouseListenEvents({ scene: this });

        delete this.matterEngine;
        window.removeEventListener("keydown", this.onKeyDown);
        this.viewports[0].contextElement.removeEventListener("mousedown", this.listenerClick);
        this.viewports[0].contextElement.removeEventListener("touchstart", this.listenerClick);
        this.viewports[0].contextElement.addEventListener("mousemove", this.listenerMove);
        this.viewports[0].contextElement.addEventListener("touchmove", this.listenerMove);
      }
    }, {
      key: "saveStats",
      value: function saveStats() {
        window.localStorage.setItem("sd_mm_stats", JSON.stringify({
          inARow: this.inARow,
          shotsTaken: this.shotsTaken,
          score: this.score,
          levelsCompleted: this.levelsCompleted
        }));
      }
    }, {
      key: "clearStats",
      value: function clearStats() {
        window.localStorage.setItem("sd_mm_stats", "");
        this.score = 0;
        this.inARow = 0;
        this.shotsTaken = 0;
        this.levelsCompleted = 0;
      }
    }, {
      key: "setupInputListeners",
      value: function setupInputListeners() {
        var _this3 = this;

        this.onKeyDown = function (evt) {
          // console.log(evt.keyCode);
          switch (evt.keyCode) {
            // B
            case 66:
              if (!_this3.reset.allowReset) {
                _this3.reset.onReadyToAppear();

                _this3.showToasty("Scooby-Shaggy");
              }

              break;
            // L

            case 76:
              _this3.background.state = _this3.selectNewBackground();

              _this3.showToasty("Scooby-Shaggy");

              break;
            // T

            case 84:
              _this3.showToasty(undefined, true);

              break;
            // W

            case 87:
              _this3.scooby.wag(); // this.showToasty("Scooby-Shaggy");


              break;
            // +/=

            case 107:
            case 187:
            case 61:
              if (_this3.cheats.snackSize !== 1.75) {
                _this3.cheats.snackSize = 1.75;
                _this3.cheats.snackForce = 2.75;
              } else {
                _this3.cheats.snackSize = 1;
                _this3.cheats.snackForce = 1;
              }

              _this3.reloadSnack();

              _this3.showToasty("Scooby-Shaggy");

              break;
            // -

            case 109:
            case 189:
            case 173:
              if (_this3.cheats.snackSize !== 0.5) {
                _this3.cheats.snackSize = 0.5;
                _this3.cheats.snackForce = 0.23;
              } else {
                _this3.cheats.snackSize = 1;
                _this3.cheats.snackForce = 1;
              }

              _this3.reloadSnack();

              _this3.showToasty("Scooby-Shaggy");

              break;
            // X

            case 88:
              if (_this3.txtCompleted.visible) {
                if (_this3.txtShotsTaken.visible) {
                  _this3.txtShotsTaken.visible = false;
                  _this3.txtScore.visible = false;
                  _this3.txtCompleted.visible = false;
                } else {
                  _this3.txtShotsTaken.visible = true;
                  _this3.txtScore.visible = true;
                }
              } else {
                _this3.txtCompleted.visible = true;
              }

              break;
            // C

            case 67:
              if (evt.shiftKey) _this3.clearStats();
              break;
            // A

            case 65:
              // this.onCompleted();
              break;
            // 4

            case 52:
              if (evt.shiftKey) _this3.allowCameos = !_this3.allowCameos;

              _this3.showToasty();

              break;

          }
        };

        window.addEventListener("keydown", this.onKeyDown);
        this.viewports[0].contextElement.addEventListener("mousedown", this.listenerClick);
        this.viewports[0].contextElement.addEventListener("touchstart", this.listenerClick);
        this.viewports[0].contextElement.addEventListener("mousemove", this.listenerMove);
        this.viewports[0].contextElement.addEventListener("touchmove", this.listenerMove); // Parallax effect

        if (window.DeviceMotionEvent) {
          window.ondeviceorientation = function (e) {
            var power = 1;

            if (pBeta === 0 && pGamma === 0) {
              pBeta = e.beta;
              pGamma = e.gamma;
            }

            var dBeta = pBeta - e.beta;
            var dGamma = pGamma - e.gamma;
            pBeta = e.beta;
            pGamma = e.gamma;

            if (_this3.background) {
              _this3.background.transform.x = Math.max(Math.min(_this3.background.transform.x - dBeta * power, 20), -20);
              _this3.background.transform.y = Math.max(Math.min(_this3.background.transform.y - dGamma * power, 20), -20);
            }
          };
        }
      }
    }, {
      key: "update",
      value: function update(dt) {
        _get(_getPrototypeOf(Game.prototype), "update", this).apply(this, arguments); // for(let gamepad of game.gamepads){
        //     for(let button of gamepad.buttons){
        //         if(button.pressed) this.onClick({ type: "gamepad", button: button * 1 });
        //     }
        // }


        if (this.physicsEnabled && PHYSICS_ENABLED) Matter.Engine.update(this.matterEngine, dt * CONFIG.meta.physics.speed); // this.cameras[0].transform.x += 0.01;
        // console.log(this.ground.mesh.vertices);
        // Check if ball is still within bounds

        if (this.snack.transform.x < -100 || this.snack.transform.x > 1500 || this.snack.transform.y < 0) {
          this.reloadSnack();
          game.playRandomSFX(["SD-OffScreen-#"]);
          this.onMissHIO();
        }

        if (this.snack.body.isSleeping && !this.ballResting) {
          this.ballResting = true;
          this.ballRestCount++;
        } // Check if still on a roll


        if (this.shotsTakenThisLevel > 0 && this.snack.body.isSleeping) this.onMissHIO();
        this.txtScore.value = this.score + "h";
        this.txtShotsTaken.value = this.shotsTaken + "a";
        this.txtCompleted.value = this.levelsCompleted + "x";
        if (this.txtCookiesLeft) this.txtCookiesLeft.value = "*" + this.cookiesLeft;
      }
    }, {
      key: "onMissHIO",
      value: function onMissHIO() {
        if (this.missed) return;
        this.missed = true;
        var missCount = this.shotsTakenThisLevel || 1;
        var maxFadeTime = 6;

        if (this.music) {
          game.fadeMusic(this.music, 0, undefined, 1 * maxFadeTime / missCount * 1000);
          game.fadeMusic(this.music2, 0, undefined, 1 * maxFadeTime / missCount * 1000);
        }

        if (missCount >= 3) {
          // this.showToasty(CONFIG.meta.cameosGang[missCount % 5]);
          this.reset.onReadyToAppear();
        }

        if (missCount === 3) {
          this.reset.showInstructions();
        }
      }
    }, {
      key: "render",
      value: function render() {
        var _get2;

        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        (_get2 = _get(_getPrototypeOf(Game.prototype), "render", this)).call.apply(_get2, [this].concat(args));

        this.getPhysicsWorldCoordinates(); // Rescale MatterMouse because the viewport isn't always the size of the world height
        // Matter.Mouse.setScale(this.matterMouse, {x: this.physicsWorldView.width / this.viewports[0].contextElement.width, y: this.physicsWorldView.height / this.viewports[0].contextElement.height});

        Matter.Render.lookAt(this.matterRender, {
          min: {
            x: this.physicsWorldView.min.x,
            y: -this.physicsWorldView.max.y
          },
          max: {
            x: this.physicsWorldView.max.x,
            y: -this.physicsWorldView.min.y
          }
        });

        {
          if (window.debug) {
            Matter.Render.world(this.matterRender);
          }

          document.getElementById("matter-debug").style.display = window.debugPolygons ? "" : "none";
        }
      }
    }, {
      key: "playBackgroundSFX",
      value: function playBackgroundSFX() {
        var _this4 = this;

        // Play random sfx
        game.playRandomSFX(["SD-cricket", "SD-Cricketsloop", "SD-Lightning", "SD-Owl", "SD-Storm", "SD-Thunder", "SD-Wind"]);
        this.setTimeout(function () {
          return _this4.playBackgroundSFX();
        }, BKG_SFX_MIN + Math.random() * (BKG_SFX_MAX - BKG_SFX_MIN)); // 5 - 15 seconds
      }
    }, {
      key: "selectNewBackground",
      value: function selectNewBackground(bg) {
        // If it's the first time, build playlist
        if (!this.playlist) {
          // Fisher-Yates shuffle
          var fy = function fy(a, b, c, d) {
            //array,placeholder,placeholder,placeholder
            c = a.length;

            while (c) {
              b = Math.random() * (--c + 1) | 0, d = a[c], a[c] = a[b], a[b] = d;
            }
          };

          this.playlist = [];

          for (var i = 0; i < CONFIG.meta.backgrounds.length; i++) {
            this.playlist.push(i);
          }

          fy(this.playlist);
          this.playlistIndex = -1;
        }

        this.playlistIndex++; // Select        

        if (!bg) {
          // Clear bgsUsed if all backgrounds have been used
          if (this.bgsUsed.length === CONFIG.meta.backgrounds.length) {
            this.bgsUsed = [];
            this.playlistIndex = 0;
          } // Select from list


          bg = CONFIG.meta.backgrounds[this.playlist[this.playlistIndex]];
          this.bgsUsed.push(bg);
        } // Apply


        this.currentBackground = bg;
        if (this.background) this.background.state = this.currentBackground;
        if (this.toast) this.showToasty(); // console.log(this.currentBackground, this.playlistIndex);

        return this.currentBackground;
      }
    }, {
      key: "stopMusic",
      value: function stopMusic() {
        game.stopMusic(this.music, 2000);
        this.music = null;
      }
    }, {
      key: "onMouseDown",
      value: function onMouseDown(evt) {
        var _this5 = this;

        if (!this.scooby || this.instructions && this.instructions.shotsTaken < 1) return; // this.mouseState

        this.mouseDown = true;
        if (this.mouseState.lastDown) game.playRandomSFX(["SD-Tap-Drip-1", "SD-Tap-Drip-1", "SD-Tap-Squeak"]);
        this.updateMousePos(evt);
        this.mouseState.lastDown = new Date(); // console.log(this.mouseState.position);

        if (!this.isLevelComplete && this.reset.allowReset && this.mouseState.position.x > 100 && this.mouseState.position.x < 200 && this.mouseState.position.y > 550 && this.mouseState.position.y < 800) {
          // Wait a frame so that arrow disappears during heavy loading
          this.shotsTakenThisLevel = 0;
          this.setTimeout(function () {
            _this5.reset.onLevelReset(function () {
              _this5.regenerate();

              if (_this5.cookiesLeft <= 0) _this5.cookiesLeft = CONFIG.meta.startCookies;
              _this5.mouseDown = false; // this.showToasty(CONFIG.meta.cameosGang[Math.random() * CONFIG.meta.cameosGang.length | 0]);
            });
          }, 32);
          this.mouseDown = false;
          return;
        }

        if (this.mouseState.position.x > 1217 && this.mouseState.position.x < 1329 && this.mouseState.position.y > 0 && this.mouseState.position.y < 150) {
          if (this.txtCompleted.visible) {
            if (this.txtShotsTaken.visible) {
              this.txtShotsTaken.visible = false;
              this.txtScore.visible = false;
              this.txtCompleted.visible = false;
            } else {
              this.txtShotsTaken.visible = true;
              this.txtScore.visible = true;
            }
          } else {
            this.txtCompleted.visible = true;
          }

          this.mouseDown = false;
          return;
        }

        this.mouseState.downStart.x = this.mouseState.position.x;
        this.mouseState.downStart.y = this.mouseState.position.y;
        this.cursor.length = 0;

        if (this.cursor) {
          {
            this.cursor.transform.x = this.mouseState.downStart.x;
            this.cursor.transform.y = this.mouseState.downStart.y;
          }

          this.cursor.visible = true;
          this.prevAngle = 0;
        } // this.sfxAIM = game.playRandomMusic(["SD-Aim-#-Dn"]);


        if (this.instructions) this.instructions.dismiss();
        evt.preventDefault();
      }
    }, {
      key: "onMouseUp",
      value: function onMouseUp(evt) {
        if (!this.mouseDown) return;
        this.mouseDown = false; // this.button.state = "idle";
        // this.onClick();

        this.updateMousePos(evt);

        if (this.cursor) {
          this.cursor.visible = false;
        }

        if (this.mouseState.lastDown > new Date() - 64) return;
        game.playRandomSFX(["SD-Aim-#-Up"]);
        game.stopSFX("SD-Aim-01-Dn"); // game.stopMusic(this.sfxAIM, 16);

        if (!this.snack || !CONFIG.meta.buttons.allowShootBeforeRest ) return;
        this.mouseState.downEnd.x = this.mouseState.position.x;
        this.mouseState.downEnd.y = this.mouseState.position.y; // Get angle
        // let angle = Math.atan2(this.mouseState.downStart.y - this.mouseState.downEnd.y, this.mouseState.downStart.x - this.mouseState.downEnd.x);

        var angle = Matter.Vector.angle(this.mouseState.downStart, this.mouseState.downEnd);
        this.prevAngle = 0; // Get velocity

        var distance = Math.hypot(this.mouseState.downEnd.x - this.mouseState.downStart.x, this.mouseState.downEnd.y - this.mouseState.downStart.y);
        var force = Math.min(distance * CONFIG.meta.physics.hitForce, CONFIG.meta.physics.hitForceMax) * this.cheats.snackForce;

        if (this.snack && force && Math.abs(force > 2) && (!CONFIG.meta.startCookies )) {
          this.shotsTaken++;
          this.shotsTakenThisLevel++;
          this.cookiesLeft--;
          if (this.shotsTakenThisLevel > 1) this.onMissHIO();
          Matter.Body.applyForce(this.snack.body, this.snack.body.position, {
            x: -Math.cos(angle) * force,
            y: Math.sin(angle) * force
          });
          game.playRandomSFX(["SD-Launch-#"]);
        }

        this.ballResting = false;
        this.missed = false; // console.log(this.mouseState);

        evt.preventDefault();
      }
    }, {
      key: "onMouseMove",
      value: function onMouseMove(evt) {
        var _this6 = this;

        this.updateMousePos(evt);
        this.mouseState.downEnd.x = this.mouseState.position.x;
        this.mouseState.downEnd.y = this.mouseState.position.y; // Get angle

        var angle = Matter.Vector.angle(this.mouseState.downStart, this.mouseState.downEnd);
        this.cursor.transform.roll = angle - Math.PI;

        if (this.mouseDown && !this.playingAIMSFX && Math.abs(this.prevAngle - angle) > 2 * (Math.PI / 180)) {
          this.prevAngle = angle; // game.stopSFX("SD-Aim-01-Dn");

          game.playSFX("SD-Aim-01-Dn");
          this.playingAIMSFX = true;
          this.setTimeout(function () {
            _this6.playingAIMSFX = false;
          }, 32);
        } // Get velocity


        var distance = Math.hypot(this.mouseState.position.x - this.mouseState.downStart.x, this.mouseState.position.y - this.mouseState.downStart.y);
        var force = Math.min(distance * CONFIG.meta.physics.hitForce, CONFIG.meta.physics.hitForceMax);
        this.cursor.length = force;
      }
    }, {
      key: "onClick",
      value: function onClick(evt) {
        this.mouseDown = false; // this.button.state = "idle";

        if (evt && evt.type === "touchstart") game.router.map.game.module.mouseState.isTouch = true;
      }
    }, {
      key: "updateMousePos",
      value: function updateMousePos(ev) {
        var orthoHeight = this.viewports[0].orthoHeight;
        var orthoWidth = orthoHeight * (16 / 9);
        var rect = this.viewports[0].contextElement.getBoundingClientRect();
        var scale = orthoHeight / rect.height;
        var x = ev.offsetX;
        var y = ev.offsetY;

        if (ev.targetTouches && ev.targetTouches[0]) {
          x = ev.targetTouches[0].pageX;
          y = ev.targetTouches[0].pageY; // Offset

          x -= rect.left;
          y -= rect.top;
        } // Firefox


        if (!x && !y) {
          x = ev.clientX;
          y = ev.clientY; // Offset

          x -= rect.left;
          y -= rect.top;
        } // Inverse Y


        y = rect.height - y; // Scale

        if (this.cameras[0]) {
          x *= scale * this.cameras[0].transform.sx;
          y *= scale * this.cameras[0].transform.sy;
        } // Scale to world


        x /= this.transform.sx;
        y /= this.transform.sy;
        x -= (orthoWidth - orthoWidth * this.transform.sx) / 2;
        y -= (orthoHeight - orthoHeight * this.transform.sy) / 2;
        this.mouseState.position.x = x;
        this.mouseState.position.y = y; // console.log(x,y);
        // this.lines.push(this.addActor({
        //     cls: "FX-Line",
        //     position: [x, y, 1],
        //     isPersistent: false
        // }, true));
        // this.sortEntitiesByZ(true);

        this.mouseState.lastUpdate = new Date();
        return this.mouseState.position;
      }
    }, {
      key: "loadScene",
      value: function () {
        var _loadScene = _asyncToGenerator(
        /*#__PURE__*/
        regeneratorRuntime.mark(function _callee() {
          var _this7 = this;

          var screenHeight;
          return regeneratorRuntime.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  screenHeight = this.viewports[0].orthoHeight;

                  this.remove(this.background);
                  this.background = this.addActor({
                    cls: "BG-Base",
                    position: [0, 0, -10],
                    // HSV: rndHSV,
                    state: this.currentBackground
                  }, true); // this.remove(this.moon);
                  // this.moon = this.addActor({
                  //     cls: "BG-Moon",
                  //     position: [0, 0, -9],
                  //     HSV: rndHSV
                  // }, true);
                  // this.remove(this.moonOverlay);
                  // this.moonOverlay = this.addActor({
                  //     cls: "BG-Moon-Overlay",
                  //     position: [0, 0, -8],
                  //     HSV: rndHSV
                  // }, true);

                  this.reloadGround(this.levelsCompleted < 100 ? "thisispop" : undefined);
                  this.reloadSnack();
                  this.remove(this.cursor);
                  this.cursor = this.addActor({
                    cls: "UI-Cursor",
                    position: [0, 0, 2]
                  }, true);
                  this.cursor.visible = false;
                  this.remove(this.fog);
                  this.fog = this.addActor({
                    cls: "BG-Fog",
                    position: [0, 0, 3],
                    // HSV: rndHSV
                    opacity: 0.5
                  }, true); // Reset

                  this.remove(this.reset);
                  this.reset = this.addActor({
                    cls: "SK-Boo",
                    position: [90, 526, 40]
                  }, true); // Instructions

                  if (this.levelsCompleted < 100) {
                    this.remove(this.instructions);
                    this.instructions = this.addActor({
                      cls: "IN-Arm",
                      position: [0, 0, 41]
                    }, true);
                    this.instructions.visible = false;
                    this.instructions.setTimeout(function () {
                      _this7.instructions.visible = true;
                      _this7.instructions.state = "idle";
                    }, 750);
                  }

                  this.remove(this.toast);
                  this.toast = this.addActor({
                    cls: "UI-Toasty",
                    position: [-500, 0, 48]
                  }, true);
                  this.remove(this.frame);
                  this.frame = this.addActor({
                    cls: "BG-Frame",
                    position: [0, 0, 50]
                  }, true); // Score shots taken

                  this.txtShotsTaken = new Text({
                    glyphSpriteSheet: game.spritesheets["mm-glyphs.json"],
                    glyphAnimation: "SD",
                    glyphCharacters: "ahx0123456789^*,-H.+Xv",
                    text: this.shotsTaken + "^",
                    align: "right",
                    alignVertical: "bottom",
                    tracking: -18
                  });
                  this.txtShotsTaken.transform.xyz = [1327, 135, 80];
                  this.txtShotsTaken.transform.sxyz = [0.8, 0.8, 1];
                  this.txtShotsTaken.visible = false;
                  this.txtShotsTaken.opacity = 0.5;
                  this.add(this.txtShotsTaken); // Score text

                  this.txtScore = new Text({
                    glyphSpriteSheet: game.spritesheets["mm-glyphs.json"],
                    glyphAnimation: "SD",
                    glyphCharacters: "ahx0123456789^*,-H.+Xv",
                    text: this.score + "H",
                    align: "right",
                    alignVertical: "bottom",
                    tracking: -18
                  });
                  this.txtScore.transform.xyz = [1327, 100, 80];
                  this.txtScore.transform.sxyz = [0.8, 0.8, 1];
                  this.txtScore.visible = false;
                  this.txtScore.opacity = 0.5;
                  this.add(this.txtScore); // Levels completed text

                  this.txtCompleted = new Text({
                    glyphSpriteSheet: game.spritesheets["mm-glyphs.json"],
                    glyphAnimation: "SD",
                    glyphCharacters: "ahx0123456789^*,-H.+Xv",
                    text: this.levelsCompleted + "X",
                    align: "right",
                    alignVertical: "bottom",
                    tracking: -18
                  });
                  this.txtCompleted.transform.xyz = [1327, 65, 80];
                  this.txtCompleted.transform.sxyz = [0.8, 0.8, 1];
                  this.txtCompleted.visible = false;
                  this.txtCompleted.opacity = 0.5;
                  this.add(this.txtCompleted); // Cookies left

                  this.transitionOverlay = new TransitionOverlay({
                    isFaded: true
                  });
                  this.add(this.transitionOverlay);
                  this.transitionOverlay.transform.xyz = [1300, 0, 90]; // TODO: Is Z backwards for fixed position?

                  this.transitionOverlay.transform.sxyz = [0.9, 0.9, 1]; // this.transitionOverlay.transform.positionFixed = true;

                  this.sortEntitiesByZ(true);

                case 44:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee, this);
        }));

        function loadScene() {
          return _loadScene.apply(this, arguments);
        }

        return loadScene;
      }()
    }, {
      key: "regenerate",
      value: function regenerate(seed) {
        this.reloadGround(seed);
        this.reloadSnack();
        this.isLevelComplete = false;
        this.shotsTakenThisLevel = 0;
      }
    }, {
      key: "reloadGround",
      value: function () {
        var _reloadGround = _asyncToGenerator(
        /*#__PURE__*/
        regeneratorRuntime.mark(function _callee2(seed) {
          var difficulty, y_height_change, change_y_odds_change, rndHSV, scoobyPositionX, scoobyPositionY, scoobyPosition;
          return regeneratorRuntime.wrap(function _callee2$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  this.remove(this.ground);
                  difficulty = Math.min(this.levelsCompleted % CONFIG.meta.levelDifficultyRamp / CONFIG.meta.levelDifficultyRamp, 1);
                  y_height_change = CONFIG.meta.generator.y_height_range * difficulty; // Because this level is nice

                  if (seed === "thisispop") {
                    y_height_change = 30;
                    difficulty = 1;
                  }

                  change_y_odds_change = CONFIG.meta.generator.change_y_odds_range * difficulty;
                  this.ground = new Ground({
                    x_width: CONFIG.meta.generator.x_width,
                    y_width: CONFIG.meta.generator.y_width,
                    change_y_odds: CONFIG.meta.generator.change_y_odds + change_y_odds_change,
                    ground_friction: CONFIG.meta.generator.ground_friction,
                    y_height: CONFIG.meta.generator.y_height + y_height_change,
                    seed: seed
                  });
                  this.add(this.ground); // Re-randomize bg color

                  rndHSV = [this.score / 100, 1, 0]; // this.background.HSV = rndHSV;
                  // this.moon.HSV = rndHSV;
                  // this.moonOverlay.HSV = rndHSV;
                  // Add scooby

                  scoobyPositionX = (this.ground.segments.x[this.ground.scoobySegment] + this.ground.segments.x[this.ground.scoobySegment - 1]) / 2;
                  scoobyPositionY = this.ground.height - (this.ground.segments.y[this.ground.scoobySegment] + this.ground.segments.y[this.ground.scoobySegment - 1]) / 2 + 60; // Check if scooby is on screen

                  if (!(this.ground.scoobySegment < 0 || scoobyPositionX < 100 || scoobyPositionX > 1250)) {
                    _context2.next = 14;
                    break;
                  }

                  _context2.next = 13;
                  return this.reloadGround();

                case 13:
                  return _context2.abrupt("return", _context2.sent);

                case 14:
                  scoobyPosition = [scoobyPositionX, scoobyPositionY, 1];
                  this.remove(this.scooby);
                  this.scooby = this.addActor({
                    cls: "CH-Scooby",
                    position: scoobyPosition
                  }, true);
                  this.shotsTakenThisLevel = 0;
                  this.ballRestCount = 0;

                case 19:
                case "end":
                  return _context2.stop();
              }
            }
          }, _callee2, this);
        }));

        function reloadGround(_x) {
          return _reloadGround.apply(this, arguments);
        }

        return reloadGround;
      }()
    }, {
      key: "reloadSnack",
      value: function reloadSnack() {
        var ballPositionX = (this.ground.segments.x[this.ground.ballSegment] + this.ground.segments.x[this.ground.ballSegment - 1]) / 2;
        var ballPositionY = this.ground.height - (this.ground.segments.y[this.ground.ballSegment] + this.ground.segments.y[this.ground.ballSegment - 1]) / 2 + 13;
        ballPositionY += 50; //if(this.score === 0) 

        var snackPosition = [ballPositionX, ballPositionY, 1]; // Add snack

        this.remove(this.snack);
        this.snack = this.addActor({
          cls: "OB-Snack",
          position: snackPosition,
          scale: [this.cheats.snackSize, this.cheats.snackSize, 1]
        }, true);
      }
    }, {
      key: "addActor",
      value: function addActor(actor) {
        var addToScene = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
        var actorClass = actor.cls;
        var newActor;

        if (CONFIG.classes[actorClass] === undefined) {
          console.log("Actor class \"".concat(actorClass, "\" does not exist."));
          return;
        }

        var behavior = actor.behavior !== undefined ? actor.behavior : CONFIG.classes[actorClass].behavior;

        if (behavior) {
          newActor = new behavior(CONFIG.classes[actorClass], actor);
        } else {
          newActor = new Actor(CONFIG.classes[actorClass], actor);
        }

        if (!this.actors[actorClass]) this.actors[actorClass] = [];
        this.actors[actorClass].push(newActor);
        if (addToScene) this.add(newActor);
        this.sortEntitiesByZ(true);
        if (this.overlay) this.entities.push(this.entities.splice(this.entities.indexOf(this.overlay), 1)[0]);
        return newActor;
      }
    }, {
      key: "removeActor",
      value: function removeActor(actor) {
        var removeFromScene = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
        if (!actor) return;
        var index = this.actors[actor.className].indexOf(actor);
        this.actors[actor.className].splice(index, 1);
        if (removeFromScene) this.remove(actor);
      }
    }, {
      key: "getPhysicsWorldCoordinates",
      value: function getPhysicsWorldCoordinates() {
        var min = this.cameras[0].unproject(this.viewports[0], 0, 0, 1);
        var max = this.cameras[0].unproject(this.viewports[0], this.viewportElements[0].width, this.viewportElements[0].height, 1);
        this.physicsWorldView = {
          min: {
            x: min[0],
            y: min[1]
          },
          max: {
            x: max[0],
            y: max[1]
          },
          width: max[0] - min[0],
          height: max[1] - min[1]
        };
      }
    }, {
      key: "setupMatter",
      value: function setupMatter() {
        this.matterEngine = Matter.Engine.create({
          enableSleeping: true,
          positionIterations: CONFIG.meta.physics.positionIterations,
          velocityIterations: CONFIG.meta.physics.velocityIterations,
          constraintIterations: CONFIG.meta.physics.constraintIterations
        }); // Gravity

        this.matterEngine.world.gravity.y = CONFIG.meta.physics.gravity; // Mouse
        // this.matterMouse = Matter.Mouse.create(this.viewports[0].contextElement);
        // this.mouseConstraint = Matter.MouseConstraint.create(this.matterEngine, {
        //     mouse: this.matterMouse,
        //     collisionFilter: {
        //         category: COLLISION_CATEGORY_MOUSE,
        //         mask: COLLISION_MASK_MOUSE
        //     },
        //     constraint: {
        //         stiffness: 0.2,
        //         render: {
        //             visible: true
        //         }
        //     }
        // });
        // Matter.Events.on(this.mouseConstraint, "enddrag", () => {
        //     this.slingshot.launch();
        // });
        // Collision

        Matter.Events.on(this.matterEngine, 'collisionStart', function (event) {
          var _iteratorNormalCompletion = true;
          var _didIteratorError = false;
          var _iteratorError = undefined;

          try {
            for (var _iterator = event.pairs[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
              var pair = _step.value;
              if (!pair.bodyA.prevVelocity || !pair.bodyB.prevVelocity) continue;
              var bodyAMomentum = Matter.Vector.mult(pair.bodyA.prevVelocity, pair.bodyA.mass);
              var bodyBMomentum = Matter.Vector.mult(pair.bodyB.prevVelocity, pair.bodyB.mass);
              var relativeMomentum = Matter.Vector.sub(bodyAMomentum, bodyBMomentum);
              if (pair.bodyA.parentEntity && pair.bodyA.parentEntity.onCollide) pair.bodyA.parentEntity.onCollide({
                event: event,
                relativeMomentum: Matter.Vector.magnitude(relativeMomentum)
              });
              if (pair.bodyB.parentEntity && pair.bodyB.parentEntity.onCollide) pair.bodyB.parentEntity.onCollide({
                event: event,
                relativeMomentum: Matter.Vector.magnitude(relativeMomentum)
              }); // console.log(Matter.Vector.magnitude(relativeMomentum));
            }
          } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion && _iterator["return"] != null) {
                _iterator["return"]();
              }
            } finally {
              if (_didIteratorError) {
                throw _iteratorError;
              }
            }
          }
        }); // Add to the world
        // Matter.World.add(this.matterEngine.world, [this.mouseConstraint]);

        {
          this.matterRender = Matter.Render.create({
            element: document.getElementById('matter-debug'),
            engine: this.matterEngine,
            // mouse: this.matterMouse,
            options: {
              width: this.viewportElements[0].width,
              height: this.viewportElements[0].height,
              // pixelRatio: 10,
              wireframeBackground: 'rgba(0,0,0,0.1)',
              showSleeping: true,
              showDebug: false,
              showBroadphase: false,
              showBounds: false,
              showVelocity: true,
              showCollisions: false,
              showSeparations: false,
              showAxes: false,
              showPositions: false,
              showAngleIndicator: true,
              showIds: false,
              showShadows: false,
              showVertexNumbers: false,
              showConvexHulls: false,
              showInternalEdges: false,
              showMousePosition: false //true

            }
          });
        }
      }
    }, {
      key: "showToasty",
      value: function showToasty(state, allowCameos) {
        var _this8 = this;

        // this.cameosUsed = [];
        // Select        
        if (!state) {
          // // Clear cameosUsed if all cameos have been used
          // if(this.cameosUsed.length === CONFIG.meta.cameos.length + CONFIG.meta.cameosAlt.length + CONFIG.meta.cameosVillains.length) this.cameosUsed = [this.toast.state];
          // // Get list of unused cameos
          // let list = CONFIG.meta.cameos.filter((el) => !this.cameosUsed.includes(el));
          // if(!list.length) list = CONFIG.meta.cameosAlt.filter((el) => !this.cameosUsed.includes(el));
          // if(!list.length) list = CONFIG.meta.cameosVillains.filter((el) => !this.cameosUsed.includes(el));
          // // Select random from list
          // state = list[(Math.random() * list.length) | 0];
          if (this.levelsCompleted % 25 === 0) {
            var list = [];

            while (!list.length) {
              list = CONFIG.meta.cameosGang.filter(function (el) {
                return !_this8.cameosGangUsed.includes(el);
              });
              if (!list.length) this.cameosGangUsed = [];
            }

            state = list[0]; // list[(Math.random() * list.length) | 0];

            this.cameosGangUsed.push(state);
          } else {
            var bgIndex = CONFIG.meta.backgrounds.indexOf(this.background.state);
            if (bgIndex < 0) bgIndex = 0;

            if (allowCameos || this.allowCameos) {
              // Primary
              state = CONFIG.meta.cameos[bgIndex];

              if (this.cameosUsed.indexOf(state) > -1) {
                // Villains
                state = CONFIG.meta.cameosVillains[bgIndex];
              }

              if (this.cameosUsed.indexOf(state) > -1) {
                // Alt
                state = CONFIG.meta.cameosAlt[bgIndex];
              }

              if (this.cameosUsed.indexOf(state) > -1) {
                // All used
                this.cameosUsed = [];
                state = CONFIG.meta.cameos[bgIndex];
              }

              this.cameosUsed.push(state);
            }
          }
        }

        if (state) {
          state = state + ""; // To fix transpiler bug

          this.toast.show(state);
        }
      }
    }, {
      key: "onCompleted",
      value: function onCompleted() {
        var _this9 = this;

        var holeInOne = this.shotsTakenThisLevel <= 1;
        this.isLevelComplete = true;
        var additionalScore = 0;
        this.levelsCompleted++;

        if (holeInOne) {
          additionalScore = CONFIG.meta.score.holeInOne + this.inARow;
          this.inARow++;
          this.score++;
          this.cookiesLeft += 2;
        } else {
          additionalScore = CONFIG.meta.score.goal;
          this.cookiesLeft += 1;
          this.inARow = 0;
        }

        for (var i = 0; i < additionalScore; i++) {
          this.setTimeout(function () {// this.score++;
          }, 100 * i);
        }

        this.removeActor(this.snack);
        this.reset.hideInstructions();
        game.playSFX("SD-SnackBite"); // Play music

        if (this.music) {
          game.fadeMusic(this.music, 1, undefined, 6000); // Fade in second track if doing really well

          if (this.inARow > 1) {
            game.fadeMusic(this.music2, 1, undefined, 6000);
          } else {
            game.fadeMusic(this.music2, 0, undefined, 6000);
          }
        }

        this.setTimeout(function () {
          _this9.scooby.showHearts(additionalScore, holeInOne);

          if (_this9.shotsTakenThisLevel <= 1) {
            game.playSFX("SD-Win-HIO-1");
            _this9.scooby.state = "CHEW-B";
          } else if (_this9.shotsTakenThisLevel <= 2) {
            game.playSFX("SD-Win-HIO-2");
            _this9.scooby.state = "CHEW-A";
          } else {
            game.playSFX("SD-Win-HIO-3");
            _this9.scooby.state = "CHEW-A";
          }
        }, 200); // Start a new level

        this.setTimeout(function () {
          if (holeInOne || _this9.currentBackground === "BG-14") {
            _this9.selectNewBackground();
          } else if (_this9.levelsCompleted % 25 === 0) {
            _this9.showToasty();
          }

          _this9.regenerate();
        }, 2000);
        if (this.levelsCompleted > 99) this.txtCompleted.visible = true;
        this.saveStats();
      }
    }]);

    return Game;
  }(Scene);

  var GameOver =
  /*#__PURE__*/
  function (_Onyx$Scene) {
    _inherits(GameOver, _Onyx$Scene);

    function GameOver() {
      var _this;

      _classCallCheck(this, GameOver);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(GameOver).call(this));
      _this.renderPasses = [new RenderPass({
        viewportClear: true
      })];
      _this.actors = {};
      _this.sprites = {};
      _this.mouseDown = false;
      _this.gamepadButtonState = [];
      _this.listenerClick = {
        handleEvent: function handleEvent(evt) {
          return _this.onClick(evt);
        }
      };
      _this.listenerMouseDown = {
        handleEvent: function handleEvent(evt) {
          return _this.onMouseDown(evt);
        }
      };
      return _this;
    }

    _createClass(GameOver, [{
      key: "onload",
      value: function onload() {
        var _this2 = this;

        var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
            _ref$reason = _ref.reason,
            reason = _ref$reason === void 0 ? "fall" : _ref$reason,
            _ref$newHighScore = _ref.newHighScore,
            newHighScore = _ref$newHighScore === void 0 ? false : _ref$newHighScore,
            _ref$letterbox = _ref.letterbox,
            letterbox = _ref$letterbox === void 0 ? false : _ref$letterbox,
            _ref$fadeIn = _ref.fadeIn,
            fadeIn = _ref$fadeIn === void 0 ? false : _ref$fadeIn;

        // this.viewports[0].id = 0; // Hotfix so it doesn't reload the textures (It's creating a new viewport object every scene)
        this.viewports = game.router.map.preloader.module.viewports; // this.viewports[0].listenForMouseEvents({ scene: game.router.map.gameover.module, renderPick: true });
        // this.viewports = game.router.map.preloader.module.viewports;
        // this.viewports[0].mouseEventHover = false;

        this.gamepadButtonState = [];
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = game.gamepads[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var gamepad = _step.value;

            for (var i in gamepad.buttons) {
              this.gamepadButtonState[i] = gamepad.buttons[i].pressed;
            }
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator["return"] != null) {
              _iterator["return"]();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }

        this.ready = false;
        this.reason = reason;
        this.renderPasses = [new RenderPass()];
        this.loadScene().then(function () {
          _this2.transitionOverlay = new TransitionOverlay({
            isShowingLetterbox: letterbox,
            isFaded: fadeIn
          });

          _this2.add(_this2.transitionOverlay);

          if (fadeIn) _this2.transitionOverlay.fadeIn();
          _this2.transitionOverlay.transform.xyz = [1300, 0, -10];
          _this2.transitionOverlay.transform.sxyz = [0.9, 0.9, 1];
          _this2.transitionOverlay.transform.positionFixed = true;

          _this2.sortEntitiesByZ(true);

          if (_this2.transitionOverlay) _this2.entities.push(_this2.entities.splice(_this2.entities.indexOf(_this2.transitionOverlay), 1)[0]); // game.playMusic("AO-Music");

          _this2.complete = false;

          _this2.animateScene(newHighScore);
        });

        this.onKeyDown = function (evt) {
          _this2.onClick(evt);
        };

        window.addEventListener("keydown", this.onKeyDown);
        this.viewports[0].contextElement.addEventListener("mousedown", this.listenerMouseDown);
        this.viewports[0].contextElement.addEventListener("touchstart", this.listenerMouseDown);
      }
    }, {
      key: "onunload",
      value: function onunload() {
        this.entities = [];
        this.cameras = []; // this.viewports[0].bindToCamera();
        // this.viewports[0].removeMouseListenEvents({ scene: this });

        window.removeEventListener("keydown", this.onKeyDown);
        this.viewports[0].contextElement.removeEventListener("mousedown", this.listenerMouseDown);
        this.viewports[0].contextElement.removeEventListener("touchstart", this.listenerMouseDown); // Cleanup

        this.entities = [];
        this.components = []; // Clear

        this.actors = {};
      }
    }, {
      key: "update",
      value: function update() {
        _get(_getPrototypeOf(GameOver.prototype), "update", this).apply(this, arguments); // Poll gamepads


        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
          for (var _iterator2 = game.gamepads[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var gamepad = _step2.value;

            for (var i in gamepad.buttons) {
              var pressed = gamepad.buttons[i].pressed;

              if (this.gamepadButtonState[i] !== pressed) {
                this.gamepadButtonState[i] = pressed;

                if (pressed) {
                  // Dash
                  if (!CONFIG.meta.buttons.gamepad["continue"].length || CONFIG.meta.buttons.gamepad["continue"].indexOf(i * 1) > -1) {
                    this.onClick({
                      type: "gamepad",
                      button: i
                    });
                  }
                }
              }
            }
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
              _iterator2["return"]();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }
      }
    }, {
      key: "onMouseDown",
      value: function onMouseDown(evt) {
        this.mouseDown = true;
        this.onClick(evt);
      }
    }, {
      key: "onMouseUp",
      value: function onMouseUp(evt) {
        this.mouseDown = false;
        this.onClick(evt);
      }
    }, {
      key: "onClick",
      value: function onClick(evt) {
        if (this.complete || !this.ready) return;
        this.complete = true;
        this.mouseDown = false;
        this.nextScene(evt);
      }
    }, {
      key: "nextScene",
      value: function nextScene(evt) {
        var _this3 = this;

        game.playSFX("UI-button-0" + Math.ceil(Math.random() * 3));
        this.transitionOverlay.fadeOut(function () {
          _this3.onunload();

          router.navigate("game", {
            showInstructions: false,
            evt: evt
          });
        });
      }
    }, {
      key: "loadScene",
      value: function () {
        var _loadScene = _asyncToGenerator(
        /*#__PURE__*/
        regeneratorRuntime.mark(function _callee() {
          var _this4 = this;

          var camera;
          return regeneratorRuntime.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  camera = new Camera({
                    projectionType: "orthographic",
                    transform: new Transform({
                      position: [0, 1105, 100]
                    })
                  });
                  this.add(camera);
                  this.viewports[0].bindToCamera(camera); // Background

                  this.addActor({
                    cls: "BG-FlickVert",
                    position: [0, 1105, 0]
                  });
                  this.addActor({
                    cls: "BG-GameOver",
                    position: [0, 0, 0]
                  }); // MaoMao

                  this.maomao = this.addActor({
                    cls: "CH-MaoMao-GO",
                    position: [410, 1500, 4],
                    state: this.reason === "fall" ? "flap" : "fall"
                  }); // BC

                  this.badger = this.addActor({
                    cls: "CH-Badger",
                    position: [700, 270, 1]
                  }); // AB

                  this.adorabat = this.addActor({
                    cls: "CH-Adorabat",
                    position: [700, 10000, 1.5]
                  }); // Trophy

                  this.trophy = this.addActor({
                    cls: "OB-Trophy",
                    position: [1110, 2300, 2]
                  }); // Trophy mask

                  this.addActor({
                    cls: "OB-Trophy-Mask",
                    position: [1120, 95, 3]
                  }); // UI Trophy

                  this.addActor({
                    cls: "UI-Trophy",
                    position: [1180, 107, 3]
                  }); // Arrow

                  this.addActor({
                    cls: "UI-Arrow",
                    position: [1250, 300, 3]
                  }); // Snow

                  this.snow = this.addActor({
                    cls: "FX-Snow",
                    position: [0, 0, 4]
                  });
                  this.slash = this.addActor({
                    cls: "UI-Slash",
                    position: [1257, 170, 80],
                    scale: [0.80, 0.80, 1],
                    events: {
                      onReady: function onReady() {
                        _this4.slash.sprite.currentAnimation.pause();

                        var count = game.router.map.game.module.levelsPlayed.length;

                        if (count > 1) {
                          _this4.slash.sprite.currentAnimation.setFrame(count - 2);
                        } else {
                          _this4.slash.visible = false;
                        }
                      }
                    }
                  }, true); // Score text

                  this.txtPrevScore = new Text({
                    glyphSpriteSheet: game.spritesheets["mm-glyphs.json"],
                    glyphAnimation: "UI",
                    glyphCharacters: "0123456789,-+./x",
                    text: game.router.map.game.module.score + "",
                    align: "center",
                    alignVertical: "bottom",
                    tracking: -4
                  });
                  this.txtPrevScore.transform.xyz = [1257, 57, 80];
                  this.txtPrevScore.transform.sxyz = [0.8, 0.8, 0.8]; // this.txtPrevScore.HSV = [0, -1, 0];

                  this.add(this.txtPrevScore); // High Score text

                  this.txtScore = new Text({
                    glyphSpriteSheet: game.spritesheets["mm-glyphs.json"],
                    glyphAnimation: "UI",
                    glyphCharacters: "0123456789,-+./x",
                    text: game.router.map.game.module.highscores[0] + "",
                    align: "center",
                    alignVertical: "bottom",
                    tracking: -2
                  });
                  this.txtScore.transform.xyz = [1257, 90, 80];
                  this.txtScore.transform.sxyz = [0.8, 0.8, 0.8]; // this.txtScore.HSV = [0, -1, 0];

                  this.add(this.txtScore); //     this.button = new Actor(CONFIG.classes['TC-Button'], {
                  //         position: [95, 0, 10]
                  //     });
                  //     this.add(this.button);
                  //     this.cat = new Actor(CONFIG.classes['TC-Cat'], {
                  //         position: [95, 0, 11]
                  //     });
                  //     this.add(this.cat);

                case 22:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee, this);
        }));

        function loadScene() {
          return _loadScene.apply(this, arguments);
        }

        return loadScene;
      }()
    }, {
      key: "addActor",
      value: function addActor(actor) {
        var addToScene = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
        var actorClass = actor.cls;
        var newActor;

        if (CONFIG.classes[actorClass] === undefined) {
          console.log("Actor class \"".concat(actorClass, "\" does not exist."));
          return;
        }

        var behavior = actor.behavior !== undefined ? actor.behavior : CONFIG.classes[actorClass].behavior;

        if (behavior) {
          newActor = new behavior(CONFIG.classes[actorClass], actor);
        } else {
          newActor = new Actor(CONFIG.classes[actorClass], actor);
        }

        if (!this.actors[actorClass]) this.actors[actorClass] = [];
        this.actors[actorClass].push(newActor);
        if (addToScene) this.add(newActor);
        this.sortEntitiesByZ(true);
        if (this.transitionOverlay) this.entities.push(this.entities.splice(this.entities.indexOf(this.transitionOverlay), 1)[0]);
        return newActor;
      }
    }, {
      key: "removeActor",
      value: function removeActor(actor) {
        var removeFromScene = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
        if (!actor) return;
        var index = this.actors[actor.className].indexOf(actor);
        this.actors[actor.className].splice(index, 1);
        if (removeFromScene) this.remove(actor);
      }
    }, {
      key: "shakeCamera",
      value: function shakeCamera() {
        var _this5 = this;

        var force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 200;
        var decay = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.88;
        var speed = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 55;
        // let polarity = 1;
        var startX = this.cameras[0].transform.x;
        var startY = this.cameras[0].transform.y; // this.from + ((this.to - this.from) * this.method(this.percentComplete))

        var shake = this.setModulate(function (dt, progress, count) {
          progress = (progress - 0.5) * 2;
          var to = _this5.cameras[0].transform.y + force;
          var from = _this5.cameras[0].transform.y;
          var v = 0 + (force - 0) * (-Math.cos(progress * Math.PI) / 2 + 0); // var v = 0 + (Math.PI-0)*((-Math.cos(progress*Math.PI)/2) + 0);
          // var angle = (Math.PI / 2) * polarity;
          // var px = Math.cos(angle) * force;
          // var py = Math.sin(angle) * force;
          // this.cameras[0].transform.x = startX + px;

          _this5.cameras[0].transform.y = startY + v;
          force *= decay; // polarity *= -1;

          if (force < 0.1) {
            _this5.removeComponent(shake);

            _this5.cameras[0].transform.x = startX;
            _this5.cameras[0].transform.y = startY;
          }
        }, speed);
      } // shakeCamera2(){
      //     let frameTime = 1000 / 60;
      //     this.setTimeout(() => {
      //     })
      // }

    }, {
      key: "animateScene",
      value: function animateScene(newHighScore) {
        var _this6 = this;

        if (!newHighScore) this.trophy.visible = false; // Show falling anim for a moment

        this.setTimeout(function () {
          // Slide camera down
          _this6.setTween({
            propParent: _this6.cameras[0].transform,
            property: "y",
            to: 0,
            from: 335,
            method: "linear",
            duration: 250,
            onComplete: function onComplete() {
              // Flash strike marks
              _this6.setInterval(function () {
                var isBlink = _this6.slash.HSV[0] !== 0;

                if (isBlink) {
                  _this6.slash.HSV = [0, 0, 0];
                } else {
                  _this6.slash.HSV = [1, -1, 1];
                }
              }, 1000 / 12, 6); // Drop adorabat


              _this6.setTimeout(function () {
                _this6.adorabat.state = "idle";

                _this6.setTween({
                  propParent: _this6.adorabat.transform,
                  property: "y",
                  to: 270,
                  from: 1000,
                  method: "linear",
                  duration: 100,
                  onComplete: function onComplete() {
                    if (newHighScore) {
                      _this6.badger.state = "abbc";
                    } else {
                      _this6.badger.state = "abbc-nohs";
                    } // this.badger.sprite.currentAnimation.frames[1].onStart = () => {


                    _this6.adorabat.visible = false; // }

                    _this6.badger.sprite.currentAnimation.frames[2].onStart = function () {
                      // Shake camera
                      _this6.shakeCamera(30, 0.81, 10);

                      game.playSFX("SB-ICE-HitOne");
                      _this6.ready = true;
                    };

                    _this6.badger.sprite.currentAnimation.frames[7].onStart = function () {
                      game.playSFX("SB-ICE-HitTwo");
                    };

                    _this6.badger.sprite.currentAnimation.callback = function () {
                      if (newHighScore) {
                        _this6.badger.state = "abbc-loop";
                      } else {
                        _this6.badger.state = "abbc-nohs-loop";
                      }
                    };
                  }
                });
              }, newHighScore ? 2000 : 1000);

              if (newHighScore) {
                // Wait a beat...
                _this6.setTimeout(function () {
                  // Drop trophy
                  _this6.setTween({
                    propParent: _this6.trophy.transform,
                    property: "y",
                    to: 330,
                    from: 2000,
                    method: "linear",
                    duration: 100,
                    onComplete: function onComplete() {
                      // Show dust
                      _this6.dust = _this6.addActor({
                        cls: "FX-DustCloud",
                        position: [_this6.trophy.transform.x - 155, _this6.trophy.transform.y - 125, _this6.trophy.transform.z - 0.1]
                      }); // Shake camera

                      _this6.shakeCamera();

                      _this6.setTimeout(function () {
                        _this6.dust.sprite.currentAnimation.callback = function () {
                          _this6.removeActor(_this6.dust);
                        };
                      }, 128);

                      game.playSFX("GO-trophy-hit"); // Sparkles

                      _this6.setTimeout(function () {
                        game.playSFX("GO-sparkle-01");
                        _this6.sparkle1 = _this6.addActor({
                          cls: "FX-Sparkle",
                          position: [_this6.trophy.transform.x + 95, _this6.trophy.transform.y + 235, _this6.trophy.transform.z + 0.1]
                        });
                      }, 500);

                      _this6.setTimeout(function () {
                        _this6.sparkle2 = _this6.addActor({
                          cls: "FX-Sparkle",
                          position: [_this6.trophy.transform.x - 35, _this6.trophy.transform.y + 60, _this6.trophy.transform.z + 0.1]
                        });
                      }, 880); // Wait a few until music is all the way faded


                      _this6.setTimeout(function () {
                        _this6.ready = true;
                      }, 100);
                    }
                  });
                }, 1300);
              }
            }
          }); // MaoMao fall


          _this6.maomao.state = "fall";

          _this6.setTween({
            propParent: _this6.maomao.transform,
            property: "y",
            to: 200,
            from: 2000,
            method: "linear",
            duration: 250,
            onComplete: function onComplete() {
              _this6.maomao.state = "land";

              _this6.setTimeout(function () {
                _this6.maomao.state = "rest"; // Shake camera

                _this6.shakeCamera();
              }, 32);

              game.playSFX("GO-trophy-hit"); // Show dust

              _this6.dust1 = _this6.addActor({
                cls: "FX-DustPuff",
                position: [_this6.maomao.transform.x - 150, _this6.maomao.transform.y + 50, _this6.maomao.transform.z - 0.1],
                events: {
                  onReady: function onReady() {
                    _this6.dust1.sprite.currentAnimation.callback = function () {
                      _this6.removeActor(_this6.dust1);

                      _this6.removeActor(_this6.dust2);
                    };
                  }
                }
              });
              _this6.dust2 = _this6.addActor({
                cls: "FX-DustPuff",
                position: [_this6.maomao.transform.x + 150, _this6.maomao.transform.y + 20, _this6.maomao.transform.z + 0.1],
                scale: [-1.5, 1.5, 1]
              });
            }
          }); // Snow fall


          _this6.setTween({
            propParent: _this6.snow.transform,
            property: "y",
            to: -5000,
            from: 0,
            method: "linear",
            duration: 100000
          });
        }, 500);
      }
    }]);

    return GameOver;
  }(Scene);

  window.decomp = decomp; // Howler.autoUnlock = false;
  var errorConsole = new ErrorConsole({
    elementId: 'error-console',
    alertOnError: false,
    ignoreMessages: ["[Onyx] Couldn't initialize WebGL"]
  }); // Import Onyx
  CONST.AUTO_DETECT_DEVICE_PIXEL_RATIO = true;
  CONST.SHADOWS_VSM_ENABLED = false;
  CONST.LIGHTING_ENABLED = false;
  CONST.DIRECTIONAL_SHADOWS_ENABLED = false;
  CONST.DEFAULT_SHADOW_BIAS = 0.000001;
  CONST.MAX_LIGHTS = 2; // Import Scenes

  var Game$1 =
  /*#__PURE__*/
  function () {
    function Game$1() {
      _classCallCheck(this, Game$1);

      this.music = [];
      this.sfx = [];
      this.spritesheets = [];
      this.videos = [];
      this.textures = {};
      this.muted = false; // this.gamepads = this.getGamepads();

      this.SPRITE_SCALE = 1366 / 1560 / 1;
      this.router = new Router({
        clock: new Clock(),
        map: {
          "preloader": {
            module: new ScenePreloader()
          },
          "title": {
            module: new GameTitle()
          },
          "intro": {
            module: new SceneIntro()
          },
          "game": {
            module: new Game()
          },
          "gameover": {
            module: new GameOver()
          }
        }
      }); // window.addEventListener("gamepadconnected", (e) => {
      //     this.gamepads = this.getGamepads();
      // });
      // window.addEventListener("gamepaddisconnected", (e) => {
      //     this.gamepads = this.getGamepads();
      // });
    }

    _createClass(Game$1, [{
      key: "toggleMute",
      value: function toggleMute() {
        this.muted = !this.muted;
        Howler.mute(this.muted);
        document.getElementById('snd-btn').classList = Howler._muted ? "off" : "on";
      }
    }, {
      key: "start",
      value: function start() {
        this.router.navigate("preloader");
      }
    }, {
      key: "playSFX",
      value: function playSFX(name) {
        var fadeTime = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        var id = arguments.length > 2 ? arguments[2] : undefined;
        var volume = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;

        if (!this.sfx[name]) {
          console.warn("SFX '".concat(name, "' not found."));
          return;
        }

        var i = this.sfx[name].play();
        this.sfx[name].fade(0, volume, fadeTime, id);
        return i;
      }
    }, {
      key: "stopSFX",
      value: function stopSFX(name) {
        var _this = this;

        var fadeTime = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        var id = arguments.length > 2 ? arguments[2] : undefined;

        if (!this.sfx[name]) {
          console.warn("SFX '".concat(name, "' not found."));
          return;
        }

        this.sfx[name].once('fade', function () {
          _this.sfx[name].stop(id);
        }, id);
        this.sfx[name].fade(1, 0, fadeTime, id);
      }
    }, {
      key: "playRandomSFX",
      value: function playRandomSFX() {
        var list = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
        var fadeTime = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        var id = arguments.length > 2 ? arguments[2] : undefined;
        var volume = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
        // Check for wildcard
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = list[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var item = _step.value;

            if (item.indexOf("#") > -1) {
              for (var _i = 0, _Object$keys = Object.keys(this.sfx); _i < _Object$keys.length; _i++) {
                var sfx = _Object$keys[_i];

                if (sfx.indexOf(item.split("#")[0]) > -1) {
                  list.push(sfx);
                }
              }

              list.splice(list.indexOf(item), 1);
            }
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator["return"] != null) {
              _iterator["return"]();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }

        return this.playSFX(list[Math.random() * list.length | 0], fadeTime = 0, id, volume = 1);
      }
    }, {
      key: "playMusic",
      value: function playMusic(name, stopOthers) {
        if (!this.music[name]) {
          console.warn("Music '".concat(name, "' not found."));
          return;
        }

        if (stopOthers) this.music[name].stop();
        var music = this.music[name].play();
        this.music[name].volume(1, music);
        return name;
      }
    }, {
      key: "stopMusic",
      value: function stopMusic(name) {
        var _this2 = this;

        var time = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        var id = arguments.length > 2 ? arguments[2] : undefined;
        this.music[name].fade(1, 0, time, id);

        if (time) {
          window.setTimeout(function () {
            _this2.music[name].stop();

            _this2.music[name].volume(1);
          }, time);
        }
      }
    }, {
      key: "playRandomMusic",
      value: function playRandomMusic() {
        var list = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
        var stopOthers = arguments.length > 1 ? arguments[1] : undefined;
        // Check for wildcard
        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
          for (var _iterator2 = list[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var item = _step2.value;

            if (item.indexOf("#") > -1) {
              for (var _i2 = 0, _Object$keys2 = Object.keys(this.music); _i2 < _Object$keys2.length; _i2++) {
                var music = _Object$keys2[_i2];

                if (music.indexOf(item.split("#")[0]) > -1) {
                  list.push(music);
                }
              }

              list.splice(list.indexOf(item), 1);
            }
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
              _iterator2["return"]();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }

        return this.playMusic(list[Math.random() * list.length | 0], stopOthers);
      }
    }, {
      key: "fadeMusic",
      value: function fadeMusic(name, toVol) {
        var fromVol = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : game.music[name].volume();
        var fadeTime = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
        var id = arguments.length > 4 ? arguments[4] : undefined;
        this.music[name].fade(fromVol, toVol, fadeTime, id);
      }
    }, {
      key: "toggleErrorConsole",
      value: function toggleErrorConsole() {
        if (errorConsole.consoleElement.display != "none") {
          errorConsole.showConsole();
        } else {
          errorConsole.hideConsole();
        }
      }
    }, {
      key: "gamepadConnected",
      value: function gamepadConnected() {}
    }, {
      key: "gamepads",
      get: function get() {
        var list = [];
        var gamepads = navigator.getGamepads ? navigator.getGamepads() : navigator.webkitGetGamepads ? navigator.webkitGetGamepads : [];

        for (var i = gamepads.length - 1; i >= 0; i--) {
          if (gamepads[i]) list.push(gamepads[i]);
        }

        return list;
      }
    }]);

    return Game$1;
  }(); // Mute/Unmute sound on tab focus change


  var hidden, visibilityState, visibilityChange;

  if (typeof document.hidden !== "undefined") {
    hidden = "hidden", visibilityChange = "visibilitychange", visibilityState = "visibilityState";
  } else if (typeof document.msHidden !== "undefined") {
    hidden = "msHidden", visibilityChange = "msvisibilitychange", visibilityState = "msVisibilityState";
  }

  var document_hidden = document[hidden];
  document.addEventListener(visibilityChange, function () {
    if (document_hidden != document[hidden]) {
      if (document[hidden]) {
        // Document hidden
        Howler.mute(true);
      } else {
        // Document shown
        Howler.mute( game.muted);
      }

      document_hidden = document[hidden];
    }
  });
  window.game = new Game$1();
  window.router = window.game.router;
  window.game.start();

}());
